<!DOCTYPE html>
<html>

	<head>
		
<title>线段树-Remember me</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/logo.ico">


<meta name="keywords" content="Algorithm,note,ACM,">
<meta name="description" content="Segment Tree">


<script src="/js/jquery.min.js"></script>



<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?a9682086becb148caa4f1270cab9fc97";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


	<meta name="generator" content="Hexo 5.4.0"></head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.jpg" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>Maskros</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/qiaobug">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg bg-content-img">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/Algorithm">Algorithm</a></li>
            
            <li><a href="/tags/note">note</a></li>
            
            <li><a href="/tags/ACM">ACM</a></li>
            
            
        </ul>
        <h1>线段树</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
                    xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
                    <path
                        d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
                        p-id="2902" fill="#ffffff"></path>
                </svg>
                
                <span> <a href="">Maskros</a></span>
                <p>2021-08-06 16:14:31</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>Segment Tree</p>
<blockquote>
<p>一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来艹了</p>
</blockquote>
<hr>
<p>原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2,b]。</p>
<p>作用：对编号连续的一些点的区间信息进行修改或者统计操作，用线段树统计的东西，必须符合<strong>区间加法</strong>。与树状数组不同的是，线段树不止适用于区间求和的查询，也可以进行区间最大值，区间最小值，或者区间异或值的查询。</p>
<p>主要操作：区间查询、点更新、区间更新</p>
<p>例如：</p>
<ul>
<li>给定s和t，求其区间上的最小值</li>
<li>给定i和x，把ai的值改成x</li>
</ul>
<p>更新和区间查询的复杂度都是 <strong>O(log(N))</strong></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><blockquote>
<p>build, update(内含push_down), query</p>
</blockquote>
<h3 id="建树-build"><a href="#建树-build" class="headerlink" title="建树 (build)"></a>建树 (build)</h3><p>线段树是一棵平衡二叉树，每个节点都对应一条线段(区间)，反之不成立，每个节点 $p$ 的左右子节点的编号分别为 $2p$ 和 $2p+1$ ，假如节点 $p$ 储存区间 $[a,b]$ 的和，设 $mid=[\frac{l+r}{2}]$，那么两个子节点分别储存 $[l,mid]$ 和 $[mid+1,r]$ 的和。可以发现，左节点对应的区间长度，与右节点相同或者比之恰好多 $1$。</p>
<p>故建树可考虑递归进行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll l = <span class="hljs-number">1</span>, ll r = n, ll p = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-comment">// 到达叶子节点</span><br>        tree[p]=A[l]; <span class="hljs-comment">// 用数组中的数据赋值</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(l, mid, p * <span class="hljs-number">2</span>); <span class="hljs-comment">// 先建立左右子节点</span><br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 该节点的值等于左右子节点之和</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 这里👴偷了个 gif 来演示一下过程 (虽然大部分都是偷的🤡)</p>
<img src="https://pic4.zhimg.com/v2-c2d11b12c87b6a7076e3df0bb3585423_b.webp" alt="img" style="zoom:60%;" />

<h3 id="区间修改-update"><a href="#区间修改-update" class="headerlink" title="区间修改(update)"></a>区间修改(update)</h3><p>首先定义”<strong>懒标记</strong>“(即“延迟标记”) <code>mark[]</code>：</p>
<p>对于区间修改，朴素的想法是用<strong>递归</strong>的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个<strong>标记</strong>，将来要用到它的<strong>子区间</strong>的时候，再向下<strong>传递</strong></p>
<p>直接上🐴 (非最简):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll l, ll r, ll d, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l) <span class="hljs-comment">// 区间无交集</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) <span class="hljs-comment">// 当前节点对应的区间包含在目标区间中</span><br>    &#123;<br>        tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d; <span class="hljs-comment">// 更新当前区间的值</span><br>        <span class="hljs-keyword">if</span> (cr &gt; cl) <span class="hljs-comment">// 如果不是叶子节点</span><br>            mark[p] += d; <span class="hljs-comment">// 给当前区间打上标记</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 与目标区间有交集，但不包含于其中</span><br>    &#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        mark[p * <span class="hljs-number">2</span>] += mark[p]; <span class="hljs-comment">// 标记向下传递</span><br>        mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>        tree[p * <span class="hljs-number">2</span>] += mark[p] * (mid - cl + <span class="hljs-number">1</span>); <span class="hljs-comment">// 往下更新一层</span><br>        tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (cr - mid);<br>        mark[p] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 清除标记</span><br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span>, cl, mid); <span class="hljs-comment">// 递归地往下寻找</span><br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 根据子节点更新当前节点的值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>更新时，我们是从最大的区间开始，递归向下处理。注意到，<strong>任何区间都是线段树上某些节点的并集</strong>。于是我们记目标区间为 $[l,r] $，当前区间为 $[cl,cr]$ ， 当前节点为 $p$ ，我们会遇到三种情况：</p>
<ol>
<li><p>当前区间与目标区间没有交集：</p>
<p>直接结束递归</p>
</li>
<li><p>当前区间被包括在目标区间里：</p>
<p>可以更新区间，不能忘记乘上区间长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d;<br></code></pre></td></tr></table></figure>

<p>然后打上懒标记（叶子节点可以不打标记，因为不会再向下传递了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">mark[p] += d;	<span class="hljs-comment">//表示“该区间上每一个点都要加上d”。因为原来可能存在标记，所以是+=而不是=</span><br></code></pre></td></tr></table></figure></li>
<li><p>当前区间与目标区间相交，但不包含于其中:</p>
<p>这时把当前区间一分为二，分别进行处理。如果存在懒标记，要先把懒标记传递给子节点（注意也是+=，因为原来可能存在懒标记)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>mark[p * <span class="hljs-number">2</span>] += mark[p];<br>mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br></code></pre></td></tr></table></figure>

<p>两个子节点的值也就需要相应的更新（后面乘的是区间长度) :[p * 2] += mark[p] * (mid - cl + 1);</p>
<p>tree[p * 2 + 1] += mark[p] * (cr - mid);</p>
<p>不要忘记清除该节点的懒标记：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">mark[p]=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>因为贵标记和👴一样是个懒蛋，只往下传递一层，所以这个过程并不是递归的，以后要用再才继续传递。其实我们常常把这个传递过程封装成一个函数<strong>扑屎裆</strong> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>); <span class="hljs-comment">// 右边的区间可能要短一点</span><br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//这样儿 update() 里面调用的时候直接 push_down(p, cr - cl + 1); 就彳亍</span><br></code></pre></td></tr></table></figure>

<p>传递完标记后，再递归地去处理左右两个子节点就彳亍乐</p>
</li>
</ol>
<p>下面儿👴又偷了个视频展示一下区间 $[1,4]$ 加上 $1$ 的过程：</p>
<p><video src="https://vdn1.vzuu.com/SD/534181e0-23ad-11eb-905e-ca0d7949bec0.mp4?disable_local_cache=1&auth_key=1628242679-0-0-804945d6146979c7aa1236d8806960d8&f=mp4&bu=pico&expiration=1628242679&v=hw"></video></p>
<p>至于单点修改，只需要令左右端点相等即可~</p>
<h3 id="区间查询-query"><a href="#区间查询-query" class="headerlink" title="区间查询(query)"></a>区间查询(query)</h3><p>还就那个直接上🐴</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>        <span class="hljs-keyword">return</span> tree[p];<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid) + <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr); <br>        <span class="hljs-comment">// 上一行拆成三行写就和区间修改格式一致了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一样的递归，一样自顶至底地寻找，一样的合并信息，即插即用😍</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><blockquote>
<p>source : <strong>洛谷P3372 【模板】线段树 1</strong></p>
<p><strong>题目描述</strong><br>如题，已知一个数列，你需要进行下面两种操作：<br>1.将某区间每一个数加上x<br>2.求出某区间每一个数的和<br><strong>输入格式</strong><br>第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。<br>第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。<br>接下来M行每行包含3或4个整数，表示一个操作，具体如下：<br>操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k<br>操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和<br><strong>输出格式</strong><br>输出包含若干行整数，即为所有操作2的结果。</p>
</blockquote>
<hr>
<p>tips: 本模板分为龙鸣版和贵族版</p>
<h3 id="龙鸣version"><a href="#龙鸣version" class="headerlink" title="龙鸣version"></a>龙鸣version</h3><blockquote>
<p>(此龙鸣非彼龙鸣，意为把上面的龙鸣🐴整合起来):</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 100005</span><br>ll n, m, A[MAXN], tree[MAXN * <span class="hljs-number">4</span>], mark[MAXN * <span class="hljs-number">4</span>]; <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>);<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll l = <span class="hljs-number">1</span>, ll r = n, ll p = <span class="hljs-number">1</span>)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        tree[p] = A[l];<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(l, mid, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll l, ll r, ll d, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)&#123;<br>        tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d;<br>        <span class="hljs-keyword">if</span> (cr &gt; cl)<br>            mark[p] += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span>, cl, mid);<br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>        <span class="hljs-keyword">return</span> tree[p];<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid) + <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        A[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">build</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)&#123;<br>        ll opr = <span class="hljs-built_in">read</span>(), l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span> (opr == <span class="hljs-number">1</span>)&#123;<br>            ll d = <span class="hljs-built_in">read</span>();<br>            <span class="hljs-built_in">update</span>(l, r, d);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(l, r));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="贵族version"><a href="#贵族version" class="headerlink" title="贵族version"></a>贵族version</h3><blockquote>
<p><del>豪华升级plus</del>，本来想加个乘除的发现板子不兼容，👴是懒狗</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br>ll tree[MAXN &lt;&lt; <span class="hljs-number">2</span>], mark[MAXN &lt;&lt; <span class="hljs-number">2</span>], n, m, A[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> len)</span></span>&#123;<br>    tree[p &lt;&lt; <span class="hljs-number">1</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    mark[p &lt;&lt; <span class="hljs-number">1</span>] += mark[p];<br>    tree[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>);<br>    mark[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += mark[p];<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cl = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl == cr) &#123; tree[p] = A[cl]; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">int</span> mid = (cl + cr) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, cl, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    tree[p] = tree[p &lt;&lt; <span class="hljs-number">1</span>] + tree[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cl = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) <span class="hljs-keyword">return</span> tree[p];<br>    <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>    ll mid = (cl + cr) &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= l) ans += <span class="hljs-built_in">query</span>(l, r, p &lt;&lt; <span class="hljs-number">1</span>, cl, mid);<br>    <span class="hljs-keyword">if</span> (mid &lt; r) ans += <span class="hljs-built_in">query</span>(l, r, p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cl = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) &#123; tree[p] += d * (cr - cl + <span class="hljs-number">1</span>), mark[p] += d; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> mid = (cl + cr) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= l) <span class="hljs-built_in">update</span>(l, r, d, p &lt;&lt; <span class="hljs-number">1</span>, cl, mid);<br>    <span class="hljs-keyword">if</span> (mid &lt; r) <span class="hljs-built_in">update</span>(l, r, d, p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    tree[p] = tree[p &lt;&lt; <span class="hljs-number">1</span>] + tree[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><p>步骤：</p>
<ol>
<li>将问题转化成点信息和目标信息</li>
<li>将目标信息根据需要扩充成区间信息<ul>
<li>增加信息符合区间加法</li>
<li>增加标记支持区间操作</li>
</ul>
</li>
<li>代码中的主要模块：区间加法，标记下推，点信息-&gt;区间信息，各种操作(修改、查询…)</li>
</ol>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><blockquote>
<p>URAL1989 Subpalindromes  <a target="_blank" rel="noopener" href="https://blog.csdn.net/zearot/article/details/38921403">题解</a></p>
<p>给定一个字符串(长度&lt;=100000)，有两个操作。  1：改变某个字符。 2：判断某个子串是否构成回文串</p>
</blockquote>
<p>分析：</p>
<p>直接判断会超时，此处用 <strong>线段树维护字符串哈希</strong></p>
<p>对于一个字符串$a[0],a[1],…,a[n-1] $它对应的哈希函数为$a[0]+a[1]*K + a[2]*K^2 +…+a[n-1]*K^{n-1}$</p>
<p>再维护一个从右往左的哈希值：</p>
<p>$a[0]*K^{n-1} + a[1]*K^{n-2} +…+a[n-1]$</p>
<p><strong>若是回文串，则左右的哈希值会相等。而左右哈希值相等，则很大可能这是回文串。</strong></p>
<p>若出现误判，可以再用一个K2，进行二次哈希判断，可以减小误判概率。实现上，哈希值最好对某个质数取余数，这样分布更均匀。</p>
<p>解题模型：</p>
<ul>
<li>目标信息：某个区间的左，右哈希值</li>
<li>点信息：一个字符</li>
</ul>
<p>目标信息已经符合区间加法，所以<strong>区间信息=目标信息</strong></p>
<p>故线段树结构：</p>
<ul>
<li><p><strong>区间信息</strong>：区间哈希值</p>
</li>
<li><p><strong>点信息</strong>：一个字符</p>
</li>
</ul>
<p>核心：就是找到<strong>区间信息</strong>， 写好<strong>区间加法</strong></p>
<h3 id="最长连续零"><a href="#最长连续零" class="headerlink" title="最长连续零"></a>最长连续零</h3><blockquote>
<p>Codeforces 527C Glass Carving <a target="_blank" rel="noopener" href="https://blog.csdn.net/zearot/article/details/44759437">题解</a></p>
<p>给定一个矩形，不停地纵向/横向切割，问每次切割后，最大的矩形面积是多少</p>
</blockquote>
<p>分析：</p>
<p>最大矩形面积=最长的长*最宽的宽</p>
<p>长宽范围均为1e5，故用01序列表示每个点是否被切割</p>
<p>最长的长就是长的最长连续0的数量+1，宽同理，于是可用用线段树维护最长连续零</p>
<p>解题模型：</p>
<ul>
<li>目标信息：区间最长连续零的个数</li>
<li>点信息：0或1</li>
</ul>
<p>由于目标信息不符合区间加法，所以要扩充目标信息</p>
<p>故线段树结构：</p>
<ul>
<li><strong>区间信息</strong>：从左，右开始的最长连续零，本区间是否全零，本区间最长连续零</li>
<li><strong>点信息</strong>：0或1</li>
</ul>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote>
<p>Codeforces 558E A Simple Task <a target="_blank" rel="noopener" href="https://blog.csdn.net/zearot/article/details/48048559">题解</a></p>
<p>给定一个长度不超过1e5的字符串（小写英文字母），和不超过5000个操作，每个操作 L R K 表示给区间[L,R]的字符串排序，K=1为升序，K=0为降序。 最后输出最终的字符串</p>
</blockquote>
<p>解题模型：</p>
<ul>
<li>目标信息：区间的计数排序结果</li>
<li>点信息：一个字符</li>
</ul>
<p>目标信息是符合区间加法的，但是为了支持区间操作，还是需要扩充信息</p>
<p>故线段树结构：</p>
<ul>
<li><strong>目标信息</strong>：区间的计数排序结果，排序标记，排序种类（升降）</li>
<li><strong>点信息</strong>：一个字符</li>
</ul>
<h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>👴前面都没整太明白，这个待续</p>

    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    

    
    <a href="/2021/07/31/%E5%8D%9A%E5%BC%88%E8%AE%BA/">
        <div class="next">
            <span>下一篇</span>
            <p>博弈论</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2021 By Maskros. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/qiaobug">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>