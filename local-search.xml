<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STL使用手册</title>
    <link href="/2021/08/13/STL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/08/13/STL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="STL使用手册"><a href="#STL使用手册" class="headerlink" title="STL使用手册"></a>STL使用手册</h1><p>Standard Template Library</p><blockquote><p>又名《👴怕忘了先把他写下来》</p></blockquote><h2 id="我-是-谁"><a href="#我-是-谁" class="headerlink" title="我 是 谁 ?"></a>我 是 谁 ?</h2><p>斯丹德儿的 坦普雷特 莱博瑞 即标准模板库</p><ul><li><p>重要特点：数据结构和算法的分离</p></li><li><p>重要特性：不是面向对象的</p></li><li><p>逻辑层次：体现了泛型化程序设计的思想</p></li><li><p>实现层次：以一种类型参数化的方式实现，基于模板(template)</p></li></ul><p>六大组件：</p><ul><li>容器（Container），是一种数据结构，如list，vector，deques ，以模板类的方法提供 ;</li><li>迭代器（Iterator），提供了访问容器中对象的方法。迭代器就如同一个指针。C++的指针也是一种迭代器。迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；</li><li>算法（Algorithm），是用来操作容器中的数据的模板函数。如sort()，find()，函数本身与他们操作的数据的结构和类型无关 ;</li><li>仿函数（Functor）</li><li>适配器（Adaptor）</li><li>分配器（allocator）</li></ul><h2 id="👴-常用的"><a href="#👴-常用的" class="headerlink" title="👴 常用的"></a>👴 常用的</h2><blockquote><p>以下不按顺序，想到啥就写啥，有个🥚的顺序</p></blockquote><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造函数</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str,index)</span></span>; <span class="hljs-comment">//将字符串str内“始于位置index”的部分当作字符串的初值</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str,index,n)</span></span>; <span class="hljs-comment">//将字符串str内“始于index且长度顶多n”的部分作为字符串的初值</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(n,c)</span></span>; <span class="hljs-comment">//生成一个字符串，包含n个c字符(char)</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str.begin(),str.end())</span></span>; <span class="hljs-comment">//以区间begin():end() (不包含end())内的字符作为字符串s的初值</span><br><br><span class="hljs-comment">//操作函数</span><br>s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//删除</span><br>s.<span class="hljs-built_in">replace</span>(pos,len,str); <span class="hljs-comment">//替换，从pos开始长为len被替换为str</span><br>s.<span class="hljs-built_in">find</span>(str,pos=<span class="hljs-number">0</span>); <span class="hljs-comment">//从pos向右查找，返回str第一次出现的位置</span><br>s.<span class="hljs-built_in">rfind</span>(str,pos=npos); <span class="hljs-comment">//从pos反向查找，返回找到位置</span><br>s.<span class="hljs-built_in">find_first_of</span>(str); <span class="hljs-comment">//查找第一个属于str中字符的位置</span><br>s.<span class="hljs-built_in">find_first_not_of</span>(str); <span class="hljs-comment">//查找第一个不属于str中字符位置</span><br>s.<span class="hljs-built_in">find_last_of</span>(str);<br>s.<span class="hljs-built_in">find_last_not_of</span>(str);<br>s1.<span class="hljs-built_in">compare</span>(s2); <span class="hljs-comment">//比较，相等0大于1小于-1</span><br>s1.<span class="hljs-built_in">compare</span>(pos,len,s2)<span class="hljs-comment">//从s1的pos开始长为len与s2比较</span><br></code></pre></td></tr></table></figure><h4 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h4><p>自动且直接的类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">stringstream sstream;<br><span class="hljs-comment">//数据类型转换</span><br>string str;<br><span class="hljs-keyword">int</span> a=<span class="hljs-number">123</span>;<br>sstream &lt;&lt; a;<br>sstream &gt;&gt; str;<br>cout&lt;&lt;str;<br>cout&lt;&lt;sstream.<span class="hljs-built_in">str</span>(); <br><span class="hljs-comment">//多个字符串拼接</span><br>sstream &lt;&lt; <span class="hljs-string">&quot;xxxx&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;aaaaa&quot;</span>;<br><span class="hljs-comment">//清空stringstream</span><br>sstream.<span class="hljs-built_in">clear</span>();<br>sstream.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><p>便携结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//访问通过first second</span><br><span class="hljs-comment">//可以通过一般运算符比较，先比较first再second</span><br><span class="hljs-function">pair&lt;string,<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span> <span class="hljs-params">(str,<span class="hljs-number">123</span>)</span></span>;<br>pair&lt;string,<span class="hljs-keyword">int</span>&gt; p = <span class="hljs-built_in">make_pair</span>(str,<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>向量容器，动态存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>v.<span class="hljs-built_in">front</span>(); v.<span class="hljs-built_in">back</span>();<br>v.<span class="hljs-built_in">begin</span>(); v.<span class="hljs-built_in">end</span>();<br>v.<span class="hljs-built_in">push_back</span>();<br>v.<span class="hljs-built_in">size</span>();<br>v.<span class="hljs-built_in">empty</span>();<br>v.<span class="hljs-built_in">clear</span>();<br>v.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//删除表尾元素</span><br>v.<span class="hljs-built_in">insert</span>(it,x); <span class="hljs-comment">//向迭代器it 指向的元素前插入新元素x</span><br>v.<span class="hljs-built_in">insert</span>(it,n,x); <span class="hljs-comment">//插入n个x</span><br>v.<span class="hljs-built_in">insert</span>(it, first, last); <span class="hljs-comment">//将由迭代器first和last 所指定的序列[first, last)插入到迭代器it指向的元素前面</span><br>v.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">//删</span><br>v.<span class="hljs-built_in">erase</span>(first,last);<br>v.<span class="hljs-built_in">reverse</span>(n); <span class="hljs-comment">//预分配缓冲空间，使存储空间至少可容纳n个元素</span><br>v.<span class="hljs-built_in">resize</span>(n); <span class="hljs-comment">//改变序列长度，超出元素删除，若源空间小于n，则默认值填满空间</span><br>v.<span class="hljs-built_in">resize</span>(n,val); <span class="hljs-comment">//超出的用val填满</span><br></code></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>s.<span class="hljs-built_in">push</span>(x);<br>s.<span class="hljs-built_in">pop</span>();<br>s.<span class="hljs-built_in">top</span>();<br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>队列，优先队列，双端队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// queue</span><br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(x);<br>q.<span class="hljs-built_in">pop</span>();<br>q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">back</span>();<br>q.<span class="hljs-built_in">empty</span>();<br>q.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">// priority_queue</span><br>priority&lt;<span class="hljs-keyword">int</span>&gt; q; <span class="hljs-comment">//默认大者优先</span><br>priority&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q; <span class="hljs-comment">//小的先出队 三个模板参数：元素类型，容器类型，比较算子</span><br><span class="hljs-comment">// 优先级设置：定义结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">int</span> grade;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (Student s1, Student s2)&#123;<br>        <span class="hljs-keyword">return</span> s1.grade&lt;s2.grade;<br>        <span class="hljs-comment">//此处小于号还是小于的作用，故队列中以成绩高的学生优先，若反之变号即可</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;Student&gt; q;<br><span class="hljs-comment">//也可以把重载的函数写在结构体外面</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Student s1, Student s2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> s1.grade&lt;s2.grade;<br>    &#125;<br>&#125;;<span class="hljs-comment">//tips:优先队列中的cmp和sort中的cmp效果相反</span><br>priority_queue&lt;Student,vector&lt;Student&gt;,cmp&gt; q;<br><span class="hljs-comment">//如果结构体内数据庞大，像出现字符串或者数组，建议使用引用来提高效率。此时比较类的参数需要加上 const 和 &amp;</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Student &amp;s1, <span class="hljs-keyword">const</span> Student &amp;s2)&#123;<br><span class="hljs-keyword">return</span> s1.grade&lt;s2.grade;<br>&#125;<br><br><span class="hljs-comment">//deque</span><br>deque&lt;<span class="hljs-keyword">int</span>&gt; d;<br>d.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">//尾部插入</span><br>d.<span class="hljs-built_in">push_front</span>(x); <span class="hljs-comment">//首部插入元素</span><br>d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>()+len,x); <span class="hljs-comment">//中间插入元素</span><br><span class="hljs-comment">//可以通过 d[0] d[1] 访问</span><br>d.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">//删除头部</span><br>d.<span class="hljs-built_in">pop_back</span>();<br>d.<span class="hljs-built_in">erase</span>(d.<span class="hljs-built_in">begin</span>()+len); <span class="hljs-comment">//删除指定位置元素，可以写多个</span><br></code></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>键值对，元素按关键字有序，内部红黑树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// map空间占用率高</span><br>map&lt;string,<span class="hljs-keyword">int</span>&gt; m;<br>m[key]=value;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(key,value));<br>m.<span class="hljs-built_in">erase</span>(key);<br>m.<span class="hljs-built_in">erase</span>(it);<br>m.<span class="hljs-built_in">clear</span>();<br>m.<span class="hljs-built_in">size</span>();<br>map&lt;string,<span class="hljs-keyword">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();++it)&#123;<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">// unordered_map 效率较高 内部哈希表</span><br><span class="hljs-comment">// 对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</span><br></code></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>无重复，按键值自动排序</p><p>数据结构为红黑树。以节点形式保存（动态)，用迭代器访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>s.<span class="hljs-built_in">begin</span>(); s.<span class="hljs-built_in">end</span>();<br>s.<span class="hljs-built_in">clear</span>();<br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">erase</span>(x);<br>s.<span class="hljs-built_in">find</span>(x);<br>s.<span class="hljs-built_in">insert</span>(x);<br>s.<span class="hljs-built_in">size</span>();<br>s.<span class="hljs-built_in">lower_bound</span>(value); <span class="hljs-comment">//返回第一个大于等于value的定位器</span><br>s.<span class="hljs-built_in">upper_bound</span>(value); <span class="hljs-comment">//返回最后一个大于等于value的定位器</span><br>set&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it=s.<span class="hljs-built_in">begin</span>();it!=s.<span class="hljs-built_in">end</span>();it++)<br>cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>链表</p><ul><li>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector </li><li>如果你需要大量的插入和删除，而不关心随即存取，则应使用list </li><li>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>list&lt;<span class="hljs-keyword">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>a.<span class="hljs-built_in">push_back</span>(x);<br>a.<span class="hljs-built_in">push_front</span>(x);<br>a.<span class="hljs-built_in">empty</span>();<br>a.<span class="hljs-built_in">resize</span>(n);<br>a.<span class="hljs-built_in">clear</span>();<br>a.<span class="hljs-built_in">front</span>(); a.<span class="hljs-built_in">back</span>();<br>a.<span class="hljs-built_in">reverse</span>();<br>a.<span class="hljs-built_in">merge</span>(b); <span class="hljs-comment">//b变空，a尾插入b</span><br>a.<span class="hljs-built_in">insert</span>(pos,x);<br>a.<span class="hljs-built_in">insert</span>(pos,b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<br>a.<span class="hljs-built_in">erase</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>a.<span class="hljs-built_in">remove</span>(x);<br></code></pre></td></tr></table></figure><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>存放二进制0/1的容器，可以声明非常大的二进制位而不限于64，用来优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">bitset&lt;N&gt; b; <span class="hljs-comment">//表示长为N的二进制串</span><br><span class="hljs-comment">// 通过b[pos]访问</span><br>b.<span class="hljs-built_in">any</span>(); <span class="hljs-comment">//存在为1的二进制位</span><br>b.<span class="hljs-built_in">none</span>(); <span class="hljs-comment">//不存在为1的二进制位</span><br>b.<span class="hljs-built_in">count</span>(); <span class="hljs-comment">//置1的二进制位的个数</span><br>b.<span class="hljs-built_in">size</span>();<br>b.<span class="hljs-built_in">test</span>(pos); <span class="hljs-comment">//在pos位处是否为1</span><br>b.<span class="hljs-built_in">set</span>(); <span class="hljs-comment">//所有位置1</span><br>b.<span class="hljs-built_in">set</span>(pos);<br>b.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//所有位置0</span><br>b.<span class="hljs-built_in">reset</span>(pos);<br>b.<span class="hljs-built_in">flip</span>(); <span class="hljs-comment">//逐位取反</span><br>b.<span class="hljs-built_in">flip</span>(pos);<br></code></pre></td></tr></table></figure><h3 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lower_bound</span>(a,a+n,x); <span class="hljs-comment">//二分查找第一个大于等于x的位置</span><br><span class="hljs-built_in">upper_bound</span>(a,a+n,x); <span class="hljs-comment">//二分查找第一个大于x的位置</span><br><span class="hljs-built_in">find</span>();<br><span class="hljs-built_in">rfind</span>();<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(a,a+n,cmp); <span class="hljs-comment">//默认ASC</span><br></code></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">swap</span>(a,b); <span class="hljs-comment">//交换</span><br><span class="hljs-built_in">replace</span>(pos,len,str); <span class="hljs-comment">//替换</span><br><span class="hljs-built_in">unique</span>(a,a+n); <span class="hljs-comment">//去除相邻的重复元素,会把重复的藏到末尾，使用前需要先排序</span><br></code></pre></td></tr></table></figure><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">next_permutation</span>(a,a+n); <span class="hljs-comment">//下一个全排列</span><br><span class="hljs-built_in">prev_permutation</span>(a,a+n); <span class="hljs-comment">//上一个全排列</span><br><span class="hljs-comment">//函数返回bool值，一般配合while()</span><br></code></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">isalpha</span>(<span class="hljs-keyword">char</span> x); <span class="hljs-comment">//小写字母返回2，大写字母1，非字母0</span><br><span class="hljs-built_in">tolower</span>(<span class="hljs-keyword">char</span> x); <span class="hljs-built_in">toupper</span>(<span class="hljs-keyword">char</span> x); <span class="hljs-comment">//返回小写，大写字母的ASCII值，非字母则相等</span><br><span class="hljs-comment">//海伦公式</span><br>p=(a+b+c)/<span class="hljs-number">2</span>;<br>s=<span class="hljs-built_in">sqrt</span>(p*(p-a)*(p-b)*(p-c));<br><span class="hljs-built_in">abs</span>(<span class="hljs-keyword">int</span> x); <span class="hljs-comment">//只用于整数</span><br><span class="hljs-built_in">fabs</span>(<span class="hljs-keyword">double</span> x); <span class="hljs-comment">//精度更高</span><br></code></pre></td></tr></table></figure><hr><p>暂时就这些了，寄！</p>]]></content>
    
    
    <categories>
      
      <category>ALGORITHMS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>note</tag>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我确实不会线段树</title>
    <link href="/2021/08/06/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2021/08/06/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>Segment Tree</p><blockquote><p>一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来艹了</p></blockquote><hr><p>原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2,b]。</p><p>作用：对编号连续的一些点的区间信息进行修改或者统计操作，用线段树统计的东西，必须符合<strong>区间加法</strong>。与树状数组不同的是，线段树不止适用于区间求和的查询，也可以进行区间最大值，区间最小值，或者区间异或值的查询。</p><p>主要操作：区间查询、点更新、区间更新</p><p>例如：</p><ul><li>给定s和t，求其区间上的最小值</li><li>给定i和x，把ai的值改成x</li></ul><p>更新和区间查询的复杂度都是 <strong>O(log(N))</strong></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><blockquote><p>build, update(内含push_down), query</p></blockquote><h3 id="建树-build"><a href="#建树-build" class="headerlink" title="建树 (build)"></a>建树 (build)</h3><p>线段树是一棵平衡二叉树，每个节点都对应一条线段(区间)，反之不成立，每个节点 $p$ 的左右子节点的编号分别为 $2p$ 和 $2p+1$ ，假如节点 $p$ 储存区间 $[a,b]$ 的和，设 $mid=[\frac{l+r}{2}]$，那么两个子节点分别储存 $[l,mid]$ 和 $[mid+1,r]$ 的和。可以发现，左节点对应的区间长度，与右节点相同或者比之恰好多 $1$。</p><p>故建树可考虑递归进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll l = <span class="hljs-number">1</span>, ll r = n, ll p = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-comment">// 到达叶子节点</span><br>        tree[p]=A[l]; <span class="hljs-comment">// 用数组中的数据赋值</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(l, mid, p * <span class="hljs-number">2</span>); <span class="hljs-comment">// 先建立左右子节点</span><br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 该节点的值等于左右子节点之和</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 这里👴偷了个 gif 来演示一下过程 (虽然大部分都是偷的🤡)</p><img src="https://pic4.zhimg.com/v2-c2d11b12c87b6a7076e3df0bb3585423_b.webp" alt="img" style="zoom:60%;" /><h3 id="区间修改-update"><a href="#区间修改-update" class="headerlink" title="区间修改(update)"></a>区间修改(update)</h3><p>首先定义”<strong>懒标记</strong>“(即“延迟标记”) <code>mark[]</code>：</p><p>对于区间修改，朴素的想法是用<strong>递归</strong>的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个<strong>标记</strong>，将来要用到它的<strong>子区间</strong>的时候，再向下<strong>传递</strong></p><p>直接上🐴 (非最简):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll l, ll r, ll d, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l) <span class="hljs-comment">// 区间无交集</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) <span class="hljs-comment">// 当前节点对应的区间包含在目标区间中</span><br>    &#123;<br>        tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d; <span class="hljs-comment">// 更新当前区间的值</span><br>        <span class="hljs-keyword">if</span> (cr &gt; cl) <span class="hljs-comment">// 如果不是叶子节点</span><br>            mark[p] += d; <span class="hljs-comment">// 给当前区间打上标记</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 与目标区间有交集，但不包含于其中</span><br>    &#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        mark[p * <span class="hljs-number">2</span>] += mark[p]; <span class="hljs-comment">// 标记向下传递</span><br>        mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>        tree[p * <span class="hljs-number">2</span>] += mark[p] * (mid - cl + <span class="hljs-number">1</span>); <span class="hljs-comment">// 往下更新一层</span><br>        tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (cr - mid);<br>        mark[p] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 清除标记</span><br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span>, cl, mid); <span class="hljs-comment">// 递归地往下寻找</span><br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 根据子节点更新当前节点的值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新时，我们是从最大的区间开始，递归向下处理。注意到，<strong>任何区间都是线段树上某些节点的并集</strong>。于是我们记目标区间为 $[l,r] $，当前区间为 $[cl,cr]$ ， 当前节点为 $p$ ，我们会遇到三种情况：</p><ol><li><p>当前区间与目标区间没有交集：</p><p>直接结束递归</p></li><li><p>当前区间被包括在目标区间里：</p><p>可以更新区间，不能忘记乘上区间长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d;<br></code></pre></td></tr></table></figure><p>然后打上懒标记（叶子节点可以不打标记，因为不会再向下传递了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mark[p] += d;<span class="hljs-comment">//表示“该区间上每一个点都要加上d”。因为原来可能存在标记，所以是+=而不是=</span><br></code></pre></td></tr></table></figure></li><li><p>当前区间与目标区间相交，但不包含于其中:</p><p>这时把当前区间一分为二，分别进行处理。如果存在懒标记，要先把懒标记传递给子节点（注意也是+=，因为原来可能存在懒标记)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>mark[p * <span class="hljs-number">2</span>] += mark[p];<br>mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br></code></pre></td></tr></table></figure><p>两个子节点的值也就需要相应的更新（后面乘的是区间长度) :[p * 2] += mark[p] * (mid - cl + 1);</p><p>tree[p * 2 + 1] += mark[p] * (cr - mid);</p><p>不要忘记清除该节点的懒标记：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mark[p]=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>因为贵标记和👴一样是个懒蛋，只往下传递一层，所以这个过程并不是递归的，以后要用再才继续传递。其实我们常常把这个传递过程封装成一个函数<strong>扑屎裆</strong> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>); <span class="hljs-comment">// 右边的区间可能要短一点</span><br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//这样儿 update() 里面调用的时候直接 push_down(p, cr - cl + 1); 就彳亍</span><br></code></pre></td></tr></table></figure><p>传递完标记后，再递归地去处理左右两个子节点就彳亍乐</p></li></ol><p>下面儿👴又偷了个视频展示一下区间 $[1,4]$ 加上 $1$ 的过程：</p><p><video width=70% src="https://vdn1.vzuu.com/SD/534181e0-23ad-11eb-905e-ca0d7949bec0.mp4?disable_local_cache=1&auth_key=1628242679-0-0-804945d6146979c7aa1236d8806960d8&f=mp4&bu=pico&expiration=1628242679&v=hw"></video></p><p>至于单点修改，只需要令左右端点相等即可~</p><h3 id="区间查询-query"><a href="#区间查询-query" class="headerlink" title="区间查询(query)"></a>区间查询(query)</h3><p>还就那个直接上🐴</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>        <span class="hljs-keyword">return</span> tree[p];<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid) + <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr); <br>        <span class="hljs-comment">// 上一行拆成三行写就和区间修改格式一致了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一样的递归，一样自顶至底地寻找，一样的合并信息，即插即用😍</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><blockquote><p>source : <strong>洛谷P3372 【模板】线段树 1</strong></p><p><strong>题目描述</strong><br>如题，已知一个数列，你需要进行下面两种操作：<br>1.将某区间每一个数加上x<br>2.求出某区间每一个数的和<br><strong>输入格式</strong><br>第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。<br>第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。<br>接下来M行每行包含3或4个整数，表示一个操作，具体如下：<br>操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k<br>操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和<br><strong>输出格式</strong><br>输出包含若干行整数，即为所有操作2的结果。</p></blockquote><hr><p>tips: 本模板分为龙鸣版和贵族版</p><h3 id="龙鸣version"><a href="#龙鸣version" class="headerlink" title="龙鸣version"></a>龙鸣version</h3><blockquote><p>(此龙鸣非彼龙鸣，意为把上面的龙鸣🐴整合起来):</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 100005</span><br>ll n, m, A[MAXN], tree[MAXN * <span class="hljs-number">4</span>], mark[MAXN * <span class="hljs-number">4</span>]; <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>);<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll l = <span class="hljs-number">1</span>, ll r = n, ll p = <span class="hljs-number">1</span>)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        tree[p] = A[l];<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(l, mid, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll l, ll r, ll d, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)&#123;<br>        tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d;<br>        <span class="hljs-keyword">if</span> (cr &gt; cl)<br>            mark[p] += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span>, cl, mid);<br>        <span class="hljs-built_in">update</span>(l, r, d, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>        <span class="hljs-keyword">return</span> tree[p];<br>    <span class="hljs-keyword">else</span>&#123;<br>        ll mid = (cl + cr) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid) + <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        A[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">build</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)&#123;<br>        ll opr = <span class="hljs-built_in">read</span>(), l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span> (opr == <span class="hljs-number">1</span>)&#123;<br>            ll d = <span class="hljs-built_in">read</span>();<br>            <span class="hljs-built_in">update</span>(l, r, d);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(l, r));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贵族version"><a href="#贵族version" class="headerlink" title="贵族version"></a>贵族version</h3><blockquote><p><del>豪华升级plus</del>，本来想加个乘除的发现板子不兼容，👴是懒狗</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br>ll tree[MAXN &lt;&lt; <span class="hljs-number">2</span>], mark[MAXN &lt;&lt; <span class="hljs-number">2</span>], n, m, A[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> len)</span></span>&#123;<br>    tree[p &lt;&lt; <span class="hljs-number">1</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    mark[p &lt;&lt; <span class="hljs-number">1</span>] += mark[p];<br>    tree[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>);<br>    mark[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] += mark[p];<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cl = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl == cr) &#123; tree[p] = A[cl]; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">int</span> mid = (cl + cr) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, cl, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    tree[p] = tree[p &lt;&lt; <span class="hljs-number">1</span>] + tree[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cl = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) <span class="hljs-keyword">return</span> tree[p];<br>    <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>    ll mid = (cl + cr) &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= l) ans += <span class="hljs-built_in">query</span>(l, r, p &lt;&lt; <span class="hljs-number">1</span>, cl, mid);<br>    <span class="hljs-keyword">if</span> (mid &lt; r) ans += <span class="hljs-built_in">query</span>(l, r, p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cl = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> cr = n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) &#123; tree[p] += d * (cr - cl + <span class="hljs-number">1</span>), mark[p] += d; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> mid = (cl + cr) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= l) <span class="hljs-built_in">update</span>(l, r, d, p &lt;&lt; <span class="hljs-number">1</span>, cl, mid);<br>    <span class="hljs-keyword">if</span> (mid &lt; r) <span class="hljs-built_in">update</span>(l, r, d, p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr);<br>    tree[p] = tree[p &lt;&lt; <span class="hljs-number">1</span>] + tree[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><p>步骤：</p><ol><li>将问题转化成点信息和目标信息</li><li>将目标信息根据需要扩充成区间信息<ul><li>增加信息符合区间加法</li><li>增加标记支持区间操作</li></ul></li><li>代码中的主要模块：区间加法，标记下推，点信息-&gt;区间信息，各种操作(修改、查询…)</li></ol><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><blockquote><p>URAL1989 Subpalindromes  <a href="https://blog.csdn.net/zearot/article/details/38921403">题解</a></p><p>给定一个字符串(长度&lt;=100000)，有两个操作。  1：改变某个字符。 2：判断某个子串是否构成回文串</p></blockquote><p>分析：</p><p>直接判断会超时，此处用 <strong>线段树维护字符串哈希</strong></p><p>对于一个字符串$a[0],a[1],…,a[n-1] $它对应的哈希函数为$a[0]+a[1]*K + a[2]*K^2 +…+a[n-1]*K^{n-1}$</p><p>再维护一个从右往左的哈希值：</p><p>$a[0]*K^{n-1} + a[1]*K^{n-2} +…+a[n-1]$</p><p><strong>若是回文串，则左右的哈希值会相等。而左右哈希值相等，则很大可能这是回文串。</strong></p><p>若出现误判，可以再用一个K2，进行二次哈希判断，可以减小误判概率。实现上，哈希值最好对某个质数取余数，这样分布更均匀。</p><p>解题模型：</p><ul><li>目标信息：某个区间的左，右哈希值</li><li>点信息：一个字符</li></ul><p>目标信息已经符合区间加法，所以<strong>区间信息=目标信息</strong></p><p>故线段树结构：</p><ul><li><p><strong>区间信息</strong>：区间哈希值</p></li><li><p><strong>点信息</strong>：一个字符</p></li></ul><p>核心：就是找到<strong>区间信息</strong>， 写好<strong>区间加法</strong></p><h3 id="最长连续零"><a href="#最长连续零" class="headerlink" title="最长连续零"></a>最长连续零</h3><blockquote><p>Codeforces 527C Glass Carving <a href="https://blog.csdn.net/zearot/article/details/44759437">题解</a></p><p>给定一个矩形，不停地纵向/横向切割，问每次切割后，最大的矩形面积是多少</p></blockquote><p>分析：</p><p>最大矩形面积=最长的长*最宽的宽</p><p>长宽范围均为1e5，故用01序列表示每个点是否被切割</p><p>最长的长就是长的最长连续0的数量+1，宽同理，于是可用用线段树维护最长连续零</p><p>解题模型：</p><ul><li>目标信息：区间最长连续零的个数</li><li>点信息：0或1</li></ul><p>由于目标信息不符合区间加法，所以要扩充目标信息</p><p>故线段树结构：</p><ul><li><strong>区间信息</strong>：从左，右开始的最长连续零，本区间是否全零，本区间最长连续零</li><li><strong>点信息</strong>：0或1</li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote><p>Codeforces 558E A Simple Task <a href="https://blog.csdn.net/zearot/article/details/48048559">题解</a></p><p>给定一个长度不超过1e5的字符串（小写英文字母），和不超过5000个操作，每个操作 L R K 表示给区间[L,R]的字符串排序，K=1为升序，K=0为降序。 最后输出最终的字符串</p></blockquote><p>解题模型：</p><ul><li>目标信息：区间的计数排序结果</li><li>点信息：一个字符</li></ul><p>目标信息是符合区间加法的，但是为了支持区间操作，还是需要扩充信息</p><p>故线段树结构：</p><ul><li><strong>目标信息</strong>：区间的计数排序结果，排序标记，排序种类（升降）</li><li><strong>点信息</strong>：一个字符</li></ul><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>👴前面都没整太明白，这个待续</p>]]></content>
    
    
    <categories>
      
      <category>ALGORITHMS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>note</tag>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="/2021/07/31/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2021/07/31/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><p>Game Theory</p><hr><h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><p>属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下：</p><ul><li>两名选手交替移动，在有限的合法移动集合中任选一种进行移动</li><li>对于任何一种局面，合法的移动集合只取决于局面本身</li><li>到谁无法移动谁就输了</li></ul><p>以下给出 P/N 的定义：</p><ul><li>P-Position：先手必败点 (Previous)</li><li>N-Position：先手必胜点 (Next)</li><li>可知所有终结点都是P点，一步就<strong>能</strong>到P点的一定是N点，通过一步<strong>只能</strong>到N点的一定是P点</li></ul><p>下面来说说Nim游戏：“有若干堆石子，每堆石子的数量有限，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为没有任何合法的移动）“，简单来想，我们可以想到一个递归的算法：对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P，那么向这个子局面的移动就是必胜策略。这其中有大量的重叠子问题，所以可以用DP或者记忆化搜索的方法以提高效率。</p><p>但是👴们已经有了一个nb的结论：</p><p><strong>对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1^a2^…^an=0，其中^表示异或(xor)运算</strong></p><p>根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。</p><hr><h2 id="Sprague-Grundy函数"><a href="#Sprague-Grundy函数" class="headerlink" title="Sprague-Grundy函数"></a>Sprague-Grundy函数</h2><p>ICG的抽象模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负</p><p>首先定义mex(minimal excludnt) 运算：</p><p>施加于集合，表示<strong>最小</strong>的<strong>不属于</strong>这个集合的<strong>非负整数</strong>，exp: mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p><p>下面给出SG函数的定义：</p><p>对于一个给定的<strong>有向无环图</strong>，定义关于图的每个顶点的Sprague-Garundy函数如下：sg(x)=mex{ sg(y) | y是x的<strong>后继</strong> }。</p><p>结论：当SG[x] = 0时，x为必败状态；当SG[x] &gt; 0时，x为必胜状态</p><p>所以从1~n的SG函数值应该如何计算呢？</p><ol><li>使用 数组 f[ ] 将可改变当前状态 的方式记录下来</li><li>然后我们使用 另一个数组 S[ ] 将当前状态x 的后继状态标记</li><li>模拟mex运算，也就是我们在标记值中 搜索 <strong>未被标记值</strong> 的最小值，将其赋值给SG(x)</li><li>不断重复 2-3 的步骤，即完成计算 1-n 的SG函数值</li></ol><p><strong>SG定理</strong>：<strong>SG(G)=SG(G1)^SG(G2)^…^SG(Gn)<strong>，原游戏的SG函数值是它的所有子游戏的SG函数值的</strong>异或</strong></p><hr><h2 id="解题模型"><a href="#解题模型" class="headerlink" title="解题模型"></a>解题模型</h2><ol><li><p>把原游戏分解成多个独立的子游戏，则原游戏的SG函数值就变为<strong>SG(G)=SG(G1)^SG(G2)^…^Sg(Gn)</strong></p></li><li><p>分别考虑每一个子游戏，计算其SG值</p><p><strong>SG值的计算方法</strong>（important）：</p><p>​    a. <strong>可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1)</strong> <strong>（Bash game）</strong></p><p>​    b. <strong>可选步数为任意步，SG(x) = x（Nim game）</strong></p><p>​    c. <strong>可选步数为一系列不连续的数，用模板计算</strong></p></li></ol><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><blockquote><p>首选打表预处理，打表没法使的时候就怼dfs</p></blockquote><h3 id="☆打表"><a href="#☆打表" class="headerlink" title="☆打表"></a>☆打表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//打表</span><br><span class="hljs-keyword">int</span> f[N],SG[MAXN],S[MAXN]; <span class="hljs-comment">// f[] 可改变当前状态的方式(可取走石子个数)   S[] 当前状态的后继状态集合</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getSG</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i,j;<br><span class="hljs-built_in">memset</span>(SG,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SG));<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123; <br><span class="hljs-built_in">memset</span>(S,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(S));<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; f[j]&lt;=i &amp;&amp; j&lt;=N;j++)<br>S[SG[i-f[j]]]=<span class="hljs-number">1</span>; <span class="hljs-comment">//S[]数组来保存当前状态的后继状态集合</span><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=n;j++)&#123; <br>        <span class="hljs-keyword">if</span>(!S[j])&#123;<span class="hljs-comment">//模拟mex运算</span><br>SG[i]=j;<br><span class="hljs-keyword">break</span>;<br>            &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//注意 f数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍</span><br><span class="hljs-comment">//n是集合f的大小 f[i]是定义的特殊取法规则的数组</span><br><span class="hljs-keyword">int</span> f[<span class="hljs-number">110</span>],SG[<span class="hljs-number">10010</span>],n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SG_dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(SG[x]!=<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> SG[x];<br>    <span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x&gt;=f[i])&#123;<br>            <span class="hljs-built_in">SG_dfs</span>(x-f[i]);<br>            vis[SG[x-f[i]]]=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> e;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;;i++)<br>        <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>            e=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> SG[x]=e;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="常见博弈"><a href="#常见博弈" class="headerlink" title="常见博弈"></a>常见博弈</h2><h3 id="Bash-Game"><a href="#Bash-Game" class="headerlink" title="Bash Game"></a>Bash Game</h3><p>只有一堆n个物品，两个人轮流取物，每次至少取一个，最多取m个。最后取光者得胜（谁拿了最后一个谁赢）</p><p>结论：最优选择为保持给对手留下 <strong>m+1</strong> 的倍数</p><ul><li><p>if(n%(m+1) != 0)  则先手必赢 </p></li><li><p>if(n%(m+1) == 0)  则后手必赢</p></li></ul><h3 id="Wythoff-Game"><a href="#Wythoff-Game" class="headerlink" title="Wythoff Game"></a>Wythoff Game</h3><blockquote><p>各位👴属实🐮，黄金分割数（1+√5）/2 = 1.618 都给整上了</p></blockquote><p>有两堆各若干个物品，两个人轮流从某一堆取物或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜</p><p>这里用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为<strong>局势</strong></p><p>由ak，bk组成的矩形近似为黄金矩形</p><p>结论：</p><ul><li><p>(int)((bk-ak)*(1+sqrt(5.0))/2) != ak ,  先手必赢</p></li><li><p>(int)((bk-ak)*(1+sqrt(5.0))/2) == ak , 后手必赢</p></li></ul><h3 id="Nim-Game"><a href="#Nim-Game" class="headerlink" title="Nim Game"></a>Nim Game</h3><p>若干堆石子，每堆石子的数量有限，两个人可以选择一堆石子并拿走若干颗</p><p>结论：xor 略</p><h3 id="Fibonacci-Nim"><a href="#Fibonacci-Nim" class="headerlink" title="Fibonacci Nim"></a>Fibonacci Nim</h3><p>有一堆个数为n的石子，游戏双方轮流取石子，满足: (1)先手不能在第一次把所有的石子取完 (2)每次可以取的石子数介于1到对手刚取的石子数的2倍之间(包含)  (3) 取走最后一个石子的人为赢家</p><p>结论：<strong>当n为Fibonacci数的时候，必败</strong></p><p>f[i]：1,2,3,5,8,13,21,34,55,89……</p>]]></content>
    
    
    <categories>
      
      <category>ALGORITHMS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>note</tag>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql学习笔记</title>
    <link href="/2021/07/29/sql/"/>
    <url>/2021/07/29/sql/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>结构化查询语言-Structured Query Language</p><p><em><strong>@author：Maskros</strong></em></p><hr><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>类型</p><ul><li>字符型<ul><li>VARCHAR型和CHAR型</li></ul></li><li>文本型<ul><li>TEXT</li></ul></li><li>数值型<ul><li>整数INT 、小数NUMERIC、钱数MONEY)</li></ul></li><li>逻辑型<ul><li>BIT</li></ul></li><li>日期型<ul><li>DATETIME </li></ul></li></ul><hr><h2 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h2><p>操作</p><p>增删改查 CURD</p><p>tips : 不区分大小写，列名表名前``可以省略</p><h3 id="SELECT-FROM"><a href="#SELECT-FROM" class="headerlink" title="SELECT(FROM)"></a>SELECT(FROM)</h3><ul><li>SELECT COLUMN 查询单个列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name`<br><span class="hljs-keyword">FROM</span> `table_name`;<br></code></pre></td></tr></table></figure><ul><li>SELECT COLUMN, COLUMN 查询多个列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name_1`, `column_name_2`  <br><span class="hljs-keyword">FROM</span> `table_name`;<br></code></pre></td></tr></table></figure><ul><li>使用 SELECT * 查询所有列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `table_name`;<br></code></pre></td></tr></table></figure><ul><li>使用 SELECT DISTINCT 查询不同行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> `column_name`<br><span class="hljs-keyword">FROM</span> `table_name`<br></code></pre></td></tr></table></figure><p>​    希望查询的值都是唯一不重复的</p><ul><li>SELECT WHERE 对行进行筛选过滤</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name1`,`column_name2`…<br><span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` operator `<span class="hljs-keyword">value</span>`;<br></code></pre></td></tr></table></figure><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT(INTO)"></a>INSERT(INTO)</h3><ul><li>INSERT INTO 在不指定列的情况下插入数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `table_name`<br><span class="hljs-keyword">VALUES</span> (value1, value2, value3,...);<br># <span class="hljs-string">&#x27;value&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>INSERT INTO 在指定的列中插入数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `table_name`<br>(`column1`, `column2`, `column3`,...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, value3,...);<br></code></pre></td></tr></table></figure><h3 id="UPDATE-SET"><a href="#UPDATE-SET" class="headerlink" title="UPDATE(SET)"></a>UPDATE(SET)</h3><ul><li>UPDATE 更新数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE `table_name`<br><span class="hljs-keyword">SET</span> `column1`<span class="hljs-operator">=</span>value1,`column2`<span class="hljs-operator">=</span>value2,...<br><span class="hljs-keyword">WHERE</span> `some_column`<span class="hljs-operator">=</span>some_value;<br># <span class="hljs-keyword">WHERE</span> 可以省略<br></code></pre></td></tr></table></figure><h3 id="DELETE-FROM"><a href="#DELETE-FROM" class="headerlink" title="DELETE(FROM)"></a>DELETE(FROM)</h3><ul><li>DELETE 删除数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `some_column` <span class="hljs-operator">=</span> `some_value`;<br></code></pre></td></tr></table></figure><ul><li>TRUNCATE TABLE 清空表</li></ul><hr><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>条件</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> A OPERATOR B<br></code></pre></td></tr></table></figure><ul><li>tips:  <code>&lt;&gt;</code> , <code>!=</code> 均为不等于，但用法不同</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p>AND 连接多条件</p></li><li><p>OR 连接多条件</p></li><li><p>NOT 过滤不满足条件的数据</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name` <br><span class="hljs-keyword">FROM</span> `table_name` <br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> `<span class="hljs-keyword">condition</span>`;<br># (condition1 operator condition2)<br></code></pre></td></tr></table></figure><h3 id="特殊条件"><a href="#特殊条件" class="headerlink" title="特殊条件"></a>特殊条件</h3><ul><li>IN 查询多条件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Where</span> `column_name1` <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">condition</span>)<br># <span class="hljs-keyword">condition</span> 中也可以写<br><span class="hljs-keyword">IN</span> (<span class="hljs-keyword">select</span> `column_name1` xxxxxxxx)<br></code></pre></td></tr></table></figure><ul><li>NOT IN 排除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` (<span class="hljs-keyword">NOT</span>) <span class="hljs-keyword">IN</span> `<span class="hljs-keyword">value</span>`;<br># （value1, value2）<br></code></pre></td></tr></table></figure><ul><li>BETWEEN AND 查询两值间的数据范围</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` <span class="hljs-keyword">BETWEEN</span> `<span class="hljs-keyword">value</span>` <span class="hljs-keyword">AND</span> `<span class="hljs-keyword">value</span>`;<br></code></pre></td></tr></table></figure><ul><li>IS NULL 查询空数据</li><li>使用 LIKE 模糊查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` <span class="hljs-keyword">LIKE</span> `<span class="hljs-keyword">value</span>`;<br># <span class="hljs-keyword">LIKE</span> `D<span class="hljs-operator">%</span>`<br># <span class="hljs-string">&#x27;D%&#x27;</span> 表示以D开头的所有单词，<span class="hljs-operator">%</span> 表示为通配符，可以替代<span class="hljs-number">0</span><span class="hljs-operator">~</span>n个字符<br></code></pre></td></tr></table></figure><h3 id="ORDER-BY-amp-LIMIT"><a href="#ORDER-BY-amp-LIMIT" class="headerlink" title="ORDER BY &amp; LIMIT"></a>ORDER BY &amp; LIMIT</h3><ul><li><p>ORDER BY 对数据进行排序（一列/多列(多列按SELECT顺序)）</p><p>ASC (ascend)升序(默认)  |  DESC(descend) 降序</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> `column_name`, `column_name`<br><span class="hljs-keyword">FROM</span> `table_name`<br># <span class="hljs-keyword">WHERE</span> XXXX<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `column_name`, `column_name` <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>; <br></code></pre></td></tr></table></figure><ul><li><p>使用 LIMIT 限制输出行数</p><p>offset ：是返回集的初始标注，起始点是0</p><p>count ：制定返回的数量</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name`, `column_name`<br><span class="hljs-keyword">FROM</span> `table_name`<br># <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> XXXX<br>LIMIT `<span class="hljs-keyword">offset</span>` , `count`;<br># <span class="hljs-keyword">offset</span>和count通常只用一个count：LIMIT (<span class="hljs-number">0</span>,)<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>函数</p><h3 id="算数函数"><a href="#算数函数" class="headerlink" title="算数函数"></a>算数函数</h3><ul><li>AVG() 函数求数值列的平均值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(`column_name`) # <span class="hljs-keyword">AS</span> `column2_name`<br><span class="hljs-keyword">FROM</span> `table_name`;<br></code></pre></td></tr></table></figure><ul><li><p>MAX() 函数返回指定列中的最大值</p></li><li><p>MIN() 函数返回指定列中的最小值</p></li><li><p>SUM() 函数统计数值列的总数</p></li><li><p>ROUND() 函数将数值四舍五入</p><ul><li>ROUND() 返回值数据类型会被变换为一个BIGINT 。</li><li>当 decimals 为正数时，column_name 四舍五入为 decimals 所指定的小数位数。省略decimals自动保留四舍五入后的整数。当 decimals 为负数时，column_name 则按 decimals 所指定的在小数点的左边四舍五入。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ROUND(`column_name`, `decimals`) <br><span class="hljs-keyword">FROM</span> `table_name`;<br>#decimals 规定要返回的小数位数<br></code></pre></td></tr></table></figure></li><li><p>NULL() 函数判断空值</p><ul><li><p>ISNULL()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ISNULL(`column_name`)<br><span class="hljs-keyword">FROM</span> `table_name`;<br># 返回 <span class="hljs-number">0</span> 或 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>IFNULL()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> IFNULL(`column_name`, `<span class="hljs-keyword">value</span>`)<br><span class="hljs-keyword">FROM</span> `table_name`;<br># 是 <span class="hljs-keyword">NULL</span> 则返回 <span class="hljs-keyword">value</span> 值，不是则返回对应内容<br></code></pre></td></tr></table></figure></li></ul></li><li><p>COUNT() 函数计数</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-built_in">COUNT</span>(column_name) 对列具有的行数进行计数 除去值为 <span class="hljs-keyword">NULL</span> 的行<br># 主要用于查看各列数据的数量情况，便于统计数据的缺失值<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(`column_name`) <br><span class="hljs-keyword">FROM</span> `table_name`;<br># <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) 对表中行的数目进行计数,包括 <span class="hljs-keyword">NULL</span> 所在行和重复项所在行<br># 主要用于查看表中的记录数<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <br><span class="hljs-keyword">FROM</span> `table_name`;<br># <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> column_name) 函数返回指定列的不同值的数目<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> `column_name`) <br><span class="hljs-keyword">FROM</span> `table_name`;<br></code></pre></td></tr></table></figure><h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><ul><li><p>NOW()，CURDATE()、CURTIME() 获取当前时间</p><ul><li><code>NOW()</code> 返回当前日期和时间  YYYY-MM-DD hh:mm:ss</li><li><code>CURDATE()</code> 返回当前日期  YYYY-MM-DD</li><li><code>CURTIME()</code> 返回当前时间  hh:mm:ss</li><li>要精确的秒以后的时间的话，可以在 () 中加数字，加多少，就表示精确到秒后多少位</li></ul></li><li><p>DATE()、TIME() 函数提取日期和时间</p></li><li><p>EXTRACT() 函数提取指定的时间信息</p><ul><li><p>FROM</p></li><li><p>返回日期/时间的单独部分</p></li><li><p>unit :  <code>YEAR</code> (年)、<code>MONTH</code> (月)、<code>DAY</code> (日)、<code>HOUR</code> (小时)、<code>MINUTE</code> (分钟)、 <code>SECOND</code> (秒)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">EXTRACT</span>(unit <span class="hljs-keyword">FROM</span> <span class="hljs-type">date</span>) # unit 为单独部分名<br><span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">table</span>`<br># <span class="hljs-type">date</span> <span class="hljs-operator">-</span> 合法<span class="hljs-keyword">column</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>DATE_FORMAT() 格式化输出日期</p><ul><li>%Y 年份 %m 月份 %d 日期 %w 星期 %H 小时  %i 分钟 %s 秒</li><li>小写y 表示年份后两位，小写h表示12小时计的小时</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_FORMAT(<span class="hljs-type">date</span>,<span class="hljs-string">&#x27;format&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>DATE_ADD() 增加时间</p><ul><li>INTERVAL</li><li>向日期添加指定的时间间隔</li><li> <code>expr</code> 是希望添加的时间间隔的数值</li><li>type :  MICROSECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , QUARTER , YEAR</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_ADD(<span class="hljs-type">date</span>, <span class="hljs-type">INTERVAL</span> expr type)<br><span class="hljs-keyword">FROM</span> table_name<br></code></pre></td></tr></table></figure></li><li><p>DATE_SUB() 减少时间</p></li><li><p>DATEDIFF() 和 TIMESTAMPDIFF() 计算日期差</p><ul><li>时间1-时间2</li><li>DATEDIFF() 默认只能计算天数差</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> DATEDIFF(时间<span class="hljs-number">1</span>,时间<span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> date_diff <span class="hljs-keyword">FROM</span> courses;<br></code></pre></td></tr></table></figure><ul><li>TIMESTAMPDIFF() 计算相差年月周日时<ul><li>类型YEAR,MONTH,WEEK,DAY,HOUR</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TIMESTAMPDIFF (类型,时间<span class="hljs-number">1</span>,时间<span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> year_diff；<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>约束</p><h3 id="NOT-NULL"><a href="#NOT-NULL" class="headerlink" title="NOT NULL"></a>NOT NULL</h3><p>非空约束</p><ul><li>强制列不接受 NULL 值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SQL"># 建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Persons` (<br>    `ID` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `LastName` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br># 已建表<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br>MODIFY `Age` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br># 撤销<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br>MODIFY `Age` <span class="hljs-type">int</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h3><p>唯一约束</p><ul><li>不希望出现重复记录</li><li>CONSTRAINT 命名</li><li>DROP 撤销</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 建表<br>## MySQL<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Persons`(<br>    `P_Id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">UNIQUE</span> (`P_Id`)<br>)<br>## <span class="hljs-keyword">SQL</span> Server <span class="hljs-operator">/</span> Oracle <span class="hljs-operator">/</span> MS Access<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Persons`(<br>`P_Id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,<br>)<br>## 命名<span class="hljs-operator">+</span>多列<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Persons`(<br>    `P_Id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `LastName` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">CONSTRAINT</span> uc_PersonID <span class="hljs-keyword">UNIQUE</span> (`P_Id`,`LastName`)<br>)<br><br># 已建<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span>（`P_Id`）<br>## 多列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> uc_PersonID <span class="hljs-keyword">UNIQUE</span> (`P_Id`,`LastName`)<br><br># 撤销<br>## MySQL<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">DROP</span> INDEX uc_PersonID<br>## <span class="hljs-keyword">SQL</span> Server <span class="hljs-operator">/</span> Oracle <span class="hljs-operator">/</span> MS Access<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> uc_PersonID<br></code></pre></td></tr></table></figure><h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p>主键约束</p><ul><li>简单的说，PRIMARY KEY = UNIQUE + NOT NULL </li><li>NOT NULL UNIQUE 可以将表的一列或多列定义为唯一性属性，而 PRIMARY KEY 设为多列时，仅能保证多列之和是唯一的，具体到某一列可能会重复。</li><li>PRIMARY KEY 可以与外键配合，从而形成主从表的关系</li><li>PRIMARY KEY 一般在逻辑设计中用作记录标识，这也是设置 PRIMARY KEY 的本来用意，而 UNIQUE 只是为了保证域/域组的唯一性</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 建表<br>## MySQL<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Persons(<br>    `P_Id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`P_Id`)<br>);<br>## <span class="hljs-keyword">SQL</span> Server <span class="hljs-operator">/</span> Oracle <span class="hljs-operator">/</span> MS Access<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Persons`(<br>    `P_Id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>)<br>## 命名<span class="hljs-operator">+</span>多列<br><span class="hljs-keyword">CONSTRAINT</span> pk_PersonID <span class="hljs-keyword">PRIMARY</span> KEY (`P_Id`,`LastName`)<br><br># 已建<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (`P_Id`)<br>## 多列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> pk_PersonID <span class="hljs-keyword">PRIMARY</span> KEY (`P_Id`,`LastName`)<br><br># 撤销<br>## MySQL<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY<br>## <span class="hljs-keyword">SQL</span> Server <span class="hljs-operator">/</span> Oracle <span class="hljs-operator">/</span> MS Access<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> pk_PersonID<br></code></pre></td></tr></table></figure><h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>外键约束 </p><ul><li>一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY </li><li>保证数据的完整性和一致性</li><li>在两个表之间建立关系，需要指定引用主表的哪一列，REFERENCES 表示引用一个表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 建表<br>## MySQL<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Orders`(<br>    `P_Id` <span class="hljs-type">int</span>,<br>    <span class="hljs-keyword">FOREIGN</span> KEY (P_Id) <span class="hljs-keyword">REFERENCES</span> Persons(P_Id)<br>)<br>## <span class="hljs-keyword">SQL</span> Server <span class="hljs-operator">/</span> Oracle <span class="hljs-operator">/</span> MS Access<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `Orders`(<br>    P_Id <span class="hljs-type">int</span> <span class="hljs-keyword">FOREIGN</span> KEY <span class="hljs-keyword">REFERENCES</span> Persons(P_Id)<br>)<br>## 命名<span class="hljs-operator">+</span>多列<br><span class="hljs-keyword">CONSTRAINT</span> fk_PerOrders <span class="hljs-keyword">FOREIGN</span> KEY (P_Id)<br><span class="hljs-keyword">REFERENCES</span> Persons(P_Id)<br><br># 已建<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Orders`<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">FOREIGN</span> KEY (P_Id)<br><span class="hljs-keyword">REFERENCES</span> Persons(P_Id)<br>## 命名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Orders`<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_PerOrders<br><span class="hljs-keyword">FOREIGN</span> KEY (P_Id)<br><span class="hljs-keyword">REFERENCES</span> Persons(P_Id)<br><br># 撤销<br>## MySQL<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Orders`<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY fk_PerOrders<br>## <span class="hljs-keyword">SQL</span> Server <span class="hljs-operator">/</span> Oracle <span class="hljs-operator">/</span> MS Access<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Orders`<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> fk_PerOrders<br></code></pre></td></tr></table></figure><h3 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h3><p>检查约束 </p><ul><li>限制列中的值的范围，评估插入或修改后的值。满足条件插入，否不插</li><li>可以为同一列指定多个 CHECK 约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `courses`(<br>`student_count` <span class="hljs-type">int</span>, …<br><span class="hljs-keyword">CHECK</span> (Condition1 <span class="hljs-keyword">AND</span> Condition2)<br>)<br>## 命名<br><span class="hljs-keyword">CONSTRAINT</span> chk_courses <span class="hljs-keyword">CHECK</span> (`student_count` <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>);<br><br># 已建<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `courses` <br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CHECK</span> ( `student_count` <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>);<br>## <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> XXX <span class="hljs-keyword">CHECK</span> (<span class="hljs-keyword">Condition</span>);<br><br># 撤销<br>## MySQL<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `courses` <br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CHECK</span> chk_courses<br>## <span class="hljs-keyword">SQL</span> Server <span class="hljs-operator">/</span> Oracle <span class="hljs-operator">/</span> MS Access<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `courses` <br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> chk_courses<br></code></pre></td></tr></table></figure><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>默认约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">`City` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;Sandnes&#x27;</span><br>`OrderDate` <span class="hljs-type">date</span> <span class="hljs-keyword">DEFAULT</span> GETDATE()  # 可以用函数<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `Persons`<br><span class="hljs-keyword">ALTER</span> `City` <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;SANDNES&#x27;</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> ab_c <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;SANDNES&#x27;</span> <span class="hljs-keyword">for</span> `City`<br><br><span class="hljs-keyword">ALTER</span> `City` <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> `City` <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span><br></code></pre></td></tr></table></figure><h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p>多表联结</p><h3 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h3><ul><li><p>在一条 SELECT 语句中关联多个表，返回一组输出</p></li><li><p>两大主角 : 主键 (PRIMARY KEY) 和外键 (FOREIGN KEY)</p></li><li><p>使用完全限定列名（用一个点分隔表名和列名）</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">condition</span><br>`table1`.`common_field` <span class="hljs-operator">=</span> `table2`.`common_field`<br></code></pre></td></tr></table></figure><ul><li>JOIN 连接子句<ul><li><strong>INNER JOIN</strong> 内连接：如果表中有至少一个匹配，则返回行</li><li><strong>OUTER JOIN</strong> 外连接<ul><li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li><li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li></ul></li><li><strong>FULL JOIN</strong> 全连接：只要其中一个表中存在匹配，则返回行</li><li><strong>CROSS JOIN</strong> 交叉连接：又称<strong>笛卡尔积</strong>，两个表数据一一对应，返回结果的行数等于两个表行数的乘积</li></ul></li></ul><h3 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h3><p>内连接 又称为EQUIJOIN 等值连接</p><ul><li>内连接就是取两个表的交集，返回的结果就是连接的两张表中都满足条件的部分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `table1`.`column1`, `table2`.`column2`...<br><span class="hljs-keyword">FROM</span> `table1`<br>(<span class="hljs-keyword">INNER</span>) <span class="hljs-keyword">JOIN</span> `table2` # <span class="hljs-keyword">INNER</span> 可省略不写<br><span class="hljs-keyword">ON</span> `table1`.`common_field` <span class="hljs-operator">=</span> `table2`.`common_field`;<br># <span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONDITION</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># exp<br><span class="hljs-keyword">SELECT</span> `c`.`id`, `c`.`name` <span class="hljs-keyword">AS</span> `course_name`, `t`.`name` <span class="hljs-keyword">AS</span> `teacher_email`<br><span class="hljs-keyword">FROM</span> `courses` `c`<br>    (<span class="hljs-keyword">INNER</span>) <span class="hljs-keyword">JOIN</span> `teachers` `t` <span class="hljs-keyword">ON</span> `c`.`teacher_id` <span class="hljs-operator">=</span> `t`.`id`;<br></code></pre></td></tr></table></figure><ul><li><code>courses</code> <code>c</code> 等同于 <code>courses</code> AS <code>c</code> ，给<code>courses</code> 表取别名为 <code>c</code></li></ul><h3 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h3><p>外连接 分为左外连接 右外连接 全外连接</p><ul><li>外连接可以将某个表格中，在另外一张表格中无对应关系，但是也能将数据匹配出来</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name <span class="hljs-number">1</span>,column_name <span class="hljs-number">2</span> ... column_name n<br>    <span class="hljs-keyword">FROM</span> table1<br>        <span class="hljs-keyword">LEFT</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">RIGHT</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">FULL</span>  (<span class="hljs-keyword">OUTER</span>) <span class="hljs-keyword">JOIN</span> table2<br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONDITION</span>;<br></code></pre></td></tr></table></figure><ul><li>LEFT JOIN : 以左表为参考表，返回左表中的所有记录，加上右表中匹配到的记录</li><li>RIGHT JOIN :  以右表为参考表</li><li>FULL JOIN : 只要左表和右表其中一个表中存在匹配，则返回行</li></ul><blockquote><p>tips :  MySQL 数据库不支持全连接，想要实现全连接可以使用 UNION ALL 来将左连接和右连接结果组合在一起实现全连接</p></blockquote><ul><li>UNION :  联合，把两次或多次查询结果合并起来<ul><li>要求：两次查询的列数必须一致，同时，每条 SELECT 语句中的列的顺序必须相同</li><li>UNION 会去掉重复的行。 如果不想去掉重复的行，可以使用 UNION ALL </li><li>如果子句中有 order by , limit，需用括号()包起来。推荐放到所有子句之后，即对最终合并的结果来排序或筛选</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name <span class="hljs-number">1</span>,column_name <span class="hljs-number">2</span> ... column_name n<br>    <span class="hljs-keyword">FROM</span> table1<br>        <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONDITION</span> <br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> column_name <span class="hljs-number">1</span>,column_name <span class="hljs-number">2</span> ... column_name n<br>    <span class="hljs-keyword">FROM</span> table1<br>        <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONDITION</span> ;<br></code></pre></td></tr></table></figure><h3 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h3><p>交叉连接 结果也称作笛卡尔积</p><ul><li>返回左表中的所有行，左表中的每一行与右表中的所有行组合。即将两个表的数据一一对应，其查询结果的行数为左表中的行数乘以右表中的行数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 隐式连接 不需要使用 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> 关键字<br><span class="hljs-keyword">SELECT</span> `table1`.`column1`, `table2`.`column2`...<br><span class="hljs-keyword">FROM</span> `table1`,`table2`;<br># 显式连接<br><span class="hljs-keyword">SELECT</span> `table1`.`column1`, `table2`.`column2`...<br><span class="hljs-keyword">FROM</span> `table1`<br><span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> `table2`;<br></code></pre></td></tr></table></figure><ul><li>通过增加联结条件，使用 WHERE 子句帮助筛选过滤无效的数据</li></ul><hr><h2 id="Advanced-Select"><a href="#Advanced-Select" class="headerlink" title="Advanced Select"></a>Advanced Select</h2><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li><p>GROUP BY 子句</p><ul><li>对同类的数据进行分类</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name`, aggregate_function(`column_name`)<br><span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` operator <span class="hljs-keyword">value</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> `column_name`;<br></code></pre></td></tr></table></figure></li><li><p>HAVING 子句</p><ul><li>使用 WHERE 条件子句时不能与聚合函数联合使用</li><li> HAVING 子句经常与 GROUP BY 联合使用，HAVING 子句就是对分组统计函数进行过滤的子句</li><li>HAVING 子句对于 GROUP BY 子句设置条件的方式其实与 WHERE 子句与 SELECT 的方式类似，语法相近，但 WHERE 子句搜索条件是在分组操作之前，而 HAVING 则是在之后</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   `column_name`, aggregate_function(`column_name`) <br><span class="hljs-keyword">FROM</span>     `table_name` <br><span class="hljs-keyword">WHERE</span>    `column_name` operator <span class="hljs-keyword">value</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> `column_name` <br><span class="hljs-keyword">HAVING</span>   aggregate_function(`column_name`) operator <span class="hljs-keyword">value</span>;<br></code></pre></td></tr></table></figure><ul><li>ex: 查询教师表 teachers计算不同国籍教师的平均年龄和所有教师的平均年龄，比较两者的大小，最后返回大于所有教师平均年龄的不同国籍下的全部教师信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 子查询<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> teachers <br>    <span class="hljs-keyword">WHERE</span> country <span class="hljs-keyword">IN</span><br>        (<span class="hljs-keyword">SELECT</span> country <span class="hljs-keyword">FROM</span> teachers <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> country<br>            <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(age) <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(age) <span class="hljs-keyword">FROM</span> teachers))<br></code></pre></td></tr></table></figure></li></ul><h3 id="子查询-Base"><a href="#子查询-Base" class="headerlink" title="子查询(Base)"></a>子查询(Base)</h3><ul><li>SELECT 语句中的子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name(s)`<br><span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` OPERATOR (<br>    <span class="hljs-keyword">SELECT</span> `column_name(s)`<br>    <span class="hljs-keyword">FROM</span> `table_name`<br>);<br></code></pre></td></tr></table></figure><ul><li>INSERT 语句中的子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `table_name`<br><span class="hljs-keyword">SELECT</span> `colnum_name(s)`<br><span class="hljs-keyword">FROM</span> `table_name`<br>[ <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">VALUE</span> OPERATOR ]<br></code></pre></td></tr></table></figure><ul><li>UPDATE 语句中的子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATE `table_name` <br><span class="hljs-keyword">SET</span> `column_name` <span class="hljs-operator">=</span> `new_value`<br><span class="hljs-keyword">WHERE</span> `column_name` OPERATOR <br>   (<span class="hljs-keyword">SELECT</span> `column_name`<br>   <span class="hljs-keyword">FROM</span> `table_name`<br>   [<span class="hljs-keyword">WHERE</span>] )<br></code></pre></td></tr></table></figure><ul><li>DELETE 语句中的子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` OPERATOR <br>   (<span class="hljs-keyword">SELECT</span> `column_name`<br>   <span class="hljs-keyword">FROM</span> `table_name`  <br>   [<span class="hljs-keyword">WHERE</span>] )<br></code></pre></td></tr></table></figure><h3 id="子查询-Adv"><a href="#子查询-Adv" class="headerlink" title="子查询(Adv.)"></a>子查询(Adv.)</h3><ul><li><p>内联视图子查询</p><ul><li>将查询的结果集作为一个查询表，继续进行查询操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> xxxx<br>) `T`<br><span class="hljs-keyword">WHERE</span> xxx <span class="hljs-operator">=</span> (<br><span class="hljs-keyword">SELECT</span> xxxx<br>);<br></code></pre></td></tr></table></figure></li><li><p>IN 操作符的多行子查询 / NOT IN </p></li><li><p>ANY 操作符的多行子查询</p><ul><li>在子查询中使用 ANY ，表示与子查询返回的任何值比较为真，则返回真</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `column_name(s)`<br><span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> `column_name` OPERATOR<br>   <span class="hljs-keyword">ANY</span>(<span class="hljs-keyword">SELECT</span> column_name<br>   <span class="hljs-keyword">FROM</span> table_name)<br></code></pre></td></tr></table></figure></li><li><p>ALL 操作符的多行子查询</p><ul><li>在子查询中使用 ALL ，表示与子查询返回的所有值比较为真，则返回真</li></ul></li><li><p>多列子查询</p></li><li><p>HAVING 子句中的子查询</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NOTE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
