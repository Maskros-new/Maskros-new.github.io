{"meta":{"title":"Maskros' Blog","subtitle":"","description":"","author":"Maskros","url":"https://maskros.top","root":"/"},"pages":[{"title":"Who Am I","date":"2021-08-27T03:12:31.000Z","updated":"2022-07-13T09:11:29.519Z","comments":true,"path":"about/index.html","permalink":"https://maskros.top/about/index.html","excerpt":"","text":"ACM破铜烂铁收集大师，运动、音乐爱好者，乐队混子bass手，综上。"},{"title":"友情链接","date":"2022-05-15T15:11:46.359Z","updated":"2022-05-15T15:11:46.359Z","comments":true,"path":"links/index.html","permalink":"https://maskros.top/links/index.html","excerpt":"","text":""},{"title":"message-board","date":"2022-02-04T15:50:10.174Z","updated":"2022-02-04T15:50:10.174Z","comments":true,"path":"message-board/index.html","permalink":"https://maskros.top/message-board/index.html","excerpt":"","text":"这是一个留言板，欢迎带🔥开喷🤡"},{"title":"文章分类","date":"2020-11-01T16:00:00.000Z","updated":"2021-07-29T02:44:39.630Z","comments":true,"path":"categories/index.html","permalink":"https://maskros.top/categories/index.html","excerpt":"","text":"","author":"Maskros"},{"title":"tags","date":"2020-09-19T08:19:22.000Z","updated":"2021-07-29T02:41:27.086Z","comments":true,"path":"tags/index.html","permalink":"https://maskros.top/tags/index.html","excerpt":"","text":"","author":"Maskros"}],"posts":[{"title":"深度学习：应用数学基础","slug":"note/深度学习_应用数学基础","date":"2022-07-14T08:15:00.000Z","updated":"2022-07-14T08:18:52.216Z","comments":true,"path":"/post/note/深度学习_应用数学基础.html","link":"","permalink":"https://maskros.top/post/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80.html","excerpt":"深度学习：应用数学基础 ref: 花书 1. 线性代数 标量、向量、矩阵、张量 (坐标超过两维) 转置、矩阵相加、标量和矩阵相加/相乘 深度学习中允许矩阵和向量相加：向量和矩阵的每一行相加(广播) 矩阵乘积(product)：C = AB，其中：A: m×n，B: n×p，C: m×p，服从分配律、结合律，不满足交换律 元素对应乘积/Hadamard乘积：C = A ⊙ B, 矩阵中对应元素的乘积 向量点积：二者相同维数，可以看做矩阵乘积 ，服从交换律： 矩阵乘积转置： 线性方程组：Ax=b，其中：A∈, b∈, x∈是要求解的未知向量 单位矩阵：, ，主对角线元素都是1，其余为0 逆矩阵： 可化为","text":"深度学习：应用数学基础 ref: 花书 1. 线性代数 标量、向量、矩阵、张量 (坐标超过两维) 转置、矩阵相加、标量和矩阵相加/相乘 深度学习中允许矩阵和向量相加：向量和矩阵的每一行相加(广播) 矩阵乘积(product)：C = AB，其中：A: m×n，B: n×p，C: m×p，服从分配律、结合律，不满足交换律 元素对应乘积/Hadamard乘积：C = A ⊙ B, 矩阵中对应元素的乘积 向量点积：二者相同维数，可以看做矩阵乘积 ，服从交换律： 矩阵乘积转置： 线性方程组：Ax=b，其中：A∈, b∈, x∈是要求解的未知向量 单位矩阵：, ，主对角线元素都是1，其余为0 逆矩阵： 可化为 线性组合(linear combination)：为了分析Ax=b有多少解，将A的列向量看做从原点出发的不同方向，确定有多少种方法可以到达向量b，向量x中的每个元素表示应该沿这些方向走多远，即 生成子空间(span)：原始向量线性组合后所能抵达的点的集合。 列空间/值域(range)：确定Ax=b是否有解，相当于确定向量b是否在A列向量的生成子空间中，该span称为列空间/值域。 线性无关：一组向量中的任意一个向量都不能表示成其他向量的线性组合。 矩阵可逆的前提是必须是方阵，且所有列向量线性无关。 奇异方阵：列向量线性相关。 范数(norm)：用于衡量向量大小，形式上范数定义如下：， 其中: , 范数(包括范数)是将向量映射到非负值的函数，直观上向量x的范数衡量从原点到点x的距离，严格讲范数是满足下列性质的任意函数： f(x)=0 =&gt; x = 0; f(x + y) ≤ f(x) + f(y) （三角不等式(triangle inequality)） ∀α∈, f(αx)=|α|f(x) 范数：p=2，又称欧几里得范数，表示原点出发到向量x确定的点的欧几里得距离，在机器学习中常简化表示为 ，略去下标2。 平方范数：也常用来衡量向量的大小，可以简单的通过点积计算，在数学和计算上比范数方便，但在原点附近增长十分缓慢。 范数：在各个位置斜率相同，同时保持简单的数学形式，简化如下： ，在ML问题中零和非零元素之间的差异非常重要时通常用范数。每当x中某个元素从0增加到a，对应范数也会增加a。有时统计向量中非0元素的个数来衡量向量大小时，阿范数也通常作为表示非零元素数目的替代函数。 (最大范数)：表示向量中具有最大幅值的元素的绝对值， Frobenius范数：衡量矩阵的大小， , 类似于向量的范数 两个向量的点积可用范数表示：，θ表示x和y的夹角。 对角矩阵(diagonal matrix)：只在主对角线上含有非零元素的矩阵。对角矩阵的乘法计算非常高效，计算乘法diag(v)x，只需将x中的每个元素放大倍，即diag(v)x=v⊙x。同理，计算对角矩阵的逆矩阵也很高效。故将一些矩阵限制为对角矩阵可以得到计算代价较低的算法。也适用于长方形的矩阵，涉及缩放。 对称矩阵(symmetric ~)：转置和自己相等的矩阵，，某些不依赖参数顺序的双参数函数生成元素时常会出现，如距离函数。 单位向量(unit vector)：具有单位范数的向量， 正交(orthogonal)：，若两个向量都有非零范数，则夹角为90°。在中，至多有n个范数非零向量相互正交，若他们不但相互正交且范数均为1，则称为标准正交(orthonormal)。 正交矩阵(orthogonal ~)：行向量和列向量是分别标准正交的方阵，即，意味着，求逆计算代价小。 特征分解(eigendecomposition)：将矩阵分解成一组特征向量和特征值。只对方阵。 特征向量(eigenvector)/特征值(eigenvalue)：与A相乘后相当于对该向量进行缩放的非零向量v：，标量 λ 称为这个特征向量对应的特征值。如果v是A的特征向量，任何缩放后的向量sv(s ∈ , s ≠ 0)也是A的特征向量且与v有相同的特征值，通常考虑单位特征向量。当且仅当含有零特征值时矩阵是奇异的。 A的特征分解：，其中V={, , … , }，为n个线性无关的特征向量，λ=[, … , ]，分别对应每个特征值。 实对称矩阵的特征分解： , 其中Q是A的特征向量组成的正交矩阵，Λ是对角矩阵，特征值 对应特征向量为矩阵的第i列。因为Q是正交矩阵，可以将A看做沿方向延展倍的空间。通常降序排列Λ的元素，使特征分解唯一当且仅当所有特征值唯一。实对称矩阵的特征分解可用于优化二次方程，其中限制，当x等于A的某个特征向量时，f将返回对应特征值。f的值域位于特征值最值之间。 正定(positive definite)/半正定(positive semidefinite)矩阵：所有特征值都是整数/非负数，半正定矩阵保证, ，正定矩阵保证 =&gt; 。 奇异值分解(singular value decomposition, SVD)：将矩阵分解为奇异向量(singular vector)和奇异值(~ value)。每一个实数矩阵都有一个奇异值分解，但不一定都有特征分解。不一定是方阵。 A的奇异值分解：，假设A为m×n，则U为m×m，D为m×n，V为n×n的矩阵。矩阵U和V定义为正交矩阵，矩阵D定义为对角矩阵，不一定是方阵。对角矩阵D对角线上的元素称为A的奇异值，U的列向量称为左奇异向量，是的特征向量；V的列向量称为右奇异向量，是的特征向量。A的非零奇异值是，同时也是特征值的平方根。 SVD应用：拓展矩阵求逆到非方矩阵上。 Moore-Penrose伪逆：，在求解线性方程Ax=y时，一般通过A的左逆B来求解：x=By，如果A的行数大于列数，那么可能没有解，反之，可能有多个解。计算伪逆使用公式：，其中U,D,V都是矩阵A奇异值分解得到的矩阵，对角矩阵D的伪逆是其非零元素取倒数后再转置得到。 当A的列数多于行数时，使用伪逆求解线性方程是众多解法中的一种，特别地，是方程所有可行解中最小的一个；当行数多于列数时，可能没有解，通过伪逆得到的x使得Ax和y的欧几里得距离 最小。 迹运算：返回对角元素和： 用处：描述清晰，可以通过矩阵乘法和迹运算符号描述很多矩阵运算而不使用求和符号，ex：Frobenius范数： 。性质： Tr(A)=Tr(A) Tr(ABC)=Tr(CAB)=Tr(BCA)，多个矩阵相乘得到方阵的Tr，和将最后一个矩阵挪到前面得到的Tr相同 Tr(AB)=Tr(BA)，其中A∈，B∈； a=Tr(a)，a是标量 行列式：det(A)，是将方阵A映射到实数的函数，行列式等于矩阵特征值的乘积。行列式的绝对值可用于衡量矩阵参与矩阵乘法后空间扩大或缩小了多少：若行列式是0，则空间至少沿某一维完全收缩，失去所有的体积，如果是1，则该转换保持空间体积不变。 主成分分析(PCA) 主成分分析(principal components analysis, PCA)是一个简单的ML算法，可以通过基础线代知识推导 xx","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"深度学习","slug":"深度学习","permalink":"https://maskros.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"math","slug":"math","permalink":"https://maskros.top/tags/math/"}]},{"title":"Canny边缘检测：数字图像处理典中典","slug":"note/Canny","date":"2022-05-24T08:30:00.000Z","updated":"2022-07-13T08:59:59.402Z","comments":true,"path":"/post/note/Canny.html","link":"","permalink":"https://maskros.top/post/note/Canny.html","excerpt":"Canny边缘检测：数字图像处理典中典 《算法设计与分析》 汇报报告 引言提取图片的边缘信息是底层数字图像处理的基本任务之一。 图像边缘信息主要集中在高频段，通常说图像锐化或检测边缘，实质就是高频滤波。何为边缘？图象局部区域亮度变化显著的部分，对于灰度图像来说，也就是灰度值有一个明显变化，既从一个灰度值在很小的缓冲区域内急剧变化到另一个灰度相差较大的灰度值。在提高对景物边缘的敏感性的同时，可以抑制噪声的方法才是好的边缘提取方法。 Canny边缘检测算法是澳洲计算机科学家约翰·坎尼（John F. Canny）于1986年开发出来的一个多级边缘检测算法，其目标是找到一个最优的边缘，在传统的边缘检测算法中较为出色，截止2014年8月, Canny发表的该篇论文，已被引用19000余次。随着时代的发展，神经网络所具有的自学习、自适应和很强的信息综合能力，使它成为了更有效的边缘检测算法，可以完成普通的边缘算子难以完成的边缘检测。但是Canny算子、包括其改进版仍旧在很多领域有广泛的应用。在这里我将致敬经典，探寻一下它的底层实现。","text":"Canny边缘检测：数字图像处理典中典 《算法设计与分析》 汇报报告 引言提取图片的边缘信息是底层数字图像处理的基本任务之一。 图像边缘信息主要集中在高频段，通常说图像锐化或检测边缘，实质就是高频滤波。何为边缘？图象局部区域亮度变化显著的部分，对于灰度图像来说，也就是灰度值有一个明显变化，既从一个灰度值在很小的缓冲区域内急剧变化到另一个灰度相差较大的灰度值。在提高对景物边缘的敏感性的同时，可以抑制噪声的方法才是好的边缘提取方法。 Canny边缘检测算法是澳洲计算机科学家约翰·坎尼（John F. Canny）于1986年开发出来的一个多级边缘检测算法，其目标是找到一个最优的边缘，在传统的边缘检测算法中较为出色，截止2014年8月, Canny发表的该篇论文，已被引用19000余次。随着时代的发展，神经网络所具有的自学习、自适应和很强的信息综合能力，使它成为了更有效的边缘检测算法，可以完成普通的边缘算子难以完成的边缘检测。但是Canny算子、包括其改进版仍旧在很多领域有广泛的应用。在这里我将致敬经典，探寻一下它的底层实现。 步骤Canny边缘检测算法主要包含以下五个步骤： 图像灰度化(降维处理) 将三个通道的像素值转换为单通道数据，减少计算量。 高斯滤波(平滑和降噪) 由于边缘检测对图像噪声很敏感，所以需要平滑图像。 引入高斯滤波函数为： 该函数各向同性，其曲线是草帽状的对称图，该曲线对整个覆盖面积求积分为1。高斯滤波的思路就是：对高斯函数进行离散化，以离散点上的高斯函数值为权值，对我们采集到的灰度矩阵的每个像素点做一定范围邻域内的加权平均，即可有效消除高斯噪声。 对于离散的高斯卷积核H: (2k+1)×(2k+1) 维，其元素计算方法为： 在这里使用 3×3 的卷积核，最后将得到的权值进行归一化，将权值的范围约束在[0,1]之间，并且所有的值的总和为1，得到高斯核卷积模板。 高斯滤波时将模板与高斯核卷积即可。即用一个高斯矩阵乘以每一个像素点及其邻域，取其带权重的平均值作为最后的灰度值。 计算图像梯度值和方向 边缘就是灰度值变化较大的的像素点的集合，在图像中，用梯度来表示灰度值的变化程度和方向。 在这里通过点乘Sobel算子，可以得到图像水平方向和垂直方向的梯度值， A表示原始图像，Gx, Gy 表示经横向及纵向边缘检测的图像。 $G_x= AG_y = A$ 随后由以下公式求出梯度值的大小和方向。 应用非极大值抑制NMS 非极大值抑制算法 (Non-maximum suppression, NMS)，寻找像素点局部最大值，将非极大值点所对应的灰度值置为0，这样可以剔除掉一大部分非边缘的点，从而得到一张二值图像。具体方法为：在上一步利用Sobel算子计算得到每个像素的梯度大小和方向后，我们遍历每个像素，判断该像素的梯度大小在该像素梯度方向上是否是其邻域中的局部最大值。根据梯度方向进行分类讨论。 如图所示，点A在边缘上，A的梯度方向垂直于边缘，B和C在A的梯度方向上，因此A和B、C比较来确定A的梯度是否为局部最大值。如果A的梯度为局部最大值，则A进入下一步，否则判断A不是边缘，A被抑制（置为0）。 双阈值检测确定边界(滞后阈值法) 这一步我们设置两个阈值 和 。遍历所有像素，梯度大小大于 的像素点被归为“确定边缘”像素，被保留；梯度大小小于 的像素点被认为一定不属于边缘，被丢弃。对于那些梯度大小介于 和 之间的像素点，如果它们连接到“确定边缘”像素，则它们被视为边缘的一部分。否则，它们也会被丢弃。如下图所示： A 在 之上，因此被认为是“确定边缘”。虽然 C 低于 ，但它连接到边A，所以C也被认为是边缘，我们得到了完整的曲线。B虽然在最小值以上，且与C边在同一区域内，但它没有连接到任何“确定边缘”，因此被丢弃。因此，为了得到正确的结果，我们必须相应地选择合适的 。 实现过程 灰度化 Mat RGB_Gray(Mat img) { Mat ret = Mat::zeros(img.size(), CV_8UC1); for (int i = 0; i &lt; img.rows; i++) { for (int j = 0; j &lt; img.cols; j++) { // B, G, R ret.at&lt;uchar&gt;(i, j) = saturate_cast&lt;uchar&gt;( 0.114 * img.at&lt;Vec3b&gt;(i, j)[0] + 0.587 * img.at&lt;Vec3b&gt;(i, j)[1] + 0.299 * img.at&lt;Vec3b&gt;(i, j)[2]); } } return ret; } 高斯滤波 获取高斯核 void GetGaussianKernel(double **KernalModel, int Kernalsize, double sigma) { // 初始化高斯核, 高斯核方差, 高斯核大小 const double PI = acos(-1.0); int center = Kernalsize / 2; //中心 double sum = 0; //高斯模板总和 for (int i = 0; i &lt; Kernalsize; i++) { //高斯模板计算 for (int j = 0; j &lt; Kernalsize; j++) { KernalModel[i][j] = (1 / (2 * PI * sigma * sigma)) * exp(-((i - center) * (i - center) + (j - center) * (j - center)) / (2 * sigma * sigma)); sum += KernalModel[i][j]; } } cout &lt;&lt; \"\\nNormalized Gaussian: \" &lt;&lt; \"\\n\"; for (int m = 0; m &lt; Kernalsize; m++) { // 归一化 for (int n = 0; n &lt; Kernalsize; n++) { KernalModel[m][n] /= sum; cout &lt;&lt; KernalModel[m][n] &lt;&lt; \", \"; } cout &lt;&lt; '\\n'; } } ​ 高斯滤波 Mat GaussFilter(Mat img, double sigma, int Kernalsize) { // 高斯核方差, 高斯核大小（奇数） Mat ret = img.clone(); int height = img.rows, width = img.cols; // 高斯核 double **KernalModel = new double *[Kernalsize]; //卷积核数组 for (int i = 0; i &lt; Kernalsize; i++) { KernalModel[i] = new double[Kernalsize]; } GetGaussianKernel(KernalModel, Kernalsize, sigma); //获取高斯+核 int diff = Kernalsize / 2; // 边界 double tmp; for (int i = diff; i &lt; height - diff; i++) { //高斯滤波, 边界直接用原来的值 for (int j = diff; j &lt; width - diff; j++) { tmp = 0; for (int m = 0; m &lt; Kernalsize; m++) { for (int n = 0; n &lt; Kernalsize; n++) { tmp = tmp + KernalModel[m][n] * img.at&lt;uchar&gt;(i - diff + m, j - diff + n); } } ret.at&lt;uchar&gt;(i, j) = uchar(tmp); } } return ret; } 计算图像梯度值和方向 void SobelGrade(Mat img, Mat Gx, Mat Gy, Mat Arg, Mat Grad) { // Gx,Gy: x,y方向梯度图, Arg:梯度角度图，Grad:梯度模值图 double KernalModel1[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}}; double KernalModel2[3][3] = {{1, 2, 1}, {0, 0, 0}, {-1, -2, -1}}; int height = img.rows, width = img.cols; int KernalSize = 3; //定义卷积核大小 int diff = KernalSize / 2; // 边界 double tmp1, tmp2; for (int i = diff; i &lt; height - diff; i++) { for (int j = diff; j &lt; width - diff; j++) { tmp1 = 0, tmp2 = 0; for (int m = 0; m &lt; KernalSize; m++) { // 模板卷积操作 for (int n = 0; n &lt; KernalSize; n++) { tmp1 = tmp1 + KernalModel1[m][n] * img.at&lt;uchar&gt;(i - diff + m, j - diff + n); tmp2 = tmp2 + KernalModel2[m][n] * img.at&lt;uchar&gt;(i - diff + m, j - diff + n); } } Gx.at&lt;uchar&gt;(i, j) = ((abs(tmp1)) != 0) ? abs(tmp1) : 0.0000001; //x方向, 需要防止分母为0 Gy.at&lt;uchar&gt;(i, j) = abs(tmp2); //y方向 Grad.at&lt;uchar&gt;(i, j) = sqrt(tmp1 * tmp1 + tmp2 * tmp2); //梯度模值 Arg.at&lt;uchar&gt;(i, j) = atan(tmp1 / tmp2) * 57.3; // 梯度角度 } } } 应用非极大值抑制NMS 根据梯度角度定义梯度方向 int GetDir(double num) { // num: 梯度角度 if (num &lt; -67.5) return 1; // -90 else if (num &gt;= -67.5 &amp;&amp; num &lt; -22.5) return 2; // -45 else if (num &gt;= -22.5 &amp;&amp; num &lt; 22.5) return 3; // 0 else if (num &gt;= 22.5 &amp;&amp; num &lt; 67.5) return 4; // 45 else return 1; // 90 } ​ 非极大值抑制NMS：沿着梯度方向 判断该点的梯度是否为最大 Mat GetNMS(Mat Arg, Mat Grad, int diff) { // Arg:梯度角度图, Grad:梯度模值, diff:沿着梯度方向判断的个数 Mat ret = Grad.clone(); int height = Grad.rows, width = Grad.cols; for (int i = diff; i &lt; height - diff; i++) { for (int j = diff; j &lt; width - diff; j++) { int dir = GetDir(Arg.at&lt;uchar&gt;(i, j)); if (dir == 1) { // -90 90 for (int index = 0; index &lt; diff; index++) { //判断是否为极大值 if ((Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i - diff + index, j)) || (Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i + diff - index, j))) { ret.at&lt;uchar&gt;(i, j) = 0; break; } } } else if (dir == 2) { // -45 for (int index = 0; index &lt; diff; index++) { if ((Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i - diff + index, j - diff + index)) || (Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i + diff - index, j + diff - index))) { ret.at&lt;uchar&gt;(i, j) = 0; break; } } } else if (dir == 3) { // 0 for (int index = 0; index &lt; diff; index++) { if ((Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i, j - diff + index)) || (Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i, j + diff - index))) { ret.at&lt;uchar&gt;(i, j) = 0; break; } } } else if (dir == 4) { // 45 for (int index = 0; index &lt; diff; index++) { if ((Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i - diff + index, j + diff - index)) || (Grad.at&lt;uchar&gt;(i, j) &lt; Grad.at&lt;uchar&gt;(i + diff - index, j - diff + index))) { ret.at&lt;uchar&gt;(i, j) = 0; break; } } } } } return ret; } 双阈值检测确定边界 Mat GetDouThre(Mat img, Mat LThImg, Mat HThImg, double lowThreshold, double highThreshold, int size) { // LThImg, HThImg: 低、高阈值图, lowThreshold, highThreshold: 低、高阈值, int height = img.rows, width = img.cols; for (int i = 0; i &lt; height; i++) { // 高低阈值处理 for (int j = 0; j &lt; width; j++) { if (img.at&lt;uchar&gt;(i, j) &gt; lowThreshold) { //低阈值处理 LThImg.at&lt;uchar&gt;(i, j) = 255; } else { LThImg.at&lt;uchar&gt;(i, j) = 0; } if (img.at&lt;uchar&gt;(i, j) &gt; highThreshold) { //高阈值处理 HThImg.at&lt;uchar&gt;(i, j) = 255; } else { HThImg.at&lt;uchar&gt;(i, j) = 0; } } } Mat ret = HThImg.clone(); for (int i = 0; i &lt; height; i++) { //双阈值检测边缘 for (int j = 0; j &lt; width; j++) { if ((HThImg.at&lt;uchar&gt;(i, j) == 0) &amp;&amp; (LThImg.at&lt;uchar&gt;(i, j) == 255)) { for (int m = i - size; m &lt; i + size; m++) { // 判断size * size 是否存在高阈值点 如果当前点也是边缘 for (int n = j - size; n &lt; j + size; n++) { if (ret.at&lt;uchar&gt;(m, n) == 255) { ret.at&lt;uchar&gt;(i, j) = 255; break; } } } } } } return ret; } main(): int main() { Mat src = imread(\"..\\\\lina.png\"); if (!src.data) { cout &lt;&lt; \"Can not load the image!\" &lt;&lt; endl; return -1; } imshow(\"source\", src); // 1. 灰度化 Mat grayimg = RGB_Gray(src); // 2. 高斯滤波 Mat GaussFilterimg = GaussFilter(grayimg, 1, 3); // 3. 计算梯度值和方向 Mat Gx = GaussFilterimg.clone(), Gy = GaussFilterimg.clone(), Arg = GaussFilterimg.clone(), Grad = GaussFilterimg.clone(); SobelGrade(GaussFilterimg, Gx, Gy, Arg, Grad); // 4. 非极大值抑制NMS Mat NMSimg = GetNMS(Arg, Grad, 3); // 5. 双阈值检测 Mat LThimg = NMSimg.clone(), HThimg = NMSimg.clone(); double lowThreshold = 50, highThreshold = 100; int Dousize = 7; Mat Douimg = GetDouThre(NMSimg, LThimg, HThimg, lowThreshold, highThreshold, Dousize); imshow(\"Canny\", Douimg); waitKey(); return 0; } 效果原图/灰度图/高斯滤波/梯度值 梯度角度/非极大值抑制NMS/双阈值结果 原图/结果图 总结与展望在计算机视觉领域，我的了解还只是简单的基础层面，由于最开始接触OpenCV时跟着随便做了一个小玩意，其中就用到了Canny边缘检测，但是只是通过调包完成的，跟着抄了几行就跑完了，正好借助这次机会就探索了一下它的原理，通过C++和OpenCV复现了一下它的实现过程，实现起来还是有一点小麻烦的。由于在Canny算法中，部分参数都是需要手动去设置的，比如高斯卷积核的大小， 的取值，双阈值检测中 的预设，都会影响到结果。我在这里由于对相应的参数理解还不够深刻，所以找寻了一下常见的参数直接代入，因此结果还是有待优化。 Canny算子不容易受噪声干扰，得到的边缘精细且准确，缺点就是运算代价较高，同时运行于实时图像处理较困难，适用于高精度要求的应用。在实验过程中，我尝试运行了一些较大的图片，很难得到结果，想必在OpenCV库中封装好的函数一定做出了更好的优化。 现如今，神经网络所具有的自学习、自适应和很强的信息综合能力，使它成为了更有效的边缘检测算法，它可以海量学习数据集，提取特征，从而完成一些传统算法所做不到的事情，完成普通的边缘算子难以完成的边缘检测，在这里尚且不谈。Canny算子在传统边缘检测算法中已经属于性能较好的，我在网上查找相关论文，发现不少学者都已经对Canny算法做出了部分优化，并且效果显著。让我不禁感慨时代在不断进步，想要在相关领域不断发展，就要时刻关注前沿的最新消息。 总体来说，边缘检测算法应用面非常广，遍及很多领域，是计算机视觉领域的常用算法，了解其中的原理和思想让我受益匪浅，也对图像的性质和对其的操作更加的了解。不再成为调包小子，理解原理才能更好的调包。","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://maskros.top/tags/OpenCV/"},{"name":"视觉","slug":"视觉","permalink":"https://maskros.top/tags/%E8%A7%86%E8%A7%89/"}]},{"title":"树 状 数 组","slug":"algorithm/learn/树状数组","date":"2022-05-13T03:55:50.000Z","updated":"2022-07-13T09:05:10.988Z","comments":true,"path":"/post/algorithm/learn/树状数组.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.html","excerpt":"树状数组Binary Indexed Tree 二进制下标树 引入基本操作： 的单点修改和区间查询 核心：巧妙利用二进制，如果我们要求前11项和，可以分别查询, , 的和再相加，即不断去掉二进制数最右边的一个1的过程。如果区间求和，使用前缀和的思想做差即可。","text":"树状数组Binary Indexed Tree 二进制下标树 引入基本操作： 的单点修改和区间查询 核心：巧妙利用二进制，如果我们要求前11项和，可以分别查询, , 的和再相加，即不断去掉二进制数最右边的一个1的过程。如果区间求和，使用前缀和的思想做差即可。 核心实现：求二进制最低位的1： Code0x01 单点修改 &amp; 区间查询#define maxn 100005 #define lowbit(x) x &amp; (-x) int tr[maxn]; // 单点修改 init void update(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr[pos] += x; } } // 前缀和 int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr[pos]; } return ans; } // 区间查询 int query(int l, int r) { return query(r) - query(l - 1); } 0x02 区间修改 &amp; 单点查询 树状数组采用差分建立，单点查询即采用原数组的区间查询即可 // 区间修改 void update(int l, int r, int x) { update(l, x); update(r + 1, -x); } // 单点查询 即做前缀和 int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr[pos]; } return ans; } *0x03 区间修改 &amp; 区间查询pf: 由差分形式可知，第 个数到第 个数可表示为: ​ 结论： ​ 可用区间修改和查询来维护，而​ 用另一个update来存即可 完整板子: #define maxn 100005 #define lowbit(x) x &amp; (-x) #define rep(i, x, y) for (int i = x; i &lt; y; i++) int tr[maxn], tr2[maxn]; // 单点修改 init void update(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr[pos] += x; } } void update2(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr2[pos] += x * (i - 1); } } // 区间修改 void update(int l, int r, int x) { update(l, x); update(r + 1, -x); update2(l, x); update2(r + 1, -x); } // 前缀和 单点查询 int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr[pos]; } return ans; } int query2(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr2[pos]; } return ans; } // 区间查询 int query(int l, int r) { return (r * query(r) - query2(r)) - ((l - 1) * query(l - 1) - query2(l - 1)); } 应用：逆序对 Def: 逆序对： &amp;&amp; ，可用归并排序实现，此处用树状数组求解，其实求解的 核心：离散化+树状数组求顺序对 Step1: 离散化：另开一个数组d，d[i]用来存放第i大的数在原序列的什么位置，ex: a={3, 8, 5, 4, 6} ==&gt; d={2, 3, 5, 4, 1} int a[maxn], d[maxn], tr[maxn]; bool cmp(int x, int y) { if (a[x] == a[y]) return x &gt; y; // 避免元素相同、重要 return a[x] &gt; a[y]; // 按原序列第几大排列 } signed main() { cin &gt;&gt; n; rep(i, 1, n + 1) cin &gt;&gt; a[i], d[i] = i; // 初始化 sort(d + 1, d + 1 + n, cmp); // 离散化 } 经简易证明可知，d数组的顺序对个数等于a数组的逆序对个数，故可使用树状数组进行求解。 Step2: 求顺序对：每次把新的x放进去后，query(x-1)查找小于x的数的个数，统计答案 void update(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr[pos] += x; } } int query(int n) { // 查询1-n有几个数存在 int ret = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ret += tr[pos]; } return ret; } signed main() { cin &gt;&gt; n; rep(i, 1, n + 1) cin &gt;&gt; a[i], d[i] = i; // 初始化 sort(d + 1, d + 1 + n, cmp); // 离散化 int ans = 0; rep(i, 1, n + 1) { update(d[i], 1); ans += query(d[i] - 1); // 计数 } cout &lt;&lt; ans; } end.","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"树状数组","slug":"树状数组","permalink":"https://maskros.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"Deep Learning 基础杂记","slug":"note/DeepLearning","date":"2022-04-30T18:37:28.000Z","updated":"2022-07-13T09:02:35.267Z","comments":true,"path":"/post/note/DeepLearning.html","link":"","permalink":"https://maskros.top/post/note/DeepLearning.html","excerpt":"Deep Learning 基础杂记 纸上谈兵 Concepts表示学习(representation learning)：机器学习旨在自动地学到从数据的表示（representation）到数据的标记（label）的映射。表示学习希望能从数据中自动地学到映射，太理想。 深度学习(deep learning, DL)：把表示学习的任务划分成几个小目标，先从数据的原始形式中先学习比较低级的表示，再从低级表示学得比较高级的表示。类似分治思想。","text":"Deep Learning 基础杂记 纸上谈兵 Concepts表示学习(representation learning)：机器学习旨在自动地学到从数据的表示（representation）到数据的标记（label）的映射。表示学习希望能从数据中自动地学到映射，太理想。 深度学习(deep learning, DL)：把表示学习的任务划分成几个小目标，先从数据的原始形式中先学习比较低级的表示，再从低级表示学得比较高级的表示。类似分治思想。 深度神经网络(deep neural networks, DNN)：实现形式，很深。利用网络中逐层对特征进行加工的特性，逐渐从低级特征提取高级特征。三大因素：大数据，计算能力，算法创新。 多层感知机(multi-layer perceptrons, MLP)： 多层由全连接层组成的深度神经网络。多层感知机的最后一层全连接层实质上是一个线性分类器，而其他部分则是为这个线性分类器学习一个合适的数据表示，使倒数第二层的特征线性可分。 激活函数(activation function)：好的性质：不饱和，零均值，易计算 迁移学习(transfer learning)：利用源任务数据辅助目标任务数据下的学习。迁移学习适用于源任务数据比目标任务数据多，并且源任务中学习得到的低层特征可以帮助目标任务的学习的情形。在计算机视觉领域，最常用的源任务数据是ImageNet。对ImageNet预训练模型的利用通常有两种方式：1. 固定特征提取器。用ImageNet预训练模型提取目标任务数据的高层特征。2. 微调（fine-tuning）。以ImageNet预训练模型作为目标任务模型的初始化权值，之后在目标任务数据上进行微调。 多任务学习(multi-task learning)：训练一个大网络以同时完成全部任务。这些任务中用于提取低层特征的层是共享的，之后产生分支，各任务拥有各自的若干层用于完成其任务。适用于多个任务共享低层特征，并且各个任务的数据相似。 端到端学习(end-to-end learning)：通过一个深度神经网络直接学习从数据的原始形式到数据的标记的映射。 优化算法： 梯度下降(gradient descent, GD)算法：基本思想：先试探在当前位置往哪个方向走下降最快（即梯度方向），再朝着这个方向走一小步，重复这个过程直到你到达谷底。性能取决于三个因素：初始位置，山谷地形，步长。 误差反向传播(error Back-Propagation, BP)算法：误差error，训练目的使error尽量小，结合微积分中链式法则和算法设计中动态规划思想用于计算梯度。 滑动平均(moving average)：要前进的方向不再由当前梯度方向完全决定，而是最近几次梯度方向的滑动平均。应用：带动量(momenturn)的SGD(随机梯度下降)、Nesterov动量、Adam(ADAptive Momentum estimation) 等。 自适应步长: 自适应地确定权值每一维的步长。持续震荡时，步长小一些；一直沿着相同方向前进，步长大一些。应用：AdaGrad、RMSProp、Adam等。 学习率衰减：开始训练时，较大的学习率可以使你在参数空间有更大范围的探索；当优化接近收敛时，我们需要小一些的学习率使权值更接近局部最优点。 归一化/初始化(Normalization)： 基本思想：方差不变，即设法对权值进行初始化，使得各层神经元的方差保持不变 Xavier：从高斯分布或均匀分布中对权值进行采样，使得权值的方差是1/n，其中n是输入神经元的个数。该推导假设激活函数是线性的。 He/MSRA：从高斯分布或均匀分布中对权值进行采样，使得权值的方差是2/n。该推导假设激活函数是ReLU。因为ReLU会将小于0的神经元置零，大致上会使一半的神经元置零，所以为了弥补丢失的这部分信息，方差要乘以2。 批量归一化(batch-normalization，BN)：每层显式地对神经元的激活值做归一化，使其具有零均值和单位方差。BN使激活值的分布固定下来，这样可以使各层更加独立地进行学习，可以使得网络对初始化和学习率不太敏感。加快模型训练时的收敛速度，使得模型训练过程更加稳定，避免梯度爆炸或者梯度消失。同时起到一定的正则化作用。 偏差(bias)：偏差度量了网络的训练集误差和贝叶斯误差 (即能达到的最优误差) 的差距。高偏差的网络有很高的训练集误差，说明网络对数据中隐含的一般规律还没有学好。高偏差解决方案：训练更大的网络，更多的训练轮数，改变网络结构。 方差(variance)：方差度量了网络的验证集误差和训练集误差的差距。高方差的网络学习能力太强，把训练集中自身独有的一些特点也当作一般规律学习，使网络不能很好的泛化(generalize)到验证集。高方差解决方案：更多的数据，正则化，改变网络结构。 正则化(Regularization)： 基本思想：使网络的有效大小变小。网络变小之后，网络的拟合能力随之降低，这会使网络不容易过拟合到训练集。 L2正则化：倾向于使网络的权值接近0。这会使前一层神经元对后一层神经元的影响降低，使网络变得简单，降低网络的有效大小，降低网络的拟合能力。实质上是对权值做线性衰减，所以L2正则化也被称为权值衰减(weight decay)。 随机失活(Dropout)：随机选择一部分神经元，使其置零，不参与本次优化迭代。随机失活减少了每次参与优化迭代的神经元数目，使网络的有效大小变小。作用：降低神经元之间耦合，网络集成。 数据扩充：我们从现有数据中扩充生成更多数据，用生成的“伪造”数据当作更多的真实数据进行训练。 早停：发现验证集误差不再变化或者开始上升时，提前停止训练。 调参技巧： 随机搜索：事先并不知道哪些超参数对你的问题更重要，通常是比网格搜索(grid search)更有效的调参策略。 对数空间搜索：对于隐层神经元数目和层数，可以直接从均匀分布采样进行搜索。而对于学习率、L2正则化系数、和动量，在对数空间搜索更加有效。 实现技巧：图形处理单元(GPU)，向量化(vectorization) 无监督预训练(Unsupervised pre-training)：预训练阶段的样本不需要人工标注数据 有监督预训练(Supervised pre-training)：一种迁移学习，已经在一类问题训练好了一组模型参数的时候，想将该模型应用到类似但不同的其它问题上，不必从头开始训练网络，而是将上述模型参数作为网络初始值，在此基础上继续训练 输入层： 矩阵，维度与输入量的特征相关 隐藏层：进行线性矩阵运算： $H=XW_1+b_1Y=HW_2+b_2$ 激活层：在隐藏层中加入，为矩阵运算结果添加非线性，常见：阶跃、Sigmoid、ReLU(修正线性单元)、Tanh、Leaky ReLU等 Softmax层；计算公式做输出结果正规化处理 正规化：将最终输出转化为概率，，和为1 交叉熵损失(Cross Entropy Error)：衡量网络的优劣，1减去Softmax输出的概率，再求对数的负数，越接近于0，说明结果越准确 迭代：即迭代，神经网络需要反复迭代直到损失值变小到满意为止 链式法则：如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示 反向传播(backward)：参数优化的过程，优化对象：, 加法结点：原封不动 乘法结点：输入的值交叉相乘 仿射变换：, 对求导就是，对求导为，对求导为1，原封不动即可 ReLU: x &gt; 0, y = x, 求导为1, 原封不动；x &lt;= 0, y = 0, 传递值为0 Softmax-with-loss: 从前面的层输入的是(a1, a2, a3)，softmax层输出(y1, y2, y3)。此外，教师标签是(t1, t2, t3)，Cross Entropy Error层输出损失L,教师标签，就是表示是否分类正确的标签(0/1)。反向传播结果：(y1 − t1, y2 − t2, y3 − t3) 反向传播参数更新： 正则化惩罚项reg：避免最后求出的W过于集中，修正 学习率epsilon: 直接反向传播回来的量值可能会比较大，在寻找最优解的过程中可能会直接将最优解越过去，学习率通常很小，如0.0001，修正为 过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好地拟合数据 梯度爆炸/梯度消失：由于链式准则，当层数越深的时候，梯度将以指数形式传播，一般随着网络层数的增加会变得越来越明显。在根据损失函数计算的误差通过梯度反向传播的方式对深度网络权值进行更新时，得到的梯度值接近0或特别大，即为消失/爆炸。 鲁棒性(Robustness)：健壮性，模型具有较高的精度或有效性；对于模型假设出现的较小偏差(噪声)，只能对算法性能产生较小的影响；模型假设出现的较大偏差(离群点)，不可对算法性能产生“灾难性”的影响 backbone：主干网络 head：获取网络输出内容的网络，利用之前提取的特征做出预测 neck：backbone和haed之间，为了更好地利用backbone的特征 epoch：当一个完整的数据集通过神经网络一次并且返回一次的过程称为一个epoch，当一个epoch对于计算机太过庞大时，就需要把它分成多个小块 batch：在不能将数据一次性通过神经网络的适合，就需要将数据集分成几个batch batch_size：一个batch中的样本总数(一次训练所选取的样本数)，大小影响模型的优化程度和速度。直接影响到GPU内存的使用情况。 mAP(Mean Average Precision)：均值平均精度，作为object detection 中衡量检测精度的指标，mAP = 所有类别的平均精度求和除以所有类别。 FrameworksPyTorch：ML框架，具有强大的GPU加速的张量(tensor)计算，包含自动求导系统的DNN，动态图机制(可修改)，简单易上手 TensorFlow：ML框架，张量定义数据类型，把数据模型和操作定义在计算图中，使用会话进行计算，把计算定义在图上。静态图机制，2.0引入动态图机制Eager模式，但是API太多，不如Pytorch简洁 CNN卷积神经网络(Convolution Neural Network, CNN): 常用来处理图片数据，输入层，卷积层(CONV)，激励层(RELU)，池化层(POOL)，全连接层(Fc) 输入层：图像处理 均值化：把输入数据各个维度都中心化到0，所有样本求和求平均，然后用所有的样本减去这个均值样本就是去均值。 归一化：数据幅度归一化到同样的范围，对于每个特征而言，范围最好是[-1,1] PCA/白化：用PCA(主成分分析算法)降维，让每个维度的相关度取消，特征和特征之间是相互独立的。白化是对数据每个特征轴上的幅度归一化 卷积层：局部连接。选择n*n大小的局部区域(filter)，扫描整张图片，每一次对应圈起来n*n个，连接到下一层的神经元，然后产生n*n个权重，构成的矩阵叫做卷积核 卷积：计算过程为卷积核和对应区域相乘求和，产生新值。设filter滑动次数为m，则产生m个值，即下一层有m个神经元，构成矩阵为特征图(feature map) 卷积过程中： 深度depth(通道)：由上一层滤波器的个数决定 步长stride：每次滑动几步 填充值zero-padding：设置了stride，很有可能某些位置滑不到，避免了边缘信息被一步步舍弃的问题。同时控制feature map的输出尺寸 feature map= (inputsize + 2 * paddingsize - filtersize) / stride + 1 计算式： 输入尺寸： 卷积层参数：filters个数K，filter尺寸F，stride为S，zero padding为P 输出尺寸： 权重个数：权重共享后每个filter有, 一共有个权重和个偏移 常规设置: 激励层：通过激活函数，把卷积层的结果做非线性映射 池化层：降低各个特征图的维度，但可以保持大部分重要信息，排除冗余信息。。池化层夹在连续的卷积层中间，不需要参数控制，负责压缩数据和参数的量，减小过拟合。常用方式： Max pooling: 最大池化，定义一个空间邻域(n*n窗口)，并从窗口内的修正特征图中取出最大的元素，最大池化被证明效果更好。 Average pooling: 平均池化，定义一个空间邻域(n*n窗口)，并从窗口内的修正特征图算出平均值 全连接层：通常在CNN尾部，全连接层中所有神经元都有权重连接。通常卷积网络的最后会将末端得到的长方体平摊成一个长长的向量，并送入全连接层配合输出层进行分类 训练与优化：训练卷积核(filter) 误差反向传播(error Back-Propagation, BP)算法：误差error，训练目的使error尽量小，结合微积分中链式法则和算法设计中动态规划思想用于计算梯度。 梯度下降(gradient descent, GD)算法：基本思想：先试探在当前位置往哪个方向走下降最快（即梯度方向），再朝着这个方向走一小步，重复这个过程直到你到达谷底。性能取决于三个因素：初始位置，山谷地形，步长。 VGGVGG vs AlexNet：采用连续的几个3×3卷积核替代AlexNet中的较大卷积核(11×11, 7×7, 5×5)，卷积核级联叠加来代替。深度更深，参数更多，效果和可移植性更好，计算量比较大。常用于图片分类。 VGG-16：13conv(2+2+3+3+3) + 3fc，卷积核尺寸3×3，最大池化尺寸2×2，池化层都使特征图缩减一半，较小的filter size/kernal size 卷积不考虑正则，全连接考虑正则：卷积层w个数相对少，在一定程度上可以防止过拟合，而全连接层计算的w参数多，故需要考虑正则防止过拟合。 迁移学习：当数据集没有大到足以训练整个CNN网络时，可以对预训练好的ImageNet网络(VGG16, Inception-v3等)进行调整以适应新任务。两种类型： 特征提取：将预训练的网络视为一个任意特征提取器，图片经过输入层，然后前向传播，最后再指定层停止，提取输出结果作为输入图片的特征。 微调(fine-tuning)：更改预训练模型的结构，移除全连接层，添加一组自定义的全连接层进行新的分类。 R-CNN 目标检测算法分类： two-stage(两阶段)算法：如R-CNN, 其主要思路是先通过启发式方法（selective search）或者CNN网络（RPN)产生一系列稀疏的候选框，然后对这些候选框进行分类与回归，two-stage方法的优势是准确度高； one-stage(单阶段)算法：如Yolo和SSD，其主要思路是均匀地在图片的不同位置进行密集抽样，抽样时可以采用不同尺度和长宽比，然后利用CNN提取特征后直接进行分类与回归，整个过程只需要一步，所以其优势是速度快，但是均匀的密集采样的一个重要缺点是训练比较困难，这主要是因为正负样本极其不均衡，导致模型准确度稍低。 R-CNN：(Regions with CNN features)，用于目标检测的经典算法。将CNN方法引入目标检测领域。论文：Rich feature hierarchies for accurate object detection and semantic segmentation 基本流程： 候选区域生成： 一张图像生成1K~2K个候选区域 （采用选择性搜索(Selective Search) 方法） 特征提取： 对每个候选区域，使用 CNN 提取特征 类别判断： 特征送入每一类的 SVM 分类器，判别是否属于该类 位置精修： 使用回归器精细修正候选框位置 选择性搜索(selective search)：① 使用一种过分割手段，将图像分割成小区域 (1k~2k 个) 。 ② 查看现有小区域，按照合并规则合并可能性最高的相邻两个区域。重复直到整张图像合并成一个区域位置。 ③ 输出所有曾经存在过的区域，所谓候选区域。 合并规则：四种相似性度量：①颜色相似性(颜色直方图)；②纹理相似性(梯度直方图)；③size相似性(小区域之间优先合并)；④shape相似性(合并只能在紧邻的两个区域间进行，远离的两个区域不能合并)。最终相似性度量为以上四种的组合。 重叠度(IOU)：物体检测需要定位出物体的bounding box，定位精度评估公式：定义了两个bounding box的重叠度，即矩形框A、B的重叠面积占A、B并集的面积比例： 非极大值抑制(NMS)： 抑制不是极大值的元素，搜索局部的极大值。局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。选取那些邻域里分数最高(概率最大)，并且抑制那些分数低的窗口。具体方法： ​ ① 对矩阵中每列按从大到小进行排序； ​ ② 从每列最大的得分建议框开始，分别与该列后面的得分建议框进行IoU计算，若IoU&gt;阈值，则剔除得分较小的建议框，否则认为图像中存在多个同一类物体； ​ ③ 从每列次大的得分建议框开始，重复步骤②； ​ ④ 重复步骤③直到遍历完该列所有建议框； ​ ⑤ 遍历完矩阵所有列，即所有物体种类都做一遍非极大值抑制； ​ ⑥ 最后剔除各个类别中剩余建议框得分少于该类别阈值的建议框。 VOC(Visual Object Class)数据集：检测和识别标准化的数据集。比赛残留，2007和2012版本比较受欢迎。 候选框搜索阶段：搜出的候选框是矩形的，而且是大小各不相同。然而CNN对输入图片的大小是有固定的，对于每个输入的候选框都需要缩放到固定的大小。假设下一阶段CNN所需要的输入图片大小是个正方形图片227*227： 各向异性缩放：不管图片的长宽比例、是否扭曲，进行缩放 各向同性缩放：A. 先扩充后裁剪： 直接在原始图片中，把box的边界进行扩展延伸成正方形，然后再进行裁剪；如果已经延伸到了原始图片的外边界，那么就用box中的颜色均值填充；B. 先裁剪后扩充：先把box图片裁剪出来，然后用固定的背景颜色填充成正方形图片(背景颜色也是采用box的像素颜色均值)； 经过最后的试验，作者发现采用各向异性缩放、padding=16的精度最高。 CNN特征提取阶段： 网络结构设计：可选AlexNet和VGG16，VGG精度高但计算量是AlexNet的7倍。 网络有监督预训练：(图片数据库：ImageNet ILSVC) 直接采用如AlexNet的网络，参数不变，再fine-tuning训练，网络优化时采用随机梯度下降(SGD)法，学习率0.001 fine-tuning阶段：(图片数据库：PASCAL VOC) 我们接着采用 selective search 搜索出来的候选框 (PASCAL VOC 数据库中的图片)继续对上面预训练的CNN模型进行fine-tuning训练。假设要检测的物体类别有N类，那么我们就需要把上面预训练阶段的CNN模型的最后一层给替换掉，替换成N+1个输出的神经元(加1，表示还有一个背景) (20 + 1bg = 21)，然后这一层直接采用参数随机初始化的方法，其它网络层的参数不变；开始的时候，SGD学习率选择0.001，在每次训练的时候，我们batch size大小选择128，其中32个正样本、96个负样本。 正负样本：CNN阶段我们需要用IOU为2000个bounding box打标签。如果用selective search挑选出来的候选框与物体的人工标注矩形框(PASCAL VOC的图片都有人工标注)的重叠区域IoU大于0.5，那么就把这个候选框标注成物体类别（正样本），否则当做背景类别（负样本）。 SVM训练、测试阶段： 训练阶段：这是一个二分类问题，论文作者最后通过训练发现，如果选择IOU阈值为0.3效果最好，小于0.3为负样本，一旦CNN fc7层特征被提取出来，那么我们将为每个物体类训练一个svm分类器。当我们用CNN提取2000个候选框，可以得到2000×4096这样的特征向量矩阵，然后我们只需要把这样的一个矩阵与svm权值矩阵4096×N点乘(N为分类类别数目，因为我们训练的N个svm，每个svm包含了4096个权值w)，就可以得到结果了。将得到的特征输入到SVM进行分类看看这个feature vector所对应的region proposal是需要的物体还是无关的实物(background) 。 排序，canny边界检测之后就得到了我们需要的bounding-box。 测试阶段：使用selective search的方法在测试图片上提取2000个region propasals ，将每个region proposals归一化到227x227，然后再CNN中正向传播，将最后一层得到的特征提取出来。然后对于每一个类别，使用为这一类训练的SVM分类器对提取的特征向量进行打分，得到测试图片中对于所有region proposals的对于这一类的分数，再使用贪心的非极大值抑制(NMS)去除相交的多余的框。再对这些框进行canny边缘检测，就可以得到bounding-box。 YOLOYOLO(You Only Look Once)：one-stage方法，用一个单独的CNN模型实现end-to-end的目标检测。首先将输入图片resize成n×n，然后送入CNN网络，最后处理网络预测结果得到检测的目标 设计理念：将输入的图片分割成 网格，然后每个单元格负责去检测那些中心点落在该格子内的目标，打上label标签，如下图红色cell就负责预测狗。让每个框都预测B个边界框(bounding box)，每个bounding box有五个量：中心位置(x, y)，高h，宽w，以及这次预测的置信度c。需注意的是：中心坐标的预测值 (x, y) 是相对于每个单元格左上角坐标点的偏移值，单位相当于单元格大小，w和h是相对于整个图片的宽和高的比例，完成了归一化，都属于 范围。 归一化原因：通常做回归问题的时候都会将输出进行归一化，否则可能导致各个输出维度的取值范围差别很大，进而导致训练的时候，网络更关注数值大的维度。因为数值大的维度，算loss相应会比较大，为了让这个loss减小，那么网络就会尽量学习让这个维度loss变小，最终导致区别对待。 偏移计算：假设grid的size为S×S，原始图片的宽高为width, height，某物体中心坐标为(x, y)，其所在的cell左上角坐标为(x1, y1)，则坐标的偏移值可计算为 置信度(confidence)：两个方面：这个边界框含有目标的可能性大小 Pr(object) (非0即1) 和 边界框的准确度 IoU。定义置信度 分类问题：对每一个单元格要给出预测出的C个类别概率值，表征由该单元格负责预测的边界框其目标属于各个类别的概率，为各个边界框置信度下的条件概率，即。不管一个单元格预测多少个边界框，其只预测一组类别概率值，这是Yolo算法的一个缺点，在后来的改进版本中，Yolo9000是把类别概率预测值与边界框是绑定在一起的。同时，我们可以计算出各个边界框类别置信度(class-specific confidence scores): ，表征的是该边界框中目标属于各个类别的可能性大小以及边界框匹配目标的好坏。 总结：每个单元格需要预测 个值，即最终预测值为 大小的张量，对于PASCAL VOC数据，其共有20个类别，如果使用S=7，B=2，那么最终的预测结果就是 7×7×30 大小的张量。下图为模型预测值结构。 网络结构：Yolo采用卷积网络来提取特征，然后使用全连接层来得到预测值。网络结构参考GooLeNet模型，包含24个卷积层和2个全连接层，对于卷积层，主要使用1x1卷积来做channle reduction(通道缩减)，然后紧跟3x3卷积。对于卷积层和全连接层，采用Leaky ReLU激活函数。但是最后一层却采用线性激活函数。最后输出为 7×7×30 大小的张量。对于每一个单元格，前20个元素是类别概率值，然后2个元素是边界框置信度，两者相乘可以得到类别置信度，最后8个元素是边界框的(x, y, w, h)。 网络训练：在训练之前，先在ImageNet上进行了预训练，其预训练的分类模型采用上图中前20个卷积层，然后添加一个average-pool层和全连接层。预训练之后，在预训练得到的20层卷积层之上加上随机初始化的4个卷积层和2个全连接层。由于检测任务一般需要更高清的图片，所以将网络的输入从224x224增加到了448x448。流程如下图所示。 损失函数：Yolo算法将目标检测看成回归问题，所以采用的是均方差损失函数(MSE, Mean Squared Error)。但是对不同的部分采用了不同的权重值。首先区分定位误差和分类误差。对于定位误差，即边界框坐标预测误差，采用较大的权重 。然后区分不包含目标的边界框与含有目标的边界框的置信度，对于前者，采用较小的权重值 。其它权重值均设为1。然后采用均方误差，其同等对待大小不同的边界框，但是实际上较小的边界框的坐标误差应该要比较大的边界框要更敏感。为了保证这一点，将网络的边界框的宽与高预测改为对其平方根的预测，即预测值变为 。 由于每个单元格预测多个边界框。但是其对应类别只有一个。那么在训练时，如果该单元格内确实存在目标，那么只选择与ground truth的IOU最大的那个边界框来负责预测该目标，而其它边界框认为不存在目标。这样设置的一个结果将会使一个单元格对应的边界框更加专业化，其可以分别适用不同大小，不同高宽比的目标，从而提升模型性能。对于不存在对应目标的边界框，其误差项就是只有置信度，坐标项误差是没法计算的。而只有当一个单元格内确实存在目标时，才计算分类误差项，否则该项也是无法计算的。 最终的损失函数计算如下： 第一项是边界框中心坐标的误差项， 指的是第 个单元格存在目标，且该单元格中的第 个边界框负责预测该目标。第二项是边界框的高与宽的误差项。第三项是包含目标的边界框的置信度误差项。第四项是不包含目标的边界框的置信度误差项。最后一项是包含目标的单元格的分类误差项， 指的是第 个单元格存在目标。 置信度的target值 ：如果不存在目标，， 。如果存在目标， ，此时需要确定 ，当然你希望最好的话，可以将IOU取1，即 ，在YOLO实现中，使用了一个控制参数rescore(默认为1)，当其为1时，IOU不是设置为1，而是计算truth和pred之间的真实IOU。不过很多复现YOLO的项目还是取 ，这个差异不会太影响结果。 网络预测：不考虑batch，认为只是预测一张输入图片。最终的网络输出是 7×7×30 ，但是我们可以将其分割成三个部分：类别概率部分为 7×7×20 ，置信度部分为 7×7×2,，而边界框部分为 7×7×2×4 (对于这部分不要忘记根据原始图片计算出其真实值)。然后将前两项相乘（ 矩阵 乘 可以各补一个维度来完成，可以得到类别置信度值为 ，这里总共预测了7×7×2=98 个边界框。 预测过程：先对预测框使用NMS，然后再确定各个box的类别。对于98个boxes，首先将小于置信度阈值的值归0，然后分类别地对置信度值采用NMS，这里NMS处理结果不是剔除，而是将其置信度值归为0。最后才是确定各个box的类别，当其置信度值不为0时才做出检测结果输出。 优点：一个CNN网络来实现检测，训练与预测都是end-to-end，较简洁且速度快；对整张图片做卷积，检测目标有更大的视野，不容易对背景误判；泛化能力强，在做迁移时，模型鲁棒性高。 缺点：各个单元格仅仅预测两个边界框，而且属于一个类别。对于小物体，表现会不如人意。这方面的改进可以看SSD，其采用多尺度单元格。也可以看Faster R-CNN，其采用了anchor boxes。Yolo对于在物体的宽高比方面泛化率低(无法定位不寻常比例的物体)。当然Yolo的定位不准确也是很大的问题。 SSDSSD(Single Shot MultiBox Detector)：Single shot指明了SSD算法属于one-stage方法，MultiBox指明了SSD是多框预测，支持300，512的输入 核心：采用多尺度特征图用于检测，采用卷积进行检测，设置先验框 锚框(anchor box)/先验框(prior bounding box)：遍历输入图像上所有可能的像素框，然后选出正确的目标框，并对位置和大小进行调整就可以完成目标检测任务。这些进行预测的像素框即为先验框。 多尺度特征图：采用大小不同的特征图。CNN网络一般前面的特征图比较大，后面会逐渐采用stride=2的卷积或者pool来降低特征图大小。大特征图和小特征图都用来做检测，大特征图检测较小的目标，小特征图检测大目标。特征图的感受野大于目标大小时才能正确检测。 采用卷积进行检测：与Yolo最后采用全连接层不同，SSD直接采用卷积对不同的特征图来进行提取检测结果。对于形状为的特征图，只需要采用 这样比较小的卷积核得到检测值。 设置先验框：SSD借鉴了Faster R-CNN中anchor box的理念，将 feature map 切分为一个个格子feature map cell，对于每一个格子，设置的一系列固定大小的 default box(先验框) ，预测的bounding boxes（边界框）是以这些先验框为基准的，在一定程度上节约了时间。 检测值：对于每个单元的每个先验框，其都输出一套独立的检测值，对应一个边界框。 第一部分是各个类别的置信度或者评分，值得注意的是SSD将背景也当做了一个特殊的类别，如果检测目标共有c个类别，SSD其实需要预测 c + 1 个置信度值，其中第一个置信度指的是不含目标或者属于背景的评分。 第二部分是边界框的location，包含，表示中心坐标和宽高，真实预测值其实只是边界框相对于先验框的收缩量(offset)。先验框位置用 表示，对应边界框用 来表示，那么边界框的预测值 为： 这个过程为边界框的编码(encode)，预测时需进行解码(decode)，从预测值 l 中得到边界框的真实位置 b。有时会设置variance超参数来调整检测值，即在 l 前乘上一个 variance[0]~[3] 。 对于一个大小 的特征图，每个单元设置的先验框数目记为 ，那么每个单元需要 个预测值，由于SSD采用卷积做检测，所以需要 个卷积核，做 次卷积。 第三部分是default box的 scale (大小，归一化输入尺度的面积)和 aspect (横纵比)。 scale：，smin是0.2，表示最底层的scale是0.2，smax是0.9，表示最高层的scale是0.9，这就保证sk一定在0.2-0.9范围内。 aspect ratio：五种 {1, 2, 3, 1/2, 1/3} default宽/高计算公式：, ，二者乘积为scale平方。 正负样本：将 prior box 和 grount truth box 按照IOU(本论文叫做JaccardOverlap)进行匹配，匹配成功则正样本，显然这样产生的负样本的数量要远远多于正样本。做了难例挖掘hard nevigating mining：将所有的匹配不上的 负样本 按照分类 loss 进行排序，选择最高的 num_sel 个 prior box 序号集合作为最终的负样本集。这里就可以利用 num_sel 来控制最后正、负样本的比例在 1：3 左右。 网络结构：SSD采用VGG16作为基础模型，然后在VGG16的基础上新增了卷积层来获得更多的特征图以用于多尺度检测的。其中VGG16中的Conv4_3层将作为用于检测的第一个特征图，Conv4_3 得到的 feature map大小为38*38：38*38*4 = 5776，用它作为用于检测的第一个特征图，从后面新增的卷积层中提取Conv7，Conv8_2，Conv9_2，Conv10_2，Conv11_2作为检测所用的特征图，加上Conv4_3层，共提取了6个特征图，其大小分别是 38、19、10、5、3、1，越来越小。不同特征图单元cell设置的先验框数目不同，对于先验框的尺度，其遵守一个线性递增规则：随着特征图大小降低，先验框尺度线性增加。 最后得到8731个prior box边界框(可以认为 default box 是抽象类，而 prior box 是具体实例，这里用到的 default box 和 Faster RCNN中的 Anchor 很像)，采样量比较大，密集采用，因此在mAP上直接秒杀yolo，当然耗时也越大。prior box 与 ground truth box 匹配，匹配成功的将会作为正样本参与分类和回归训练，而未能匹配的则只会参加分类(负样本)训练。 Atrous Algorithm (Dilation Convolution 空洞卷积/膨胀卷积)：atrous algorithm可以在减小卷积步长的同时指数级扩大feature map的大小，即同等情况下，通过这个操作，我们可以获得一个更大的feature map，而实验表明，大的feature map会提升检测的性能。yolov3也使用了。使用扩张 率(dilation rate)参数，来表示扩张的大小，如下图所示，(a)是普通的 3×3 卷积，其视野为 3×3，(b)是扩张率为2，此时视野变成 7×7，(c)扩张率为4时，视野扩大为 15×15 ，但是视野的特征更稀疏了。 损失函数：由分类和回归两部分组成，回归部分的loss是希望预测的box和prior box的差距尽可能跟ground truth和prior box的差距接近，这样预测的box就能尽量和ground truth一样。总损失是置信度损失和位置损失的加权和。 总误差： 位置损失：采用Smooth L1 loss，下面四个式子是decode公式： 置信度误差：采用softmax loss： 数据扩增：为了使模型对各种输入目标大小和形状更鲁棒，每张训练图像都是通过以下选项之一进行随机采样： 直接使用整个原始输入图像。 采样一个patch（就是feature map 上裁下来一部分，使得与目标之间的最小Jaccard overlap重叠为0.1，0.3，0.5，0.7或0.9。 水平翻转：以0.5的概率进行水平翻转 光度失真： Some improvements on deep convolutional neural network based image classification中提出的 预测过程：对于每个预测框，首先根据类别置信度确定其类别(置信度最大的)与置信度值，并过滤掉属于背景的预测框。然后根据置信度阈值过滤掉阈值较低的预测框。对于留下的预测框进行解码，根据先验框得到其真实的位置参数 (解码后一般还需要做clip，防止预测框位置超出图片)。解码之后，一般需要根据置信度进行降序排列，然后仅保留top-k (如400) 个预测框。最后就是进行NMS，过滤掉重叠度较大的预测框。剩余的就是检测结果。 Reference[1] https://zhuanlan.zhihu.com/p/363345545 [2] https://zhuanlan.zhihu.com/p/27908027 [3] https://zhuanlan.zhihu.com/p/65472471 [4] https://zhuanlan.zhihu.com/p/66534632 [5] https://zhuanlan.zhihu.com/p/31561570 [6] https://zhuanlan.zhihu.com/p/41423739 [7] https://zhuanlan.zhihu.com/p/23006190 [8] https://zhuanlan.zhihu.com/p/33544892 [9] https://zhuanlan.zhihu.com/p/37850811 [10] https://zhuanlan.zhihu.com/p/32525231 [11] https://www.jianshu.com/p/7c6796e65b08","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"深度学习","slug":"深度学习","permalink":"https://maskros.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"SpringBoot学习杂记","slug":"note/springboot","date":"2022-04-14T18:37:28.000Z","updated":"2022-07-13T09:06:11.740Z","comments":true,"path":"/post/note/springboot.html","link":"","permalink":"https://maskros.top/post/note/springboot.html","excerpt":"SB杂记梳理javaSE: OOP mysql: 持久化 html + css + js + jquery + 框架: 视图 javaweb: MVC三层架构，原始 ssm: 框架：简化了我们的开发流程，配置较为复杂 war：tomcat运行 spring再简化：SpringBoot-jar: 内嵌tomcat 微服务架构 服务越来越多：SpringCloud","text":"SB杂记梳理javaSE: OOP mysql: 持久化 html + css + js + jquery + 框架: 视图 javaweb: MVC三层架构，原始 ssm: 框架：简化了我们的开发流程，配置较为复杂 war：tomcat运行 spring再简化：SpringBoot-jar: 内嵌tomcat 微服务架构 服务越来越多：SpringCloud SpringBoot： 是什么 配置如何编写 yaml *自动装配原理：重要：谈资 集成web开发：业务核心 集成 数据库 Druid 分布式开发：Dubbo (RPC) + zookeeper swagger：接口文档 任务调度 SpringSecurity：Shiro SpringCloud： 微服务 springcloud入门 Restful Eureka Ribbon Feign HyStrix Zuul 路由网关 SpringCloud config：git Spring &amp; SpringBootSpring Spring如何简化Java开发？ 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； SpringBoot 核心思想：约定大于配置 优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 微服务微服务是一种架构风格 高内聚 低耦合 架构：MVC MVVM 微服务架构 (服务分层) 业务： service : userservice ===&gt; 模块 springmvc, controller ==&gt; 接口 SpringBoot 配置项目创建使用 IDEA 直接创建项目：创建一个新项目，选择spring initalizr，默认就是去官网的快速构建工具那里实现，随后选择初始化的组件（初学勾选 Web 即可） 在Application同级目录下写项目包：Controller Pojo Dao Service… 将项目打包成jar：点击maven的package 彩蛋：更改启动时显示的字符拼成的字母(banner图案)，到项目下的 resources 目录下新建一个banner.txt 即可，图案可到 https://www.bootschool.net/ascii 生成。 运行原理 由于为快餐学习，故原理并不深究 JavaConfig @Configuration @Bean 配置和组件 关于SpringBoot，谈谈你的理解： 自动装配 (全面接管SpringMVC的配置) SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； run() 方法 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 yaml配置注入 配置文件：SpringBoot使用全局的配置文件，名称固定 application.properties： 语法：key=value application.yml：语法：key: 空格 value 修改SpringBoot自动配置的默认值 以数据作为中心，而非以标记语言为重点 xml vs yaml &lt;server&gt; &lt;port&gt;8081&lt;port&gt; &lt;/server&gt; server： port: 8080 语法 # 字面量 字符串默认不用加上引号 # 双引号不会转义字符串里的特殊字符 单引号会转义 key: value # 对象、Map(键值对) k: v1: v2: # 行内写法 student: {name: sb,age: 3} # 数组(List, set) 用 - 值表示数组中的一个元素 pets: - cat - dog - pig pets: [cat,dog,pig] # 修改默认端口号 server: port: 8082 # 占位符表达式 name: fuck${random.int} age: ${person.hello:hello} yaml文件更强大的地方在于，可以给实体类直接注入匹配值： 在resources目录下新建一个文件 application.yml 编写实体类(在pojo下) @Component //注册bean到容器中，可以被spring接收到 public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 } 使用yaml配置的方式进行注入 person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - girl - music dog: name: 旺财 age: 1 # 如果不使用yaml 则在实体类的属性上方写 @Value(\"xxx\")进行赋值 将person对象的所有值注入类中 @Component //注册bean @ConfigurationProperties(prefix = \"person\") public class Person {...} 随后可以通过ApplicationTests测试类进行测试，引用类时使用@AutowIred可以自动注入 加载指定的配置文件方法： @PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； ex: @PropertySource(value = “classpath: person.properties”) 松散绑定 JSR303数据校验需要在pom.xml中引入依赖spring-boot-starter-validation &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 在实体类前标注@Validated 进行数据校验 对需要校验的属性分别进行检查 @NotNull(message=\"名字不能为空\") private String userName; @Max(value=120,message=\"年龄最大不能查过120\") private int age; @Email(message=\"邮箱格式错误\") private String email; 空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included. 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则 多环境切换 可以通过激活不同的环境版本，实现快速切换环境； 目前暂时用不到，故略学 配置文件加载位置： 优先级1：项目路径下的config文件夹配置文件 flie:./config/ 优先级2：项目路径下配置文件 file:./ 优先级3：资源路径下的config文件夹配置文件 classpath:/config/ 优先级4：资源路径下配置文件 classpath:/ 自动装配原理 暂略 1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties: 封装配置文件中相关属性； SpringBoot Web开发要解决的问题： 导入静态资源 首页 jsp，模板引擎Thymeleaf 装配扩展SpringMVC 增删改查 拦截器 国际化(zh-cn/eng) 静态资源导入以下四个目录存放的静态资源可以被我们识别： \"classpath:/META-INF/resources/\" \"classpath:/resources/\" \"classpath:/static/\" (默认) \"classpath:/public/\" 自定义静态资源路径：可以在application.properties中配置 spring.resources.static-locations=classpath:/coding/,classpath:/kuang/ 一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效 首页定制：可以在/public/或者/static/目录下放置favicon.ico，即为网站首页图标 Thymeleaf模板引擎在pom.xml中引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 把html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染 在templates下面的页面只能通过Controller来跳转,不能使用@RestController注解 这里我在运行的时候出现了500错误，调了半天换了Maven版本为3.8.2后才成功运行，ee，或者clean一下maven缓存 Thymeleaf语法 查文档 https://www.thymeleaf.org/ // test @RequestMapping(\"/t2\") public String test2(Map&lt;String,Object&gt; map){ //存入数据 map.put(\"msg\",\"&lt;h1&gt;Hello&lt;/h1&gt;\"); map.put(\"users\", Arrays.asList(\"qinjiang\",\"kuangshen\")); //classpath:/templates/test.html return \"test\"; } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt; &lt;div th:text=\"${msg}\"&gt;&lt;/div&gt; &lt;!--不转义--&gt; &lt;div th:utext=\"${msg}\"&gt;&lt;/div&gt; &lt;!--遍历数据--&gt; &lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt; &lt;h4 th:each=\"user :${users}\" th:text=\"${user}\"&gt;&lt;/h4&gt; &lt;h4&gt; &lt;!--行内写法：官网#12--&gt; &lt;span th:each=\"user:${users}\"&gt;[[${user}]]&lt;/span&gt; &lt;/h4&gt; &lt;/body&gt; &lt;/html&gt; SpringMVC配置MVC配置原理 扩展SpringMVC 整合JDBC数据源com.zaxxer.hikari.HikariDataSource 方法都在JdbcTemplate中 // yml spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/sqlcourse?useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver 可以用测试类测试数据源： @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException { System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); } @RestController public class JDBCController { @Autowired JdbcTemplate jdbcTemplate; // 查询数据库的所有信息 // 没有实体类 数据库中的东西怎么获取？ Map @GetMapping(\"/stulist\") public List&lt;Map&lt;String, Object&gt;&gt; studentList() { String sql = \"select * from student\"; List&lt;Map&lt;String, Object&gt;&gt; list_maps = jdbcTemplate.queryForList(sql); return list_maps; } } 整合Druid Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控 添加依赖 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; 切换数据源(yml) spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/sqlcourse?useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源 切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项 spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/sqlcourse?useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源 #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 导入log4j的依赖 &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性； \\config\\DruidConfig.java 绑定、配置Druid数据源监控、配置 web 监控 filter过滤器 package com.example.demo.config; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; import com.alibaba.druid.support.http.WebStatFilter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; import java.util.Arrays; import java.util.HashMap; import java.util.Map; @Configuration public class DruidConfig { @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druidDataSource() { return new DruidDataSource(); } // 后台监控：web.xml, ServletRegistrationBean // 因为 SpringBoot 内置了 servlet容器，所以妹有web.xml, 替代方法：ServletRegistrationBean @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), \"/druid/*\"); // 后台需要有人登录，账号密码配置 HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;(); // 增加配置 initParameters.put(\"loginUsername\", \"admin\"); // 登录key 是固定的 loginUsername loginPassword initParameters.put(\"loginPassword\", \"123456\"); // 允许谁可以访问 initParameters.put(\"allow\", \"\"); // 禁止谁能访问 // initParameters.put(\"sb\", \"192.168.11.123\"); bean.setInitParameters(initParameters); // 设置初始化参数 return bean; } // filter @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\", \"*.js,*.css,/druid/*,/jdbc/*\"); bean.setInitParameters(initParams); //\"/*\" 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; } } 整合Mybatis导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 创建mapper目录以及对应的Mapper接口 @Mapper @Repository public interface ScMapper { List&lt;Sc&gt; queryAllSc(); Sc querySc(int Sno, int Cno); int addSc(Sc sc); int updateSc(Sc sc); int deleteSc(int Sno, int Cno); } 在resource目录下新建 /mybatis/mapper/ScMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.maskros.sql_course_sc.mapper.ScMapper\"&gt; &lt;select id=\"queryAllSc\" resultType=\"Sc\"&gt; select * from sc; &lt;/select&gt; &lt;select id=\"querySc\" resultType=\"Sc\" parameterType=\"int\"&gt; select * from sc where Cno = #{Cno} and Sno = #{Sno} ; &lt;/select&gt; &lt;insert id=\"addSc\" parameterType=\"Sc\"&gt; insert into sc values(#{Sno}, #{Cno}, #{Grade}); &lt;/insert&gt; &lt;update id=\"updateSc\" parameterType=\"Sc\"&gt; update sc set Cno = #{Cno}, Sno = #{Sno}, Grade = #{Grade} where Sno = #{Sno} and Cno = #{Cno}; &lt;/update&gt; &lt;delete id=\"deleteSc\" parameterType=\"int\"&gt; delete from sc where Cno = #{Cno} and Sno = #{Sno}; &lt;/delete&gt; &lt;/mapper&gt; 暂时寄了，TBC…","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"java","slug":"java","permalink":"https://maskros.top/tags/java/"},{"name":"springBoot","slug":"springBoot","permalink":"https://maskros.top/tags/springBoot/"}]},{"title":"字符串Hash 给我狠狠的哈希！","slug":"algorithm/learn/字符串Hash","date":"2022-04-13T10:55:00.000Z","updated":"2022-07-13T09:05:43.682Z","comments":true,"path":"/post/algorithm/learn/字符串Hash.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E5%AD%97%E7%AC%A6%E4%B8%B2Hash.html","excerpt":"字符串Hash本质：把每个不同的字符串转化成不同的整数 难点：如何构造一个合适的Hash函数 性质：Hash值不一样的两个字符串一定不一样，但Hash值一样的字符串不一定不一样 (但大概率一样) 单Hash 偷懒也可以 unsigned long long 自然溢出不用取mod，不过可能会被卡 要求： 和 均为质数，， 取尽量大 可任取131,233…","text":"字符串Hash本质：把每个不同的字符串转化成不同的整数 难点：如何构造一个合适的Hash函数 性质：Hash值不一样的两个字符串一定不一样，但Hash值一样的字符串不一定不一样 (但大概率一样) 单Hash 偷懒也可以 unsigned long long 自然溢出不用取mod，不过可能会被卡 要求： 和 均为质数，， 取尽量大 可任取131,233… 双Hash ※子串Hash若已知 的字符串的Hash值，, 子串 的Hash值就可以 O(1) 求解： 如果需要反复求解子串Hash值，预处理 效果更佳 素数选择上界和下界指的是离素数最近的 的值。 lwr uBr % err prime 2^5 2^6 10.416667 53 2^6 2^7 1.041667 97 2^7 2^8 0.520833 193 2^8 2^9 1.302083 389 2^9 2^10 0.130208 769 2^10 2^11 0.455729 1543 2^11 2^12 0.227865 3079 2^12 2^13 0.113932 6151 2^13 2^14 0.008138 12289 2^14 2^15 0.069173 24593 2^15 2^16 0.010173 49157 2^16 2^17 0.013224 98317 2^17 2^18 0.002543 196613 2^18 2^19 0.006358 393241 2^19 2^20 0.000127 786433 2^20 2^21 0.000318 1572869 2^21 2^22 0.000350 3145739 2^22 2^23 0.000207 6291469 2^23 2^24 0.000040 12582917 2^24 2^25 0.000075 25165843 2^25 2^26 0.000010 50331653 2^26 2^27 0.000023 100663319 2^27 2^28 0.000009 201326611 2^28 2^29 0.000001 402653189 2^29 2^30 0.000011 805306457 2^30 2^31 0.000000 1610612741 题单 0x00 P3370 【模板】字符串哈希 模板 0x01 P2957 谷仓里的回声 同上 0x02 P1381 单词背诵 尺取 尺取(双指针)： 对给定的一个序列，在序列中寻找包含全部需求的，长度最小的一段子序列 O(n) 初始化左右下标 l, r 到适当位置 不停向右移动r，直到 r 出界或者[l, r] 自区间已经满足要求 ans = min(ans, r - l + 1) 移动 l 到适当位置，重复第一个过程 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define int ll #define p 233 #define mod 1610612741 #define maxn 1000005 int Hash1[1000005], Hash2[1000005], Hashtmp[1000005]; int b[1000005]; void add(int Hash[], string s) { Hash[0] = 0; for (int i = 0; i &lt; s.size(); i++) { Hash[i + 1] = (Hash[i] * p + (s[i] - 'a')) % mod; } } void init() { b[0] = 1; for (int i = 1; i &lt;= 1e6; i++) { b[i] = b[i - 1] * p % mod; } } int getHash(int Hash[], int l, int r) { return ((Hash[r] - Hash[l - 1] * b[r - l + 1]) % mod + mod) % mod; } map&lt;ll, int&gt; words; map&lt;ll, bool&gt; vis; string ss[maxn]; int cnt[maxn]; signed main() { init(); int n; cin &gt;&gt; n; while (n--) { string s; cin &gt;&gt; s; add(Hash1, s); words[Hash1[s.size()]]++; } int m; cin &gt;&gt; m; int tot = 0; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; ss[i]; add(Hashtmp, ss[i]); Hash2[i] = Hashtmp[ss[i].size()]; if (words[Hash2[i]] &amp;&amp; !vis[Hash2[i]]) { vis[Hash2[i]] = 1; tot++; cnt[i] = tot; } else if (words[Hash2[i]]) { cnt[i] = tot; } else { cnt[i] = 0; } } cout &lt;&lt; tot &lt;&lt; '\\n'; if (!tot) cout &lt;&lt; 0; else { int l = 1, r = 1; map&lt;ll, int&gt; haved; int ans = maxn; int tmp = 0; for (int l = 1, r = 1; r &lt;= m; r++) { if (words[Hash2[r]]) { if (haved[Hash2[r]] == 0) { tmp++; } haved[Hash2[r]]++; } if (tmp &lt; tot) continue; while (haved[Hash2[l]] &gt; 1 || !words[Hash2[l]]) { if (haved[Hash2[l]] &gt; 1) haved[Hash2[l]]--; l++; } ans = min(ans, r - l + 1); } cout &lt;&lt; ans; } } 0x03 EOJ 3486 最大的子串 二分 + Hash 求后缀的最长公共前缀 0x04 [JSOI2016]扭动的回文串","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"hash","slug":"hash","permalink":"https://maskros.top/tags/hash/"}]},{"title":"Java Syntax in 算法竞赛","slug":"note/java syntax","date":"2022-04-06T17:07:28.000Z","updated":"2022-07-13T09:06:28.873Z","comments":true,"path":"/post/note/java syntax.html","link":"","permalink":"https://maskros.top/post/note/java%20syntax.html","excerpt":"Java Syntax for ACM 临阵磨枪 0x00 Headerimport java.util.*; import java.math.*; import java.io.*; public class Main&#123; public static void main(String[] args)&#123; // hot key : main &#125; &#125; 0x01 I/OScanner cin = new Scanner(System.in); Scanner cin = new Scanner(new BufferedInputStream(System.in)); // more fast // most fast // main 函数要 throw IOException 每次输入前 cin.nextToken() // 数字输入cin.nval 字符串cin.sval static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); // 注意 sval 如果字符串纯数字会返回为null 应提前转义 cin.ordinaryChars('0', '9') ; cin.wordChars('0', '9'); int n = cin.nextInt(); String s = cin.next(); double t = cin.nextDouble(); String s = cin.nextLine(); // 读一整行 char[] c = cin.next().toCharArray(); // 多行输入 while (cin.hasNextInt()) while (cin.hasNext()) while (cin.nextToken() != StreamTokenizer.TT_EOF) // 文件末尾 // 读入一行，分割字符串 String s = cin.nextLine(); String[] split = s.split(\" \"); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); // more fast out.printf(); out.flush(); // 在代码的最后out.flush() System.out.println(); //sout System.out.printf();","text":"Java Syntax for ACM 临阵磨枪 0x00 Headerimport java.util.*; import java.math.*; import java.io.*; public class Main&#123; public static void main(String[] args)&#123; // hot key : main &#125; &#125; 0x01 I/OScanner cin = new Scanner(System.in); Scanner cin = new Scanner(new BufferedInputStream(System.in)); // more fast // most fast // main 函数要 throw IOException 每次输入前 cin.nextToken() // 数字输入cin.nval 字符串cin.sval static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); // 注意 sval 如果字符串纯数字会返回为null 应提前转义 cin.ordinaryChars('0', '9') ; cin.wordChars('0', '9'); int n = cin.nextInt(); String s = cin.next(); double t = cin.nextDouble(); String s = cin.nextLine(); // 读一整行 char[] c = cin.next().toCharArray(); // 多行输入 while (cin.hasNextInt()) while (cin.hasNext()) while (cin.nextToken() != StreamTokenizer.TT_EOF) // 文件末尾 // 读入一行，分割字符串 String s = cin.nextLine(); String[] split = s.split(\" \"); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); // more fast out.printf(); out.flush(); // 在代码的最后out.flush() System.out.println(); //sout System.out.printf(); 0x02 Common API vs STL 三级标题括号内容即对应c++ STL内容 0. 进制转换String s = Integer.toString(a, x); //把int型数据转换乘X进制数并转换成string型 x ∈ [2, 36] int b = Integer.parseInt(s, x); //把字符串当作X进制数转换成int型 1. sort默认排序 (对基本类型如int char) Arrays.sort(int[] a, int fromIndex, int toIndex); // 默认排序 升序 实现Comparator接口自定义比较器 (要使用基本类型所对应的类：(Integer, Character) ) @Override public int compare(type x, type y) Arrays.sort(a, 1, n + 1, Collections.reverseOrder()); // 降序的简便写法 public class Main &#123; public static void main(String[] args) &#123; //注意，要想改变默认的排列顺序，不能使用基本类型（int,double,char）而要使用它们对应的类 Integer[] a = &#123;9, 8, 7, 2, 3, 4, 1, 0, 6, 5&#125;; //定义一个自定义类Mycmp的对象 Comparator cmp = new MyCmp(); Arrays.sort(a, cmp); &#125; &#125; // 放在Main类外面 // Comparator是一个接口，所以这里我们自己定义的类MyComparator要implents该接口 class Mycmp implements Comparator&lt;Integer>&#123; //返回值为负则x排在y前面，反之在后面，为0则表示相等 @Override public int compare(Integer x, Integer y) &#123; if (x &lt; y) return 1; if (x > y) return -1; return 0; &#125; &#125; 实现Comparable接口自定义类排序 @Override public int compareTo(classname x) class Point implements Comparable&lt;Point>&#123; int x,y; //自定义的比较函数，跟2的语法类似，此例中先x后y从小到大排序 @Override public int compareTo(Point o) &#123; return x!=o.x? x-o.x: y-o.y; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; //Java里的数组要先new数组，再new每个元素，不是数组有了每个元素也就有了 Point[] p = new Point[10]; //其实应该在Point里重载有参的构造函数，直接在new的时候初始化，这样代码简洁些 for (int i = 1; i &lt;= n; i++) &#123; p[i] = new Point(); //不把每个元素new出来直接进行下面的赋值会空指针的 p[i].x = cin.nextInt(); p[i].y = cin.nextInt(); &#125; Arrays.sort(p, 1, n + 1);//先x后y从小到大排序 &#125; &#125; 2. String/StringBuilderString 是 final 类型，每一次拼接，都会构建一个新的String对象， 相加除外，但是 + 操作比较耗时 String s; char[] c; s = s.toCharArray(); // 字符串转换为字符数组 s.charAt(idx); // 返回下标对应的字符 s.equals(str); // 比较 s.split(str); // 根据str分割s, 返回String数组 s.substring(i, j); // 截取子串 s.concat(str); // 在后面连接子串 s = s.replace('x', 'y'); // 将x全部替换为y s.indexOf('c'); // 查找第一次出现c的地方 s.lastIndexOf('c'); // 查找最后一次出现c的地方 s.startsWith(str); s.endsWith(str); // 是否以指定字符串开始和结束 s.trim(); // 去除首尾空格 StringBuilder 一般拼接时使用 StringBuilder sb = new StringBuilder(); sb.append(x); // 末尾添加，任意数据类型都可以，都转换成string sb.append(x).append(y).append(z); // 可链式写法 sb.reverse(); // 翻转字符串 String s = sb.toString(); // 转换成String StringBuilder sb = new StringBuilder(s); // String转换成sb sb.equals(sb2); String s = sb.substring(l, r); // 区间截取 [l, r) sb.delete(l, r); sb.replace(l, r, str); 3. HashMap/TreeMap (map)无序HashMap 对应 unordered_map HashMap&lt;Character, Integer> mp = new HashMap&lt;Character, Integer>(); mp.put(c, x); // 存 mp.get(x); // 取，key不存在则返回null mp.remove(c); // 删 mp.replace(c, x) // 改, key不存在则无事发生 // 用迭代器遍历 Iterator&lt;Entry&lt;Character, Integer> > it = mp.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Character, Integer> e = it.next(); System.out.println(e.getKey() + \" \" + e.getValue()); &#125; // 用for-each循环遍历 更便捷 // entry 使用 getKey() 和 getvalue() 方法来获得键值 for (Map.Entry&lt;Character, Integer> e : mp.entrySet()) &#123; System.out.println(e.getKey() + \" \" + e.getValue()); &#125; // 检查键值是否存在 返回boolean mp.containsKey(c); mp.containsValue(x); 有序Treemap - map // 基本操作同上，多了查找方法 TreeMap&lt;K, V> mp = new TreeMap&lt;K,V>(); // 返回K 或 Map.Entry&lt;K,V> mp.ceilingKey(K key); //第一个大于等于key mp.floorKey(K key); //第一个小于等于key mp.lowerKey(K, key); //第一个小于key mp.higherKey(K, key); //第一个大于key 4. ArrayList (vector)ArrayList&lt;Integer> v = new ArrayList&lt;Integer>(); // 二维 ArrayList[] v = new ArrayList[n + 1]; for (int i = 0; i &lt; n; i++) &#123; v[i] = new ArrayList&lt;Integer>(); &#125; v.add(1); // 增 v.remove(idx); // 删除 v.remove(Integer.valueOf(1)); // 删除值为1的元素 v.set(idx, 1); // 改 v.get(idx); // 查 5. ArrayDeque/PriorityQueue ((queue/stack/deque)/priority_queue)ArrayDeque ArrayDeque&lt;Integer> q = new ArrayDeque&lt;Integer>(); // 无论如何都可以Foreach遍历 for(Integer x : q) &#123;...&#125; // queue q.offer(x); // 入队 q.peek(); // 队头 q.pop(); // 出队，同时返回值 while (!q.isEmpty()) &#123; System.out.println(q.pop()); // 弹出的同时可以返回队头元素，不像c++是void的 &#125; // stack s.push(x); // 入栈 s.peek(); // 栈顶 s.pop(); // 弹出栈顶，同时返回值 // deque d.addFirst(x); d.addLast(x); // 入队 d.getFirst(); d.getLast(); // 队头队尾 d.removeFirst(); d.removeLast(); // 删 PriorityQueue // 默认从小到大 foreach遍历不报错 但乱序 PriorityQueue&lt;Integer> q = new PriorityQueue&lt;Integer>(); q.offer(x); // 增 q.peek(); //获得第一个元素 q.poll(); //获取并移除第一个 q.remove(x); //移除指定元素 // 自定义优先队列比较器：实现Comparator接口即可 class Mycmp implements Comparator&lt;Integer> &#123; @Override public int compare(Integer x, Integer y) &#123; return y - x; &#125; &#125; PriorityQueue&lt;Integer> q = new PriorityQueue&lt;Integer>(new Mycmp()); 6. HashSet/TreeSet (set)HashSet无序 TreeSet有序 以下用TreeSet演示 TreeSet&lt;Integer> s = new TreeSet&lt;Integer>(); s.add(x); s.contains(x); // 返回boolean是否存在 s.remove(x); s.ceiling(x); s.floor(x); s.higher(x); s.lower(x); s.headSet(x); // 小于x组成的set s.tailSet(x); // 大于x组成的set s.subset(x, false, y, true); // (x, y]组成的set // 遍历 Iterator&lt;Integer> it = s.iterator(); while(it.hasNext())&#123; // 遍历 int x = it.next(); // ... &#125; 7. BigInter/BigDemical大整数/高精度 (直接根据自动补全名称使用对应方法即可) 8. Math// 除基本的Math.max, min, abs, sqrt, pow外 Math.ceil(x); // 向上取整 Math.floor(x); // 向下取整 Math.round(x); // 四舍五入 Math.random(); // 生成[0, 1) 之间的double伪随机数 Math.cos(x); Math.acos(x); Math.sin(x); Math.asin(x); Math.tan(x); Math.atan(x); // 三角函数 Math.acos(-1) = pi; ok","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"java","slug":"java","permalink":"https://maskros.top/tags/java/"},{"name":"STL","slug":"STL","permalink":"https://maskros.top/tags/STL/"}]},{"title":"Use Eclipse as a Coding IDE","slug":"note/Eclipse","date":"2022-04-04T16:07:28.000Z","updated":"2022-04-06T16:58:09.881Z","comments":true,"path":"/post/note/Eclipse.html","link":"","permalink":"https://maskros.top/post/note/Eclipse.html","excerpt":"","text":"Eclipse for Lanqiao 不咋用Eclipse 为了参加蓝桥记录一下 Eclipse Config0x01 自动补全Window —&gt; Preferences —&gt; Java —&gt; Editor —&gt; Content Assist Auto activation triggers for Java : .qwertyuiopasdfghjklzxcvbnm Disable insertion triggers except ‘Enter’ [Y] // 表示只有回车时才触发自动补全 Project —&gt; Build Automatically 取消勾选 关闭自动编译 0x02 新建文件New —&gt; Java Project —&gt; input your project name —&gt; new package —&gt; new Class —&gt; input your Class name —&gt; public static void main(String[] args) [Y] 0x03 快捷键 Keys Features Alt+↑/↓ 将当前行内容往上/下移动 Ctrl+shift+F 格式化 Ctrl+D 删除当前行 Alt+/ 代码助手 Ctrl+/ 注释 Ctrl+F11 运行 Ctrl+Alt+↑/↓ 复制当前行","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"}]},{"title":"数位dp专题训练","slug":"algorithm/exercise/数位dp_problem","date":"2022-03-23T12:30:00.000Z","updated":"2022-03-24T03:57:11.955Z","comments":true,"path":"/post/algorithm/exercise/数位dp_problem.html","link":"","permalink":"https://maskros.top/post/algorithm/exercise/%E6%95%B0%E4%BD%8Ddp_problem.html","excerpt":"","text":"数位dp专题训练猛练！ 0x00 Digit link 洛谷板子题 题意：定义一个正整数的价值是把这个数的十进制写出来之后，最长的等差子串的长度。求 范围内数字价值的总和。 /* 定义一个正整数的价值是把这个数的十进制写出来之后，最长的等差子串的长度。 求[l,r]范围内数字价值的总和。 */ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int T, n, m, len, a[20]; ll l, r, dp[20][15][25][25][20]; ll dfs(int pos, int pre, ll st, ll sum, int d, int lead, int limit) //pos搜到的位置 //pre前一位数 //st当前公差最大差值 //sum整个数字的最大价值 //d共差 //lead判断是否有前导0 //limit判断是否有最高位限制 { if (pos &gt; len) return sum; //dp结束 //记录状态（计划搜索） //注意d有负数，最小可以到-9，所以记录时数组下标是d+10 if ((dp[pos][pre][st][sum][d + 10] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre][st][sum][d + 10]; ll ret = 0; int res = limit ? a[len - pos + 1] : 9; //最高位最大值 for (int i = 0; i &lt;= res; i++) { //有前导0且这位也是前导0，一切不变只有位数变化 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 0, -38, 1, limit &amp;&amp; (i == res)); //有前导0但这位不是前导0（这位是数字的最高位）开始有前一位，一个数形成等差数列 else if (i &amp;&amp; lead) ret += dfs(pos + 1, i, 1, 1, -38, 0, limit &amp;&amp; (i == res)); //之前刚搜到1位还没有共差，两位数形成等差数列，记录共差 else if (d &lt; -9) ret += dfs(pos + 1, i, 2ll, 2ll, i - pre, 0, limit &amp;&amp; (i == res)); //搜到2位以后，共差若与前两位相同当前等差数列长度增加，若公差变化则更新整个数字的最大价值，等差数列长度又变为2 else if (d &gt;= -9) ret += dfs(pos + 1, i, (i - pre == d) ? st + 1 : 2, max(sum, (i - pre == d) ? st + 1 : 2), (i - pre == d) ? d : i - pre, 0, limit &amp;&amp; (i == res)); } //没有前导0和最高限制时可以直接记录当前dp值以便下次搜到同样的情况可以直接使用。 return (!limit &amp;&amp; !lead) ? dp[pos][pre][st][sum][d + 10] = ret : ret; } ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof(dp)); return dfs(1, 0, 0, 0, -38, 1, 1); //-38是随便赋的其实赋成-10就行了…… } int main() { cin &gt;&gt; T; while (T--) { cin &gt;&gt; l &gt;&gt; r; //l是0的时候要特别注意！ if(l) cout &lt;&lt; (part(r) - part(l - 1)) &lt;&lt; '\\n'; else cout &lt;&lt; part(r) - part(l) + 1 &lt;&lt; '\\n'; } return 0; } 0x01 HDU2089 不要62 link 题意： 入门题，统计区间内不含4或62的数字个数 int a[10], len; ll l, r; ll dp[15][15]; ll dfs(int pos, int pre, int lead, int limit) { if (pos &gt; len) return 1; //剪枝 if ((dp[pos][pre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { if (i == 4) continue; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 else { if (i == 2 &amp;&amp; pre == 6) continue; ret += dfs(pos + 1, i, 0, i == res &amp;&amp; limit); } } if (!limit &amp;&amp; !lead) dp[pos][pre] = ret; //当前状态方案数记录 return ret; } //把数按位拆分 ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 1, 1); //进入记搜 } int main() { while(cin &gt;&gt; l &gt;&gt; r) { if(!l &amp;&amp; !r) break; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; } } 0x02 数位小孩 link 题意： 给定区间，统计区间中有多少个数同时满足：每相邻两个数位和为素数，其中至少一个数位为1，且没有前导0 int a[20], len; ll l, r; bool prime[25]; ll dp[20][20]; ll dfs(int pos, int pre, bool one, int lead, int limit) //记搜 { if (pos &gt; len) if (one) return 1; else return 0; //剪枝 if ((dp[pos][pre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead) &amp;&amp; one)) return dp[pos][pre]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { bool nextone = one; if (i == 1 || pre == 1) nextone = 1; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 if (i &amp;&amp; lead) ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); // else else { if (!prime[i + pre]) continue; ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); } } if (!limit &amp;&amp; !lead &amp;&amp; one) dp[pos][pre] = ret; //当前状态方案数记录 return ret; } //把数按位拆分 ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 0, 1, 1); //进入记搜 } void pr(int x) { prime[x] = 1; } void init() { pr(2), pr(3), pr(5), pr(7), pr(11), pr(13), pr(17), pr(19); } int main() { init(); cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; } 0x03 AT4540 Digit Sum link 题意： 区间 ​ 内有多少个数，使得十进制表示的数字之和是 D 的倍数？ 答案对 1e9 + 7 取模，K &lt; 1e10000. D &lt; 1e2 题解：只需维护前缀和num即可，pre都用不到，注意输入数字较大，爆longlong要用string翻转处理，(开始没翻转过来wa了半天…) int a[maxn], len; ll l, r, D; ll dp[maxn][115]; ll dfs(int pos, int num, int lead, int limit) { if (pos &gt; len) return num == 0; //剪枝 if ((dp[pos][num] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][num] % mod; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { int num_ = (num + i) % D; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret = (ret + dfs(pos + 1, num_, 1, i == res &amp;&amp; limit) % mod) % mod; //有前导0但当前位不是前导0，当前位就是最高位 else if (i &amp;&amp; lead) ret = (ret + dfs(pos + 1, num_, 0, i == res &amp;&amp; limit) % mod) % mod; else { ret = (ret + dfs(pos + 1, num_, 0, i == res &amp;&amp; limit) % mod) % mod; } } if (!limit &amp;&amp; !lead) dp[pos][num] = ret % mod; //当前状态方案数记录 return ret % mod; } ll part(string x) { len = x.size(); // reverse for (int i = 0; i &lt; x.size(); i++) { a[len - i] = x[i] - '0'; } memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 1, 1); //进入记搜 } int main() { string s; cin &gt;&gt; s; cin &gt;&gt; D; cout &lt;&lt; (part(s) - part(\"0\") + mod) % mod &lt;&lt; '\\n'; } 0x04 SAC#1 - 萌数 link 题意： 只有满足“存在长度至少为2的回文子串”的数是萌的，求区间内萌数的个数。 题解： 正难则反，当一个数的任意一位都不和前两位的数字相同时，这个数就不含回文串 故dp[pos][pre][ppre]，pre表示上一位，ppre表示上二位的数字。 但是由于输入范围超过ll，所以需读入string，并且用总长度减去dp求得的方案数。 在这里没有更加简洁优化自己的代码，写了个丑陋的大数减法，虽然AC了但是待优化、、 优化细节： 由于答案是 sum[r] - sum[l - 1] 那么对于 ：需要写高精度减法吗？ 不用。直接求sum[r] 和 sum[l] 然后特判一下 这个左边界是否合法就行。 由于正难则反，取补集，需要使用 再减去答案，需要写高精度吗？ 不用。直接对 和 取模然后相减，得出的结果与 一致。 string l, r; int len, a[maxn]; int dp[maxn][15][15]; // pos pre ppre ll dfs(int pos, int pre, int ppre, int lead, int limit) { if (pos &gt; len) return 1; //剪枝 if ((dp[pos][pre][ppre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre][ppre] % mod; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { if ((!i) &amp;&amp; lead) ret = (ret + dfs(pos + 1, 0, -1, 1, i == res &amp;&amp; limit) % mod) % mod; else if (i &amp;&amp; lead) ret = (ret + dfs(pos + 1, i, -1, 0, i == res &amp;&amp; limit) % mod) % mod; else { if (pre == ppre || i == pre || i == ppre) continue; ret = (ret + dfs(pos + 1, i, pre, 0, i == res &amp;&amp; limit) % mod) % mod; } } if (!limit &amp;&amp; !lead) dp[pos][pre][ppre] = ret % mod; //当前状态方案数记录 return ret % mod; } ll part(string x, bool flag) { len = x.size(); rep(i, 0, len) { a[len - i] = x[i] - '0'; } if(flag) { if(len == 1 &amp;&amp; a[1] == 0) { a[1] = 0; } else { int idx = 1; while (idx &lt;= len) { if(a[idx] &gt; 0) { a[idx]--; break; } else a[idx] = 9, idx++; } } } memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, -1, 1, 1); //进入记搜 } // y - x + 1 int ret[maxn]; ll calc(string x, string y) { int lead = 1; int leny = y.size(), lenx = x.size(); if(lenx == 1 &amp;&amp; x[0] == '0') lead = 0; rep(i, 1, lenx + 1) { int tmp = y[leny - i] - '0' - (x[lenx - i] - '0') + lead; if(tmp &gt;= 10) { lead = 1; tmp = tmp % 10; } else if(tmp &lt; 0) { lead = -1; tmp = tmp + 10; } else lead = 0; ret[i] = tmp; } rep(i, lenx + 1, leny + 1) { int tmp = y[leny - i] - '0' + lead; if(tmp &gt;= 10) { lead = 1; tmp = tmp % 10; } else if(tmp &lt; 0) { lead = -1; tmp = tmp + 10; } ret[i] = tmp; } ll ans = 0; red(i, leny + 1, 1) { ans = (ans * 10 % mod + ret[i]) % mod; } return ans; } signed main() { cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; (calc(l, r) - (part(r, 0) - part(l, 1) + mod) % mod + mod) % mod &lt;&lt; '\\n'; } 0x05 [ZJOI2010]数字计数 link 题意：给定区间，统计区间内每个数各位数字出现的次数 思路：对0~9每个数字单独记搜 #define int ll ll l, r; int len, a[20]; int dp[20][20]; // pos int num = 0; ll dfs(int pos, int cnt, int lead, int limit) { if (pos &gt; len) return cnt;//剪枝 if ((dp[pos][cnt] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][cnt]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { // ret += dfs(pos + 1, cnt + ((i == num) &amp;&amp; (i || !lead)), lead &amp;&amp; (i == 0), i == res &amp;&amp; limit); int cnt_ = (i == num) ? cnt + 1 : cnt; if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 1, i == res &amp;&amp; limit); else if (i &amp;&amp; lead) ret += dfs(pos + 1, cnt_, 0, i == res &amp;&amp; limit); else ret += dfs(pos + 1, cnt_, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][cnt] = ret; //当前状态方案数记录 return ret; } ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 1, 1); //进入记搜 } signed main() { cin &gt;&gt; l &gt;&gt; r; while(num &lt;= 9) cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; ' ', num++; } 0x06 [AHOI2009] 同类分布 link 题意：统计区间内每个数各位数字之和能整除原数的数的个数，l, r &lt; 1e18 思路：模数就是各位数字之和。所以我们可以先确定这个值再搜。可以枚举各位数字之和。那么最坏的情况就是10^18-1，各位数字和为17 * 9=153，所以我们枚举153次即可。 dp数组维护各位数字之和d, 以及数字对mod取模的值sum即可，剪枝条件为 d == mod &amp;&amp; sum == 0 #define int ll ll l, r; int len, a[25]; int dp[25][180][180]; // pos sum d int mod; ll dfs(int pos, int sum, int d, int lead, int limit) { if (pos &gt; len) return d == mod &amp;&amp; sum == 0;//剪枝 if ((dp[pos][sum][d] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][sum][d]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { if(d + i &gt; mod) break; if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 1, i == res &amp;&amp; limit); else if (i &amp;&amp; lead) ret += dfs(pos + 1, i % mod, i, 0, i == res &amp;&amp; limit); else ret += dfs(pos + 1, (sum * 10 + i) % mod, d + i, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][sum][d] = ret; //当前状态方案数记录 return ret; } ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; ll ans = 0; rep(i, 1, 9 * len + 1) { memset(dp, -1, sizeof dp); mod = i; ans += dfs(1, 0, 0, 1, 1); } return ans; } signed main() { cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)); } 0x07 P4317 花神的数论题 link 题意： 表示 的二进制中 的个数，给定 , 求从 到 , 的乘积。对 1e7 + 7 取模，N &lt; 1e15 思路： 将 按照二进制存储，根据范围1e15可知，一个数的二进制有50位1，于是我们枚举1的个数，dp[pos][cnt] 维护1的个数cnt，剪枝时cnt=枚举个数即可返回计数。对枚举的每种情况进行计数用ksm乘即可。 ll qpow(ll a, ll b) { ll ans = 1; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; } return ans; } ll l, r; int len, a[70], tmp; int dp[70][70]; // pos cnt ll dfs(int pos, int cnt, int lead, int limit) { if (pos &gt; len) return cnt == tmp; if ((dp[pos][cnt] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][cnt]; ll ret = 0; int res = limit ? a[len - pos + 1] : 1; for (int i = 0; i &lt;= res; i++) { if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 1, i == res &amp;&amp; limit); else if (i &amp;&amp; lead) ret += dfs(pos + 1, i == 1, 0, i == res &amp;&amp; limit); else ret += dfs(pos + 1, (i == 1) + cnt, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][cnt] = ret; return ret; } ll part(ll x) { len = 0; while (x) a[++len] = x &amp; 1 ? 1 : 0, x /= 2; ll ans = 1; rep(i, 1, 70) { tmp = i; memset(dp, -1, sizeof dp); int fuck = dfs(1, 0, 1, 1); ans = ans * qpow(i, fuck) % mod; } return ans; } signed main() { cin &gt;&gt; r; cout &lt;&lt; part(r); }","categories":[{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"https://maskros.top/tags/dfs/"}]},{"title":"数位dp","slug":"algorithm/learn/数位dp","date":"2022-03-17T15:00:00.000Z","updated":"2022-07-13T09:05:23.671Z","comments":true,"path":"/post/algorithm/learn/数位dp.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E6%95%B0%E4%BD%8Ddp.html","excerpt":"数位dp数位dp是在范围内按位递推出最大值的快捷算法，由于是按位dp，所以数的大小对复杂度影响很小 ref: blog in luogu 导 经典题面： 求出一段区间 中，满足某一特殊条件的数有多少个，条件一般与数的大小无关而与数字的组成有关 数位dp较普通dp比较冷门，但是不会写就只能暴力骗分 = = 注：L, R 巨大爆longlong时要用字符串处理 注：由于搜索的速度很快，所以可以根据题意考虑枚举每种情况后分别进行记搜计数，最后再汇总。","text":"数位dp数位dp是在范围内按位递推出最大值的快捷算法，由于是按位dp，所以数的大小对复杂度影响很小 ref: blog in luogu 导 经典题面： 求出一段区间 中，满足某一特殊条件的数有多少个，条件一般与数的大小无关而与数字的组成有关 数位dp较普通dp比较冷门，但是不会写就只能暴力骗分 = = 注：L, R 巨大爆longlong时要用字符串处理 注：由于搜索的速度很快，所以可以根据题意考虑枚举每种情况后分别进行记搜计数，最后再汇总。 基本原理 通过记忆化搜索来实现动态规划，相比正面递推在大多数情况下更简洁。 0X01 记忆化搜索从起点向下搜索，到最底层得到方案数，一层一层向上返回答案累加，最终从搜索起点得到最终答案。 对于区间 , 一般转化成两次数位dp，即找 和 两段，结果相减即可。 0x02 状态设计 考虑在哪一层，判断当前的状态 数位dp的状态能记录的最好都记录上 dfs()函数的一些参量： 数字位数 , 记录答案的 , 最高位限制 判断前导0的标记 由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系，所以一般在 dfs() 中也要记录前一位或前几位数 ​ 参量解释： 前导0标记 有的时候前导0不需要判断，根据题意即可 由于我们要搜的数可能很长，所以我们的直接最高位搜起 举个例子：假如我们要从找任意相邻两数相等的数 显然等等是符合题意的数 但是我们发现右端点是四位数 因此我们搜索的起点是，而三位数的记录都是等等 而这种情况下如果我们直接找相邻位相等则符合题意而都不符合题意了 所以我们要加一个前导0标记： 当前位 = 1 且当前位置为0，那么当前位置也是前导0，使 + 1 继续搜 当前位 = 1 但当前位不是0，那么本位为当前数字的最高位， + 1 继续搜 最高位标记 我们知道在搜索的数位搜索范围可能发生变化； 举个例子：我们在搜索 的数时，显然最高位搜索范围是 ~ ，而后面的位数的取值范围会根据上一位发生变化：当最高位是 ~ 时，第二位取值为 ; 当最高位是 时，第二位取值为 （再往上取就超出右端点范围了） 为了分清这两种情况，我们引入了 标记： 当前位 = 1 而且已经取到了能取到的最高位时，下一位 = 1； 当前位 = 1 但是没有取到能取到的最高位时，下一位 = 0； 当前位 = 0 则下一位也为0。 我们设这一位的标记为 ，这一位能取到的最大值为 ，则下一位的标记就是i == res &amp;&amp; limit ( ​ 枚举这一位填的数) 0x03 dp数位dp在记忆化搜索的框架下进行，每找到一种情况我们就将这种情况记录下来，等到后面搜到相同情况时直接使用当前记录的值即可。 dp数组的下标：表示一种状态。只要当前状态和之前搜过的某个状态完全一样，就可以直接返回原来已经记录下的dp值。 重要的例子： 区间： 搜到 时，dfs从下返回上来的数值就是 当前位是第5位，前一位是0的方案数，搜完之后记录方案数字。 当搜到 时，就发现当前状态一样是 搜到第5位，且前一位是0，与之前记录情况完全相同，所以就不用向下搜，直接返回上次dp值即可。 如果搜到 ，不能直接返回当前位是第5位，前一位是4的dp值。 因为这个状态的dp值被记录时，当前位也就是第5位的取值是 ，而这次当前位的取值是​，方案数一定比之前记录的dp值要小。当前 = 1, 最高位有取值的限制。 结论： 当 = 1时，不能记录和取用dp值，同理 = 1 时也不行。 板子ll dfs(int pos, int pre, int st, ……, int lead, int limit) //记搜 { if (pos &gt; len) return st; //剪枝 if ((dp[pos][pre][st]……[……] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre][st]……[……]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, ……, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 else if (i &amp;&amp; lead) ret += dfs(pos + 1, i, ……, 0, i == res &amp;&amp; limit); else if (根据题意而定的判断) ret += dfs(……, ……, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][pre][st]……[……] = ret; //当前状态方案数记录 return ret; } ll part(ll x)//把数按位拆分 { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, ……, ……, 1, 1); //进入记搜 } int main() { cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; return 0; } 题单solution 0x00 Digit link 0x01 HDU2089 不要62 link 0x02 数位小孩 link 0x03 AT4540 Digit Sum link 0x04 SAC#1 - 萌数 link 0x05 [ZJOI2010]数字计数 link 0x06 [AHOI2009] 同类分布 link 0x07 P4317 花神的数论题 link","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"2022牛客寒假算法基础集训营5","slug":"nowcoder/2022winter/round5","date":"2022-03-16T15:30:50.000Z","updated":"2022-03-24T06:42:24.884Z","comments":true,"path":"/post/nowcoder/2022winter/round5.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round5.html","excerpt":"","text":"2022牛客寒假算法基础集训营5 补一下打的最烂的一场 A 疫苗小孩 (二分) 题意： 给定长为 n 的01串，0表示可以打疫苗，最多可以打三针，每两针相差k天时可以贡献w，每多相差x天或者少相差x天，贡献都会减少为 w-q*x，问最大贡献是多少 思路： 可以发现1针和0针的贡献都为0，所以直接考虑2针及以上的情况枚举第二针所在的位置pos，二分找到离 pos+k 和 pos-k 最近的两个点计算最大贡献即可 使用 lower_bound 函数， 复杂度 #define int ll int a[maxn]; void solve() { int n; cin &gt;&gt; n; int cnt = 0; rep(i, 1, n + 1) { char t; cin &gt;&gt; t; if(t == '0') a[++cnt] = i; } int k, w, q; cin &gt;&gt; k &gt;&gt; w &gt;&gt; q; int ans = 0; rep(i, 2, cnt + 1) { // first &gt;= int pos1 = lower_bound(a + 1, a + cnt + 1, a[i] - k) - a; int pos2 = lower_bound(a + 1, a + cnt + 1, a[i] + k) - a; int mn1 = min(abs(a[i] - k - a[pos1]), abs(a[i] - k - a[max(1ll, pos1 - 1)])); int mn2 = min(abs(a[i] + k - a[pos2]), abs(a[i] + k - a[max(1ll, pos2 - 1)])); int tmp1 = max(0ll, w - q * mn1), tmp2 = max(0ll, w - q * mn2); if(i == cnt) tmp2 = 0; ans = max(ans, tmp1 + tmp2); } cout &lt;&lt; ans; } *C 战旗小孩 (二进制枚举) 题意： n, k, s 表示游戏局数，可以获得额外机会的次数和起始分数，随后一行 n 个数 pi 为每一局结束后的一个特定分数，如果该局结束后分数大于等于该特定分数，就高兴一次，pi 顺序不能改变。接下来 n 行为每局结束后分数的变化delta和如果是用额外机会分数的变化delta。可以变换 n 局游戏的顺序，问最多能高兴几次。 0= &lt; k &lt; n &lt;= 20 思路： 由于 n 很小，采用二进制枚举，1的个数为使用额外机会的次数，处理一下每局可能获得的最大值，每次选择最大值计算即可。 __builtin_popcount(n) 表示 n 内二进制位为1的个数 int n, k, s; int p[maxn], v[maxn], w[maxn]; int h[maxn]; int cal(int x) { rep(i, 0, n) { if((x &gt;&gt; i) &amp; 1) h[i + 1] = w[i + 1]; else h[i + 1] = v[i + 1]; } sort(h + 1, h + n + 1, greater&lt;int&gt;() ); int tmp = s; int ret = 0; rep(i, 1, n + 1) { tmp += h[i]; if(tmp &gt;= p[i]) ret++; } return ret; } void solve() { cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; int ans = 0; rep(i, 1, n + 1) cin &gt;&gt; p[i]; rep(i, 1, n + 1) { int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; v[i] = max(a, b); w[i] = max({v[i], c, d}); } int mx = 1 &lt;&lt; n; rep(i, 0, mx) { if (__builtin_popcount(i) == k) ans = max(ans, cal(i)); } cout &lt;&lt; ans; } D 数位小孩 (数位dp) 题意： 给定区间，统计区间中有多少个数同时满足：每相邻两个数位和为素数，其中至少一个数位为1，且没有前导0 思路： 套数位dp板子即可 int a[20], len; ll l, r; bool prime[25]; ll dp[20][20]; ll dfs(int pos, int pre, bool one, int lead, int limit) //记搜 { if (pos &gt; len) if (one) return 1; else return 0; //剪枝 if ((dp[pos][pre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead) &amp;&amp; one)) return dp[pos][pre]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { bool nextone = one; if (i == 1 || pre == 1) nextone = 1; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 if (i &amp;&amp; lead) ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); // else else { if (!prime[i + pre]) continue; ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); } } if (!limit &amp;&amp; !lead &amp;&amp; one) dp[pos][pre] = ret; //当前状态方案数记录 return ret; } //把数按位拆分 ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 0, 1, 1); //进入记搜 } void pr(int x) { prime[x] = 1; } void init() { pr(2), pr(3), pr(5), pr(7), pr(11), pr(13), pr(17), pr(19); } int main() { init(); cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; } G 163小孩 排列组合 int ans = C(13, 2) * 2 + C(13, 3) * 3 + C(13, 2) + C(13, 3) * 6 + C(13, 4) * 4 + C(13, 3) + C(13, 4) * C(4, 2) + C(13, 5) * 5 + C(13, 6); I 兔崽小孩 (前缀和/二分) 题意： n条说说，q次询问，每条说说有固定的发送时间t，每次询问k, p; k表示入睡时间，p表示要求的总睡眠时间，如果最后总睡眠时间小于p则输出NO， 否则YES 思路： 对时间差值排序，维护前缀和，对每次询问二分查找到大于k的下标，利用前缀和数组区间求和进行计算即可。 int t[maxn]; int a[maxn], pre[maxn]; void solve() { int n, q; cin &gt;&gt; n &gt;&gt; q; int len = 0; rep(i, 0, n) { cin &gt;&gt; t[i]; if (i) a[++len] = t[i] - t[i - 1]; } sort(a + 1, a + len + 1, greater&lt;int&gt;()); pre[1] = a[1]; rep(i, 2, len + 1) { pre[i] = pre[i - 1] + a[i]; } rep(i, 0, q) { int k, p; cin &gt;&gt; k &gt;&gt; p; int idx = lower_bound(a + 1, a + 1 + len, k, greater&lt;int&gt;()) - a; int tmp = pre[idx - 1] - (idx - 1) * k; tmp &gt;= p ? puts(\"Yes\") : puts(\"No\"); } } J 三国小孩沙比题，略了","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"https://maskros.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"}]},{"title":"Codeforce Edu 124 & Round 777 Problem D","slug":"codeforces/cf Edu 124 & 777 D","date":"2022-03-13T13:20:00.000Z","updated":"2022-03-14T15:04:58.363Z","comments":true,"path":"/post/codeforces/cf Edu 124 & 777 D.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20124%20&%20777%20D.html","excerpt":"","text":"Codeforce Edu 124 &amp; Round 777 Problem DEdu 124 D Nearest_Excluded_Points (BFS) 题意： 给定 个点的坐标，对于每个点，打印哈密顿距离最近且不包含在该 个点中的点的坐标。 思路： 从外往里bfs。如果一个点没被围死，那么总有一个相邻的点为答案，被围死了则外围的点也有答案。 首先，我们可以为所有与至少一个不属于这个集合的点相邻的点找到答案。这些点的距离显然是1（这是我们能得到的最小的答案）。在下一次迭代中，我们可以为所有与找到答案的点相邻的点设定答案（因为它们没有不属于集合的邻居，所以它们的距离至少是2）。哪一个点并不重要，所以如果点i与答案为1的点j相邻，我们可以将点i的答案设置为点j的答案。就代码而言，这可以通过广度优先搜索（BFS）来完成。换句话说，我们为距离为1的点设置答案，然后将这些答案按距离增加的顺序推给所有相邻的点，直到我们找到所有答案。 int n; int dx[] = {0, 0, -1, 1}; int dy[] = {-1, 1, 0, 0}; void solve() { cin &gt;&gt; n; vector&lt;pii&gt; v; rep(i, 0, n) { int x, y; cin &gt;&gt; x &gt;&gt; y; v.pb({x, y}); } set&lt;pii&gt; st(v.begin(), v.end()); map&lt;pii, pii&gt; ans; queue&lt;pii&gt; q; for(auto [x, y] : v) { rep(i, 0, 4) { int nx = x + dx[i], ny = y + dy[i]; if(st.count({nx, ny})) continue; ans[{x, y}] = {nx, ny}; q.push({x, y}); break; } } while(!q.empty()) { auto it = q.front(); int x = it.fst, y = it.sec; q.pop(); rep(i, 0, 4) { int nx = x + dx[i], ny = y + dy[i]; if(!st.count({nx, ny}) || ans.count({nx, ny})) continue; ans[{nx, ny}] = ans[{x, y}]; q.push({nx, ny}); } } for(auto [x, y] : v) { auto it = ans[{x, y}]; cout &lt;&lt; it.fst &lt;&lt; \" \" &lt;&lt; it.sec &lt;&lt; '\\n'; } } cf 777 D Madoka_and_the_Best_School_in_Russia 题意： 给定 , , 判断是否至少有两种方法可以把 任意拆成 (1 ~ n)个数，使得拆出来的每个数都可以整除 ，但不能整除 (n &gt;= 2) ，能则输出YES，否则输出NO 思路： 分类讨论： ① 如果 x 不能整除 d*d ，则铁定为NO 对 x 不断除 d，共分解成 div 个 d (div &gt;= 2) 和剩余的因子 x ② 如果 x 不为质数，则至少有两种分解方式，一定能凑出两种情况，为YES ③ 如果 x 为质数，且 d 被唯一分解为 x * x，当且仅当 div = 3 时，为NO ④ 如果 x 为质数，d 不为质数且 div &gt; 2，为YES ⑤ 其余情况为NO int prime(int x) { for (int i = 2; i &lt;= sqrt(x); i++) { if(x % i == 0) return i; } return -1; } void solve() { int x, d; cin &gt;&gt; x &gt;&gt; d; int dd = d * d; if(x % dd != 0) { puts(\"NO\"); return; } int div = 0; while(x % d == 0) x /= d, div++; if(prime(x) != -1) { puts(\"YES\"); return; } if(prime(d) != -1 &amp;&amp; d == prime(d) * prime(d)) { if(x == prime(d) &amp;&amp; div == 3) { puts(\"NO\"); return; } } if(div &gt; 2 &amp;&amp; prime(d) != -1) { puts(\"YES\"); return; } puts(\"NO\"); }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"bfs","slug":"bfs","permalink":"https://maskros.top/tags/bfs/"},{"name":"讨论","slug":"讨论","permalink":"https://maskros.top/tags/%E8%AE%A8%E8%AE%BA/"}]},{"title":"CSP202109-2 非零段划分","slug":"probs/CSP非零段划分","date":"2022-03-01T14:30:50.000Z","updated":"2022-03-01T15:41:17.264Z","comments":true,"path":"/post/probs/CSP非零段划分.html","link":"","permalink":"https://maskros.top/post/probs/CSP%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86.html","excerpt":"","text":"CSP 202109-2 非零段划分 (差分) link 赛时没想明白，写了个暴力70分，一直惦记着这个题，故在此重做 题面A1,A2,⋯,An 是一个由 n 个自然数（非负整数）组成的数组。我们称其中 Ai,⋯,Aj 是一个非零段，当且仅当以下条件同时满足： 1≤i≤j≤n； 对于任意的整数 k，若 i≤k≤j，则 Ak&gt;0； i=1 或 Ai−1=0； j=n 或 Aj+1=0。 下面展示了几个简单的例子： A=[3,1,2,0,0,2,0,4,5,0,2] 中的 4 个非零段依次为 [3,1,2]、[2]、[4,5] 和 [2]； A=[2,3,1,4,5] 仅有 1 个非零段； A=[0,0,0] 则不含非零段（即非零段个数为 0）。 现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，可取 p=1，即不对 A 做任何修改。 规定： 全部的测试数据满足 n≤5e5，且数组 A 中的每一个数均不超过 1e4 题解非零段可以理解为孤立的岛屿，不同的岛屿之间用 0 分隔开。选择一个正整数 p ，将所有小于 p 的数都变为 0 ，可以理解为海平面上涨到 p 的位置，p 以下的部分都被淹没，求孤立岛屿数最大是多少。可以先考虑 p = 10001 的情况：所有数字都被海水淹没了，显然只有 0 00 个岛屿。然后海平面逐渐下降，观察岛屿数量的变化。可以看出：每当一个凸峰出现，岛屿数就多了一个；而每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连接在了一起，岛屿数减少一个。凸峰点和凹谷点的判断需要注意平面（如 1 2 2 1 ）的存在：若连续一段数字相同，可以把他们合并成一个点（1 2 1），这样对答案不会产生影响，可以使用 std::unique() 函数来去掉相邻重复元素。 🐴vector&lt;int&gt; v; int high[100005], low[100005], cnt[100005]; void solve(){ int n; cin &gt;&gt; n; v.pb(0); rep(i, 0, n) { int t; cin &gt;&gt; t; if(i &amp;&amp; t != v[v.size() - 1] || i == 0) v.pb(t); } v.pb(0); rep(i, 1, v.size() - 1) { if(v[i] &gt; v[i - 1] &amp;&amp; v[i] &gt; v[i + 1]) high[v[i]]++; if(v[i] &lt; v[i - 1] &amp;&amp; v[i] &lt; v[i + 1]) low[v[i]]++; } cnt[100001] = 0; int ans = 0; red(i, 100001, 0) { cnt[i] = cnt[i + 1] + high[i] - low[i]; ans = max(ans, cnt[i]); } cout &lt;&lt; ans &lt;&lt; '\\n'; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"差分","slug":"差分","permalink":"https://maskros.top/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"Codeforces Round 773 (Div.2)","slug":"codeforces/cf 773","date":"2022-02-23T14:30:00.000Z","updated":"2022-02-23T14:45:35.740Z","comments":true,"path":"/post/codeforces/cf 773.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20773.html","excerpt":"Codeforces Round 773 (Div.2)","text":"Codeforces Round #773 (Div.2) rk 293 AB各自白给了一发，但是上大分，嘻嘻 A_Hard_Way 水题，一开始没读懂题直接猜答案猜错了WA1，急了大火 void solve() { int x1, y1, x2, y2, x3, y3; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3; double ans = 0; if (y1 == y2) ans = (y3 &lt; y2) ? abs(x2 - x1) : 0; eif(y2 == y3) ans = (y1 &lt; y3) ? abs(x3 - x2) : 0; eif(y1 == y3) ans = (y2 &lt; y3) ? abs(x3 - x1) : 0; printf(\"%.9f\\n\", ans); } B_Power_Walking 水题，忘记 map.clear()了，白wa1发，纯丢人 map&lt;int, int&gt; mp; void solve() { mp.clear(); int n; cin &gt;&gt; n; rep(i, 1, n + 1) { int t; cin &gt;&gt; t; mp[t]++; } int mx = mp.size(); rep(i, 1, n + 1) cout &lt;&lt; max(i, mx) &lt;&lt; ' '; en; } C_Great_Sequence 题意： 给定长为 的数组 ，给定 ，你可以向数组中添加一些数，使得数组中的数两两一组，并且满足 ，询问至少添加多少个数。 思路： 暴力贪心即可，满足的直接扬了，用 multiset 维护一下，:) multiset&lt;ll&gt; s; void solve() { s.clear(); int n, x; cin &gt;&gt; n &gt;&gt; x; int t; rep(i, 0, n) {cin &gt;&gt; t; s.insert(t);} multiset&lt;ll&gt;::iterator it; int ans = 0; for (it = s.begin(); it != s.end(); it++) { ll tmp = (*it) * x; if(s.find(tmp) != s.end()) { s.erase(s.find(tmp)); }else ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } D_Repetitions_Decoding (构造) 题意： 给定一个数组，你可以对它进行操作：在某一位置连续插入两个相同数字。最终使得该数组按顺序变成 对重复序列 ​ 。(tandem repeats: 串联重复序列，如：1 2 3 1 2 3 | 4 7 5 4 7 5 | 6 6 ) 最终指定格式分别打印：操作数、操作内容、、最终序列的组成结构。如果不能构造输出 -1. 思路： 由于题干说只要构造成功就可以，不追求最小操作数，所以我们直接贪心即可。 首先由于每次操作插入的都是两个相同数字，故如果原序列中某个数只有奇数个，是不能构成 ​ 对重复序列的，特判一下； 构造时使用 vector 维护，双指针 , 扫描序列。从头开始，在序列中找到下一个与 一样的数的位置，标记为 (right_begin)，随后同时向右扫描，如果 = ，则跳过，如果不等，则在下标为 的位置插入 。当左侧序列指针 扫描到右侧序列起点处 时 ，则构成了一对重复序列，记录一下答案后，使 = 继续向后扫描即可。 写的时候由于对下标的混淆结果卡了一会，最后过的时候居然div2全场只过了200人，开心嗨了 :) vector&lt;int&gt; v; vector&lt;pair&lt;int,int&gt; &gt; op; vector&lt;int&gt; ans; map&lt;int, int&gt; mp; map&lt;int, int&gt;::iterator it; vector&lt;int&gt;::iterator pos; void debug() { en; for(auto x : v) de(x); en; en; } void solve() { mp.clear(); v.clear(); op.clear(); ans.clear(); int n; cin &gt;&gt; n; rep(i, 0, n) { int t; cin &gt;&gt; t; v.pb(t); mp[t]++; } bool flag = 1; for(it = mp.begin(); it != mp.end(); it++) { if(it-&gt;sec &amp; 1) { flag = 0; break;} } if(!flag) {cout &lt;&lt; -1 &lt;&lt; '\\n'; return;} else { int bg = 0, rbg, r; bool is = false; rep(i, 0, v.size()) { r++; if(!is) { pos = find(v.begin() + i + 1, v.end(), v[i]); bg = i; rbg = pos - v.begin(); r = rbg; is = true; } else { if(i == rbg) { i = r - 1; ans.pb(r - bg); is = false; continue; } if(r &gt;= v.size()) { v.pb(v[i]); v.pb(v[i]); op.pb(mpr(r + 1 - 1, v[i])); continue; } if(v[i] != v[r]) { v.insert(v.begin() + r, v[i]); v.insert(v.begin() + r, v[i]); op.pb(mpr(r + 1 - 1, v[i])); } } } } if(op.empty()) cout &lt;&lt; 0 &lt;&lt; '\\n'; else { cout &lt;&lt; op.size() &lt;&lt; '\\n'; for (auto x : op) cout &lt;&lt; x.fst &lt;&lt; \" \" &lt;&lt; x.sec &lt;&lt; \" \"; en; } if(ans.empty()) cout &lt;&lt; 1 &lt;&lt; '\\n' &lt;&lt; v.size() &lt;&lt; '\\n'; else { cout &lt;&lt; ans.size() &lt;&lt; '\\n'; for(auto x : ans) cout &lt;&lt; x &lt;&lt; ' '; en; } } 这场因为div1, div2同时进行分了波流，偷了个上分机会，变色！","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"LCA板子","slug":"algorithm/learn/LCA","date":"2022-02-08T16:00:00.000Z","updated":"2022-07-13T09:03:42.634Z","comments":true,"path":"/post/algorithm/learn/LCA.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/LCA.html","excerpt":"LCALowest Common Ancestor 最近公共祖先 定义一般指图论中有向无环图DAG或树中的最近公共祖先，两个节点的LCA在两点间的路径上","text":"LCALowest Common Ancestor 最近公共祖先 定义一般指图论中有向无环图DAG或树中的最近公共祖先，两个节点的LCA在两点间的路径上 四种求解板子 在线算法：问一次回答一次 离线算法：问完了一次性回答 0x01 树剖 在线 树链剖分求解LCA的过程就是轻重链的跳转，跟树剖求任意两点间的距离一样的操作，只不过不用线段树去维护dis了 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int sz[N], dep[N], fa[N], son[N], top[N]; int n, m; inline int read() { int f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } void add(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void dfs1(int rt, int f) { dep[rt] = dep[f] + 1; sz[rt] = 1, fa[rt] = f; for(int i = head[rt]; i; i = nex[i]) { if(to[i] == f) continue; dfs1(to[i], rt); if(!son[rt] || sz[to[i]] &gt; sz[son[rt]]) son[rt] = to[i]; sz[rt] += sz[to[i]]; } } void dfs2(int rt, int t) { top[rt] = t; if(!son[rt]) return ; dfs2(son[rt], t); for(int i = head[rt]; i; i = nex[i]) { if(to[i] == fa[rt] || to[i] == son[rt]) continue; dfs2(to[i], to[i]); } } int solve(int x, int y) { while(top[x] != top[y]) { if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = fa[top[x]]; } return dep[x] &lt; dep[y] ? x : y; } int main() { n = read(), m = read(); int rt = read(); int x, y; for(int i = 1; i &lt; n; i++) { x = read(), y = read(); add(x, y); add(y, x); } dfs1(rt, 0); dfs2(rt, rt); for(int i = 1; i &lt;= m; i++) { x = read(), y = read(); printf(\"%d\\n\", solve(x, y)); } return 0; } 0x02 Tarjan 离线 后序DFS+并查集 本质就是利用了dfs的节点顺序，当我们正在递归两个节点的最近公共祖先时，显然这两个点是属于其子树的节点，那么当我们第一次遍历完两个需要求解的两个点时，其最近的尚未被完全遍历完子节点的节点就是他们两个的最近公共祖先 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 5e5 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int visit[N], fa[N], n, m; int qhead[N], qto[N &lt;&lt; 1], qnex[N &lt;&lt; 1], qcnt = 1, qid[N &lt;&lt; 1], ans[N]; inline int read() { int f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } void add_edge(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void add_query(int x, int y, int w) { qto[qcnt] = y; qnex[qcnt] = qhead[x]; qid[qcnt] = w; qhead[x] = qcnt++; } int find(int rt) { return rt == fa[rt] ? rt : fa[rt] = find(fa[rt]); } void tarjan(int rt, int f) { for(int i = head[rt]; i; i = nex[i]) { if(to[i] == f) continue; tarjan(to[i], rt); fa[to[i]] = rt; } visit[rt] = 1; for(int i = qhead[rt]; i; i = qnex[i]) { if(!visit[qto[i]]) continue; ans[qid[i]] = find(qto[i]); } } int main() { // freopen(\"in.txt\", \"r\", stdin); n = read(), m = read(); int rt = read(); for(int i = 1; i &lt; n; i++) { int x = read(), y = read(); add_edge(x, y); add_edge(y, x); } for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 1; i &lt;= m; i++) { int x = read(), y = read(); add_query(x, y, i); add_query(y, x, i); } tarjan(rt, 0); for(int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0; } 0x03 ST表+RMQ 在线 先序DFS+ST RMQ(Range Mini/Maximum Query) 区间最值查询 利用dfs的遍历，在遍历两个点的时候，一定会在中间返回到其最近公共祖先，这个时候的公共祖先也就是这两个点的遍历中的最小值 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; inline ll read() { ll f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } const int N = 5e5 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int id[N], tot, last; int st[N &lt;&lt; 2][30]; void add(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void dfs(int rt, int fa) { id[rt] = last = ++tot; st[tot][0] = rt; for(int i = head[rt]; i; i = nex[i]) { if(to[i] == fa) continue; dfs(to[i], rt); st[++tot][0] = rt; } } int MIN(int a, int b) { return id[a] &lt; id[b] ? a : b; } int main() { // freopen(\"in.txt\", \"r\", stdin); int n = read(), m = read(), rt = read(); for(int i = 1; i &lt; n; i++) { int x = read(), y = read(); add(x, y); add(y, x); } dfs(rt, 0); int k = log(last) / log(2); for(int j = 1; j &lt;= k; j++) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= last; i++) st[i][j] = MIN(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for(int i = 1; i &lt;= m; i++) { int x = read(), y = read(); x = id[x], y = id[y]; if(x &gt; y) swap(x, y); int k = log(y - x + 1) / log(2); printf(\"%d\\n\", MIN(st[x][k], st[y - (1 &lt;&lt; k) + 1][k])); } return 0; } 0x04 倍增 类似于快速幂，通过二进制数的组合来达到 级别的优化，但是需要注意其中进制的枚举大小顺序 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; inline ll read() { ll f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } const int N = 5e5 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int fa[N][21], dep[N], n, m; void add(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void dfs(int rt, int f) { dep[rt] = dep[f] + 1; fa[rt][0] = f; for(int i = 1; 1 &lt;&lt; i &lt;= dep[rt]; i++)//进制由小到大递推 fa[rt][i] = fa[fa[rt][i - 1]][i - 1]; for(int i = head[rt]; i; i = nex[i]) { if(to[i] == f) continue; dfs(to[i], rt); } } int LCA(int x, int y) { if(dep[x] &lt; dep[y]) swap(x, y); for(int i = 20; i &gt;= 0; i--)//进制由大到小开始组合， if(dep[fa[x][i]] &gt;= dep[y]) x = fa[x][i]; if(x == y) return x;//注意特判 for(int i = 20; i &gt;= 0; i--)//进制从小到大开始组合， if(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0];//这一步尤其考虑，为什么x, y不知LCA,而其父节点就一定是LCA， } int main() { // freopen(\"in.txt\", \"r\", stdin); int n = read(), m = read(), rt = read(); for(int i = 1; i &lt; n; i++) { int x = read(), y = read(); add(x, y); add(y, x); } dfs(rt, 0); for(int i = 1; i &lt;= m; i++) { int x = read(), y = read(); printf(\"%d\\n\", LCA(x, y)); } return 0; }","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"LCA","slug":"LCA","permalink":"https://maskros.top/tags/LCA/"}]},{"title":"2022牛客寒假算法基础集训营4","slug":"nowcoder/2022winter/round4","date":"2022-02-08T13:30:50.000Z","updated":"2022-03-02T13:46:31.541Z","comments":true,"path":"/post/nowcoder/2022winter/round4.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round4.html","excerpt":"","text":"2022牛客寒假算法基础集训营4 AC 11 / 12 A R (二分/前缀和) 题意： 给定长为 的字符串 , 给定 , 求字符串中含 ‘R’ 个数大于等于 且不含字符 ‘P’ 的子串个数 思路： 前缀和储存 R 和 P 的个数，枚举左端点，二分查找符合条件的最近右端点长度和最远右端点，作差即为贡献值。 int n, k; char s[maxn]; int R[maxn], P[maxn]; bool checkR(int l, int r) { int cnt_R = R[r] - R[l - 1]; if(cnt_R &gt;= k) return 1; else return 0; } bool checkP(int l, int r) { int cnt_P = P[r] - P[l - 1]; if(cnt_P == 0) return 1; else return 0; } void solve() { cin &gt;&gt; n &gt;&gt; k; R[0] = 0, P[0] = 0; rep(i, 1, n + 1) { cin &gt;&gt; s[i]; R[i] = R[i - 1], P[i] = P[i - 1]; if(s[i] == 'R') R[i]++; eif(s[i] == 'P') P[i]++; } ll ans = 0; rep(i, 1, n + 1) { int l = i, r = n; int rmx = 0, lmn = 0; while(l &lt;= r) { int mid = (l + r) / 2; if(checkP(i, mid)) { rmx = mid; l = mid + 1; } else r = mid - 1; } if(rmx == 0) continue; l = i, r = rmx; while(l &lt;= r) { int mid = (l + r) / 2; if(checkR(i, mid)) { lmn = mid; r = mid - 1; } else l = mid + 1; } if(lmn == 0) continue; int len = rmx - lmn + 1; ans += len; } cout &lt;&lt; ans &lt;&lt; '\\n'; } *B 进制 (线段树) 题意： 长度为 的字符串 (only include ‘0’ ~ ‘9’)，有 次以下两种操作： 输入 1 x y, 修改第 个字符为 ，即 输出 2 x y, 代表查询区间 [, ]，该区间子串能表示的某进制的最小值 (二进制到十进制之间)，对 1e9 + 7 取模 思路： 区间最大数字为 ​ 则对应 ​ 进制即为所求，用线段树维护区间最大值，同时维护在 2 ~ 10 进制下每个区间的值。 一个区间的值 = 左区间的值 * pow(进制, 右区间长度) * 右区间的值 int n, q; int s[maxn]; ll qpow(ll a, ll b) { ll res = 1; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; } return res; } struct SegTree { int l, r; ll a[15]; int m; }tree[maxn &lt;&lt; 2]; void build(int u, int l, int r) { if(l == r) { tree[u].l = tree[u].r = l; int tmp = s[l]; tree[u].m = tmp; rep(i, max(2, tmp + 1), 11) { tree[u].a[i] = tmp; } } else { int mid = l + r &gt;&gt; 1; build(u * 2, l, mid); build(u * 2 + 1, mid + 1, r); tree[u].m = max(tree[u * 2].m, tree[u * 2 + 1].m); rep(i, max(2, tree[u].m + 1), 11) { tree[u].a[i] = (tree[u * 2].a[i] * qpow(i, r - mid) % mod + tree[u * 2 + 1].a[i]) % mod; } } } void update(int u, int l, int r, int x, int y) { if(l == r) { tree[u].m = y; rep(i, max(2, y + 1), 11) { tree[u].a[i] = y; } } else { int mid = l + r &gt;&gt; 1; if(x &lt;= mid) update(u * 2, l, mid, x, y); else update(u * 2 + 1, mid + 1, r, x, y); tree[u].m = max(tree[u * 2].m, tree[u * 2 + 1].m); rep(i, max(2, tree[u].m + 1), 11) { tree[u].a[i] = (tree[u * 2].a[i] * qpow(i, r - mid) % mod + tree[u * 2 + 1].a[i]) % mod; } } } int querymax(int u, int l, int r, int x, int y) { if(x &lt;= l &amp;&amp; r &lt;= y) return tree[u].m; int mid = l + r &gt;&gt; 1; if(y &lt;= mid) return querymax(u * 2, l, mid, x, y); eif(x &gt; mid) return querymax(u * 2 + 1, mid + 1, r, x, y); else return max(querymax(u * 2, l, mid, x, y), querymax(u * 2 + 1, mid + 1, r, x, y)); } ll query(int u, int l, int r, int x, int y, int z) { if(x &lt;= l &amp;&amp; r &lt;= y) return tree[u].a[z]; int mid = l + r &gt;&gt; 1; if(y &lt;= mid) return query(u * 2, l, mid, x, y, z); eif(x &gt; mid) return query(u * 2 + 1, mid + 1, r, x, y, z); else return (query(u * 2, l, mid, x, mid, z) * qpow(z, y - mid) % mod + query(u * 2 + 1, mid + 1, r, mid + 1, y, z)) % mod; } void solve() { cin &gt;&gt; n &gt;&gt; q; rep(i, 1, n + 1) { char t; cin &gt;&gt; t; s[i] = t - '0'; } build(1, 1, n); rep(i, 0, q) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if(op == 1) update(1, 1, n, x, y); else { int z = querymax(1, 1, n, x, y); cout &lt;&lt; query(1, 1, n, x, y, z + 1) &lt;&lt; '\\n'; } } } C 蓝彗星 (差分) 题意： 输入 , 表示彗星的数量和每个彗星的持续时间，输出一个长 的只有 ‘B’ 和 ‘R’ 组成的字符串，表示彗星颜色，B为蓝色R为红色。 输入 个整数 ，表示每颗彗星的开始时刻，求能看到蓝彗星且看不到红彗星的总秒数。 1 &lt;= &lt;= 1e5 思路： 维护两个差分数组表示蓝彗星和红彗星的持续时间，按时间顺序开始遍历，分别计算两个数组的前缀和来看当前时间是否符合条件，符合则计数。 #define N 100005 char s[N]; int a[N], red[2 * N], blue[2 * N]; void solve(){ int n, t; cin &gt;&gt; n &gt;&gt; t; rep(i, 1, n + 1) { cin &gt;&gt; s[i]; } rep(i, 1, n + 1) { cin &gt;&gt; a[i]; if(s[i] == 'B') blue[a[i]]++, blue[a[i] + t]--; else red[a[i]]++, red[a[i] + t]--; } int ans = 0; int redcnt = 0, bluecnt = 0; rep(i, 1, 2 * N) { redcnt += red[i]; bluecnt += blue[i]; if(bluecnt &amp;&amp; !redcnt) ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } D 雪色光晕 (二维几何) 计算点到线段的最短距离，套板子 //square of a double inline double sqr(double x){return x*x;} int sgn(double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1; } struct Point{ double x,y; Point(){} Point(double _x,double _y){ x = _x; y = _y; } bool operator==(Point b) const { return sgn(x - b.x) == 0 &amp;&amp; sgn(y - b.y) == 0; } bool operator&lt;(Point b) const { return sgn(x - b.x) == 0 ? sgn(y - b.y) &lt; 0 : x &lt; b.x; } Point operator-(const Point&amp; b) const { return Point(x - b.x, y - b.y); } //叉积 double operator^(const Point&amp; b) const { return x * b.y - y * b.x; } //点积 double operator*(const Point&amp; b) const { return x * b.x + y * b.y; } //返回长度 double len() { return hypot(x, y); //库函数 } //返回长度的平方 double len2() { return x * x + y * y; } //返回两点的距离 double distance(Point p) { return hypot(x - p.x, y - p.y); } }; struct Line{ Point s,e; Line(){} Line(Point _s,Point _e){ s = _s; e = _e; } //求线段长度 double length() { return s.distance(e); } //点到直线的距离 double dispointtoline(Point p) { return fabs((p - s) ^ (e - s)) / length(); } //点到线段的距离 double dispointtoseg(Point p) { if (sgn((p - s) * (e - s)) &lt; 0 || sgn((p - e) * (s - e)) &lt; 0) return min(p.distance(s), p.distance(e)); return dispointtoline(p); } }; void solve() { int n; double x0,y0,x,y; cin&gt;&gt;n&gt;&gt;x0&gt;&gt;y0&gt;&gt;x&gt;&gt;y; Point p0=Point(x,y),p=Point(x0,y0); double dis=p0.distance(p); double xx,yy; rep(i,0,n){ cin&gt;&gt;xx&gt;&gt;yy; Point p1=Point(x0+xx,y0+yy); Line l1=Line(p,p1); dis=min(l1.dispointtoseg(p0),dis); x0+=xx; y0+=yy; p=Point(x0,y0); } printf(\"%.8lf\",dis); } G 子序列权值乘积 (快速幂/欧拉降幂) 题意： 小红定义一个数组的权值为该数组的最大值乘以最小值。例如数组 [4,1,3] 的权值是 41=4。小红拿到了一个数组。她想知道，这个数组的所有 *非空子序列 的权值的乘积是多少？由于该数过大，请对 1e9+7 取模。 子序列的定理：对于一个数组，删除其中某些数之后（也可以不删）得到的数组。子序列中的数的相对顺序必须和原数组中的顺序相同 exp: 数组 [1,3,2] 的非空子序列有 [1] [3] [2] [1,3] [1,2] [3,2] [1,3,2] 共7个。 思路： 先排序，随后遍历数组，从当前位置与后面所有序列组成的序列的最小值都是他，与前面所有序列组成的序列的最大值都是他，用快速幂计算贡献即可，注意指数部分取模要采用欧拉降幂，即 % mod - 1 计算贡献：qpow(a[i], qpow(2, n - i, mod - 1), mod) % mod * qpow(a[i], qpow(2, i - 1, mod - 1), mod); int n, a[maxn]; ll qpow(ll a, ll b, ll _mod) { ll ans = 1; while (b) { if (b &amp; 1) ans = ans * a % _mod; a = a * a % _mod; b &gt;&gt;= 1; } return ans; } void solve() { cin &gt;&gt; n; rep(i, 1, n + 1) { cin &gt;&gt; a[i]; } sort(a + 1, a + n + 1); ll ans = 1; rep(i, 1, n + 1) { ans = ans * qpow(a[i], qpow(2, n - i, mod - 1), mod) % mod * qpow(a[i], qpow(2, i - 1, mod - 1), mod) % mod; } cout &lt;&lt; ans &lt;&lt; '\\n'; } I 爆炸的符卡洋洋洒洒 (dp) 题意： 小红正在研究如何把符卡组合出尽可能大威力的组合魔法。 小红共有 ​ 种符卡可以选择，每种符卡最多只能选择一次，每个符卡的魔力消耗为 ​，威力为 ​。如果将多个符卡进行组合，则可以发动一个组合魔法。组合魔法的魔力消耗为选择的符卡的魔力消耗的总和，其威力为选择的符卡的威力的总和。小红必须保证最终符卡的魔力消耗总和为 ​​ 的倍数。小红想知道，自己能发动的组合魔法最大的威力是多少？, &lt; 1e3; , &lt; 1e9 思路： 01背包，dp[i][j] 表示为前 i 张卡魔力消耗模 k 为 j 的符卡威力的最大值。 int a[1005], b[1005]; ll dp[1005][1005]; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 1, n + 1) { cin &gt;&gt; a[i] &gt;&gt; b[i]; a[i] %= k; } rep(i, 1, n + 1) { dp[i][a[i]] = b[i]; rep(j, 0, k) { dp[i][j] = max(dp[i - 1][j], dp[i][j]); if(dp[i - 1][(j - a[i] + k) % k]) dp[i][j] = max(dp[i][j], dp[i - 1][(j - a[i] + k) % k] + b[i]); } } if(dp[n][0]) cout &lt;&lt; dp[n][0]; else cout &lt;&lt; -1; } J 区间合数的最小公倍数 (数学) 题意： 求区间 中所有合数的最小公倍数对 1e9 + 7 取模, , &lt; 3e5 思路： 预处理所有的素数，根据唯一分解定理可知所有的合数可以分解成素数的幂的乘积，求最小公倍数 lcm 只需要维护一个map，对每个素因子取最高次幂即可，快速幂计算最小公倍数。 ll qpow(int a, int b) { ll ans = 1; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) ans = ans * a % mod; a = a * a % mod; } return ans; } vector&lt;int&gt; prime; bool notprime[maxn]; void getprime() { notprime[1] = 1; rep(i, 2, maxn) { if(!notprime[i]) { prime.pb(i); for(int j = i * i; j &lt;= maxn; j += i) notprime[j] = 1; } } } map&lt;int, int&gt; mp; void solve() { int l, r; cin &gt;&gt; l &gt;&gt; r; ll ans = 1; getprime(); rep(i, l, r + 1) { if(!notprime[i]) continue; int tmp = i; for(auto x : prime) { int cnt = 0; while(tmp % x == 0) { tmp /= x; cnt++; } mp[x] = max(mp[x], cnt); if(tmp == 1) break; } } for(auto &amp;it : mp) { ans = ans * qpow(it.fst, it.sec) % mod; } if(ans == 1) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; ans &lt;&lt; '\\n'; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"线段树","slug":"线段树","permalink":"https://maskros.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"欧拉降幂","slug":"欧拉降幂","permalink":"https://maskros.top/tags/%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/"}]},{"title":"Codeforces Round 770 (Div.2)","slug":"codeforces/cf 770","date":"2022-02-08T10:30:00.000Z","updated":"2022-02-15T11:14:34.482Z","comments":true,"path":"/post/codeforces/cf 770.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20770.html","excerpt":"Codeforces Round 770 (Div.2)","text":"Codeforces Round #770 (Div.2) 被交互题干碎，hack真好玩 A_Reverse_and_Concatenate 水题 void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; string s, ss; cin &gt;&gt; s; ss = s; reverse(s.begin(), s.end()); if (ss == s || k == 0) cout &lt;&lt; 1 &lt;&lt; \"\\n\"; else cout &lt;&lt; 2 &lt;&lt; \"\\n\"; } B_Fortune_Telling (xor) 题意： 给定一个 数组，可以对一个非负整数 遍历数组 (从 1 到 n) 做如下操作: 或者 。 Alice 从 开始，Bob 从 开始，已知输入数据一定合法，询问 Alice 和 Bob 谁能遍历数组后得到 思路： 重要性质： 和 的奇偶性不会改变 根据题意， 和 的奇偶性固然不同，遍历判断奇偶性即可。 void solve() { ll n, x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; x = x &amp; 1 ? 1 : 0; rep (i, 0, n){ int t; cin &gt;&gt; t; x = (x + t) &amp; 1 ? 1 : 0; } if ((x &amp; 1) == (y &amp; 1)) puts(\"Alice\"); else puts(\"Bob\"); } C_OKEA (构造) 题意： 给定 , ，构造这样一个从 到 的矩阵，要求每行的相邻 个数的和要被 整除，不能构造输出 NO，否则输出 YES 和构造方案。 思路：嗯构造，注意一下为NO的条件为 (n * k) % (2 * k) != 0 &amp;&amp; k != 1 即可 void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; if((n * k) % (2 * k) &amp;&amp; k != 1) { puts(\"NO\"); return ;} puts(\"YES\"); rep(i, 1, n + 1){ rep(j, 0, k){ cout &lt;&lt; i + j * n &lt;&lt; \" \"; } en; } } D_Finding_Zero 题意： 交互题, 待补 这场因为交互题卡的人还挺多，结果去hack了别人的A，hack的挺爽，上了一波小分","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"牛客2022年除夕AK场- E 春联(博弈)","slug":"probs/春联sg","date":"2022-02-04T15:30:50.000Z","updated":"2022-02-15T10:12:21.826Z","comments":true,"path":"/post/probs/春联sg.html","link":"","permalink":"https://maskros.top/post/probs/%E6%98%A5%E8%81%94sg.html","excerpt":"","text":"牛客2022年除夕AK场- E 春联(博弈) link 题面小红和紫准备玩一个游戏。她们拿到了一个只包含小写字母的字符串 。两人轮流将一个小写字母添加到一个新串 的结尾，必须保证t时刻都是 的一个子序列。谁先无法操作则输掉游戏。 初始是一个空串。小红先手添加，假设两人都足够聪明，请问谁最终能获得胜利？ 子序列 Def‘：若一个字符串 删除部分字符（也可以不删）后得到字符串 ，那么称 是 的子序列。 如果小红获得胜利，则输出 “kou”，否则输出 “yukari” 题解首先，最后一个字母是必胜位置，那么与最后一个字母相同的位置到最后一个字母之间都是必败区间，因为在这中间选，那么接下来对手至需要选最后一个字母即可获胜。 那么，就会形成 , 代表必败区间， 代表必胜区间 那么考虑由必胜作为第一个点，那么小红只需要先手在第一个位置，那么就会将对手逼入必败 不完整的必败区间作为开头，小红也可以选择第一个必胜点，转为情况1 只有当完整的必败区间（找到了与之后第一个必败区间相同的字母）作为开头，那么这时候小红只能在必败区间选取，则无法取胜 🐴void solve(){ string s; cin&gt;&gt;s; int i,j=s.length()-1; for(i=j-1;i&gt;=0;i--){ if(s[i]==s[j])j=i-1,i=j; } if(j==-1) puts(\"yukari\"); else puts(\"kou\"); } 如果要求每次添加的时候t都是s的子串，解法是后缀自动机next指针dag图上求sg函数 &gt;~&lt;","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"博弈","slug":"博弈","permalink":"https://maskros.top/tags/%E5%8D%9A%E5%BC%88/"}]},{"title":"2022牛客寒假算法基础集训营3","slug":"nowcoder/2022winter/round3","date":"2022-02-03T13:30:50.000Z","updated":"2022-02-24T06:41:19.480Z","comments":true,"path":"/post/nowcoder/2022winter/round3.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round3.html","excerpt":"","text":"2022牛客寒假算法基础集训营3 AC 7 / 12 越打越菜 B 智乃买瓜 (背包) 题意： 智乃来到水果摊前买瓜，水果摊上贩卖着 个不同的西瓜，第 个西瓜的重量为 。智乃对于每个瓜都可以选择买一个整瓜或者把瓜劈开买半个瓜，半个瓜的重量为 。保证所有瓜的重量都是一个正偶数。如果他想要购买西瓜的重量和分别为 时，有多少种购买西瓜的方案，答案对1e9+7取模 题解： 分组背包，每个瓜有三种决策：买一个/半个/不买， 表示前 个瓜，重量为 的方案数，故可列出转移方程： // dp[1005][2005] int dp[1005][2005]; int w[1005]; void solve() { int N, M; cin &gt;&gt; N &gt;&gt; M; rep(i, 1, N + 1) cin &gt;&gt; w[i]; rep(i, 1, N + 1) { dp[i][w[i]]++; dp[i][w[i] / 2]++; rep(j, 1, M + 1) { dp[i][j] += dp[i - 1][j]; if(j - w[i] &gt;= 0) dp[i][j] = (dp[i - 1][j - w[i]] + dp[i][j]) % mod; if(j - w[i] / 2 &gt;= 0) dp[i][j] = (dp[i - 1][j - w[i]/2] + dp[i][j]) % mod; } } rep(i, 1, M + 1) { cout &lt;&lt; dp[N][i] &lt;&lt; ' '; } } // dp[2005] another version int dp[2005]; int w[1005]; void solve() { int N, M; cin &gt;&gt; N &gt;&gt; M; rep(i, 1, N + 1) cin &gt;&gt; w[i]; rep(i, 1, N + 1) { red(j, M + 1, 1) { if(j - w[i] &gt;= 0) dp[j] = (dp[j - w[i]] + dp[j]) % mod; if(j - w[i] / 2 &gt;= 0) dp[j] = (dp[j - w[i] / 2] + dp[j]) % mod; } dp[w[i]]++; dp[w[i] / 2]++; } rep(i, 1, M + 1) { cout &lt;&lt; dp[i] &lt;&lt; ' '; } } *C 智乃买瓜 v2 (dp) 题意： B题的反转，给定质量从 到 的买瓜方案数，让你还原西瓜的个数和质量。 思路： 首先容易知道 的个数是确定的。不放倒着考虑，在B题中dp[i, j]的方案数是怎么得到的，这里就怎么减去。思路就是在把一个个dp方案数变为 ​ 的过程中不断将使用的重量放到答案vector中。从前往后遍历dp数组，如果一个位置的值不为0，说明这些剩下的这个重量i对应的方案数只能由 i*2 这个西瓜/2来提供。此时就把一个i*2放入ans，然后更新后面的dp数组部分 TIPS: i==j 时就是处理 dp[i]，剩下的方案数由dp[i]个i*2的瓜提供，因此dp[0]要设置为1，即每次都要减1。 int dp[2005]; vector&lt;int&gt; w; void solve() { int M; cin &gt;&gt; M; rep(i, 1, M + 1) cin &gt;&gt; dp[i]; dp[0] = 1; // important rep(i, 1, M + 1) { while(dp[i]) { w.pb(2 * i); rep(j, i, M + 1) { dp[j] = (dp[j] - dp[j - i] + mod) % mod; if(j - 2 * i &gt;= 0) dp[j] = (dp[j] - dp[j - i * 2] + mod) % mod; } } } cout &lt;&lt; w.size() &lt;&lt; \"\\n\"; for (auto v : w) cout &lt;&lt; v &lt;&lt; ' '; } D 智乃的01串打乱 水题 void solve() { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; rep(i, 1, s.size()){ if(s[i] != s[0]) { swap(s[0], s[i]); break;} } cout &lt;&lt; s; } E 智乃的数字积木 ezv 贪心暴力即可 int n, m, k; char s[100005]; int a[100005]; ll cal() { ll ret = s[0] - '0'; rep(i, 1, n) { ret = (ret * 10 + s[i] - '0') % mod; } return ret; } void op() { int idx = 0; rep(i, 1, n) { if (a[i] != a[idx]) { sort(s + idx, s + i, greater&lt;char&gt;() ); idx = i; } } sort(s + idx, s + n, greater&lt;char&gt;() ); cout &lt;&lt; cal() &lt;&lt; '\\n'; } void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s; a[0] = 0; rep(i, 0, n) cin &gt;&gt; a[i]; op(); rep(i, 0, k) { int x, y; cin &gt;&gt; x &gt;&gt; y; rep(i, 0, n) { if(a[i] == x) a[i] = y; } op(); } } G 智乃的树旋转 ezv 简单的树的性质 int fa[1005]; void solve() { int n; cin &gt;&gt; n; rep(i, 1, n + 1) fa[i] = i; int x1, x2; rep(i, 1, n + 1) { cin &gt;&gt; x1 &gt;&gt; x2; if (x1) fa[x1] = i; if (x2) fa[x2] = i; } int ans = 0; rep(i, 1, n + 1) { cin &gt;&gt; x1 &gt;&gt; x2; if (x1 &amp;&amp; fa[i] == x1) ans = x1; if (x2 &amp;&amp; fa[i] == x2) ans = x2; } if(ans) cout &lt;&lt; 1 &lt;&lt; '\\n' &lt;&lt; ans; else cout &lt;&lt; 0; } I 智乃的密码 (二分/前缀和) 题意： 密码是仅包含大小写英文字母、数字、特殊符号的字符串；密码的长度不少于 个字符，并且不多于 个字符。密码中应该至少包括①大写英文字母、②小写英文字母、③数字、④特殊符号这四类字符中的三种。 现在智乃有一个长度大小为 的字符串 ，她想知道 ​ 串中有多少个子串是一个符合条件的密码，请你帮助智乃统计符合条件的密码数目 思路： 前缀和处理字符串，遍历枚举左端点，二分找符合条件最近距离的右端点，计算贡献值。 int n, l, r; char s[100005]; int pre[100005][5]; bool check(int ll, int rr) { int checksum = min(pre[rr][0] - pre[ll - 1][0], 1) + min(pre[rr][1] - pre[ll - 1][1], 1) + min(pre[rr][2] - pre[ll - 1][2], 1) + min(pre[rr][3] - pre[ll - 1][3], 1); if(checksum &gt;= 3) return 1; return 0; } void solve() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; rep(i, 1, n + 1) cin &gt;&gt; s[i]; pre[0][0] = pre[0][1] = pre[0][2] = pre[0][3] = 0; rep(i, 1, n + 1) { rep(j, 0, 4) pre[i][j] = pre[i - 1][j]; if(s[i] &lt;= '9' &amp;&amp; s[i] &gt;= '0') pre[i][0]++; eif(s[i] &lt;= 'Z' &amp;&amp; s[i] &gt;= 'A') pre[i][1]++; eif(s[i] &lt;= 'z' &amp;&amp; s[i] &gt;= 'a') pre[i][2]++; else pre[i][3]++; } ll ans = 0; rep(i, 1, n + 1) { if(i + l - 1 &gt; n) break; int mnpos = 0; int L = l - 1, R = min(r - 1, n - i); while(L &lt;= R) { int mid = (L + R) / 2; if(check(i, i + mid)) { R = mid - 1; mnpos = min(r - 1, n - i) - mid + 1; }else L = mid + 1; } ans += mnpos; } cout &lt;&lt; ans &lt;&lt; '\\n'; } J 智乃的C语言模除方程 (分类讨论) 题意： 模除是一种不具交换性的二元运算。模除（又称模数、取模操作、取模运算等，英语： 或 。得到的是一个数除以另一个数的余数，给定两个正整数：被除数 和除数 ，得到的是使用欧几里德除法时 的余数。而当 和 出现负数时，通常的定义就不适用了，c/c++语言中，当被除数 或者 出现负数时，运算的过程中首先将 和 作为非负整数进行运算，然后得出结果时符号与被除数 保持一致。举个例子，比如 而 。 现在智乃有一个模除方程： ， 其中 为未知数, 为给定常数, 可为区间 内的任意整数，运算遵循c/c++中模除运算的运算法则。 显然这个方程的解并不为一，所以智乃现在给你划定了一个整数答案区间 ，询问答案区间 内有多少符合条件的整数 能使得等式 ​ 成立。 思路：分类讨论 #include &lt;bits/stdc++.h&gt; using namespace std; int P, l, r, L, R; typedef long long ll; ll ans; ll calc(ll a, ll b, ll c, ll d) { //计算符合条件的区间长 if (b &lt; c || d &lt; a) return 0ll; ll r = min(b, d), l = max(a, c); return r - l + 1; } ll query(ll u) { //[0,u]中符合条件的个数 // u/p份 每份所在总区间为[0,P-1] // u%p 余数为[1,u%p] 0%p=0 总区间[0,p] if (u &gt;= 0) return 1ll * (u / P) * calc(0, P - 1, l, r) + 1ll * calc(0, u % P, l, r); else return 1ll * abs(u) / P * calc(1 - P, 0, l, r) + 1ll * calc(u % P, 0, l, r); } int main() { cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R; P = abs(P); if (L &gt;= 0 &amp;&amp; R &gt;= 0) ans = query(R) - query(L - 1); else if (L &lt;= 0 &amp;&amp; R &gt;= 0) ans = query(R) + query(L) - query(0); else ans = query(L) - query(R + 1); cout &lt;&lt; ans &lt;&lt; endl; return 0; } L 智乃的数据库 (模拟) 题意： 模拟SQL语句: SELECT COUNT(*) FROM Table GROUP BY ...; 思路： 模拟即可，注意细心不要写错 int N, M; map&lt;string, int&gt; mp; vector&lt;int&gt; order; struct node { int data[maxn]; } a[maxn]; bool cmp(node x, node y){ rep(i, 0, order.size()) { int idx = order[i]; if(x.data[idx] == y.data[idx]) continue; else return x.data[idx] &lt; y.data[idx]; } return x.data[0] &lt; y.data[0]; } void solve() { cin &gt;&gt; N &gt;&gt; M; string s; rep(i, 0, M) { cin &gt;&gt; s; mp[s] = i;} rep(i, 0, N) { rep(j, 0, M) { cin &gt;&gt; a[i].data[j]; } } rep(i, 0, 7) cin &gt;&gt; s; int bg = 0; rep(i, 0, s.size()) { if(s[i] == ',' || s[i] == ';') { string key = s.substr(bg, i - bg); bg = i + 1; order.pb(mp[key]); } } sort(a, a + N, cmp); int cnt = 1; vector&lt;int&gt; ret; rep(i, 1, N) { rep(j, 0, order.size()) { int idx = order[j]; if(a[i].data[idx] != a[i - 1].data[idx]) { ret.pb(cnt); cnt = 0; break; } } cnt++; } ret.pb(cnt); cout &lt;&lt; ret.size() &lt;&lt; '\\n'; for (auto x : ret) cout &lt;&lt; x &lt;&lt; ' '; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"}]},{"title":"Codeforces Round 769 (Div.2)","slug":"codeforces/cf 769","date":"2022-02-02T10:30:00.000Z","updated":"2022-02-14T11:50:34.731Z","comments":true,"path":"/post/codeforces/cf 769.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20769.html","excerpt":"Codeforces Round 769 (Div.2)","text":"Codeforces Round #769 (Div.2) virtual participant A_ABC 水题 void solve() { int t; cin&gt;&gt;t; string s; cin&gt;&gt;s; if(t&gt;=3){puts(\"NO\");} else{ if(t==1) puts(\"YES\"); eif(t==2&amp;&amp;s[0]==s[1]) puts(\"NO\"); else puts(\"YES\"); } } B_Fun_with_Even_Subarrays (构造/xor) 题意： 从 ~ 代表 个连续柱子的高度，现在需要构造一个排列，构建的成本为相邻柱子异或的最大值，即 ，现在要使成本最小。 思路： 无论如何异或的最大值都由最高位决定，注意把他和低位的全1数错开即可 void solve() { int n; cin&gt;&gt;n; int mx; rep(i,1,20){ int p=pow(2,i); if(p==n-1) {mx=p; break;} eif(p&gt;n-1) {mx=pow(2,i-1); break;} } rep(i,1,mx) cout&lt;&lt;i&lt;&lt;\" \"; cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;mx&lt;&lt;\" \"; rep(i,mx+1,n) cout&lt;&lt;i&lt;&lt;\" \"; en; } C_Strange_Test (or) 题意： 给定 和 (a&lt;b)，可以做任意次操作： ​ 询问至少需要多少次操作才能使 ? 思路： 由于or操作的性质， 一定大于 和 ，故或操作最多执行一次。所以只需判断是先 自加再 or 还是先 自加再 or 即可。 // 只可能先a++再or，或者先b++再or void solve() { int a, b; cin &gt;&gt; a &gt;&gt; b; int x = a, y = b; int ans1 = 1, ans2 = 1; while((x|y) != y &amp;&amp; x &lt;= y) x++, ans1++; if(x == y) ans1--; while((a|b) != b) b++, ans2++; cout &lt;&lt; min(ans1, ans2) &lt;&lt; \"\\n\"; } D_New_Year_Concert (ST表/二分) 题意： 个学校从 到 编号，第 个班级准备了时长为 的节目，对于前 个节目，如果存在 , () 且 ，观众就会感觉无聊，为了避免这种情况，你可以修改任意节目的时长为任意正整数。 规定 为前 个节目需要修改的最小次数，打印 思路： 注意到，a个数的GCD一定不小于a+1个数的GCD，因此其具有单调性（满足二分条件）。且每次操作的那个数可以替换为任意值，那么就可以取一个大素数。且f值具有承袭性。那么考虑这样一个做法： 遍历1到n，设当前为i，lst为上一次进行操作的位置+1。如果当前a[i] = 1，必然要进行更改；否则基于上面提到的n个数GCD的性质，二分找[lst, i]这段区间是否存在某个字区间[x, i]满足。如果有的话则让 ，同时 更新为 ；如果没有则让 即可，二分check使用ST表查询区间GCD。 #include&lt;bits/stdc++.h&gt; using namespace std; int a[200009], st[200009][30]; int gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b); } int query(int l, int r) { int k = log2(r - l + 1); return gcd(st[l][k], st[r-(1&lt;&lt;k)+1][k]); } int main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); st[i][0] = a[i]; } for(int j = 1; j &lt;= 20; j++) { for(int i = 1; i &lt;= n; i++) { if(i + (1 &lt;&lt; j) - 1 &gt; n) continue; st[i][j] = gcd(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]); } } int pos = 1, ans = 0; for(int i = 1; i &lt;= n; i++) { int l = pos, r = i; while(l &lt; r) { int mid = (l + r) / 2; if(query(mid, i) &gt;= i - mid + 1) r = mid; else l = mid + 1; } if(query(l, i) == i - l + 1) { ans++; pos = i + 1; } printf(\"%d \", ans); } cout &lt;&lt; endl; return 0; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"ST表","slug":"ST表","permalink":"https://maskros.top/tags/ST%E8%A1%A8/"}]},{"title":"记念二〇二一","slug":"life/Summary_2021","date":"2022-02-01T15:50:00.000Z","updated":"2022-02-01T16:07:08.837Z","comments":true,"path":"/post/life/Summary_2021.html","link":"","permalink":"https://maskros.top/post/life/Summary_2021.html","excerpt":"","text":"记念二〇二一 以下 Q&amp;A： Q：为什么是“记念”？ A：这个词对于我来说最早出自高中学过的一篇课文，鲁迅的《记念刘和珍君》，关于这一篇为啥我记得比较清楚，这里按下不表。当时就在想为什么是“记念”而非“纪念”，然后查了查，我觉得最靠谱的理由就是他写这篇文章的时候文白混杂、简繁混用才写的“记念”。什么诸如细细品味在《线代汉语词典》中词性和用法的微微差异，我觉得这种瞎JB猜的都是扯淡。但是说回正题，我在这里为什么要用”记念“呢，就是因为想用了。 Q：为什么大年初一才发年终总结，而不是1月1号？ A：这个有很多原因。我还是更倾向于1月1号代表新的一年，日历也得换本新的，虽然👴🏻不用台历。那天晚上想写来着又因为感觉有些作业没处理，比较忙，就没写。实际情况是当天晚上摆了，啥正事没干，过了那天又觉得写有没啥意思，就拖下来了。总结：摆了，没来得及写。 OK，接下来进入正题。 本文贯彻总-分-总的行文结构，以下叙事按时间轴进行，无图（其实图挺多的要放图也行但是懒得放），最后来个总结，over. （以下为目录，如果你是PC的话右边儿👉🏻也有、排版部分借鉴了coin哥哥🥰的风格） 一月 一些新鲜事 生日 考试周 二月 MCM[1] 春晚 三月 四月 蓝莲花 Take On me The Dawn 1丶惊喜 五月 败走银川 摇滚之夜 六月 山东大学“六月的风” Livehouse 欧洲杯 考试月 七月 体验生活 NBA Final 训练 八月 东京奥运 👩’s Birthday CR7 九月 Web框架编程 国赛 藏书票 十月 👋，旧手机 Vlog👶🏻横空出世 十一月 EDG 海超[2] 败走上海 十二月 CCSP 软件工程 总结 迷茫 轮廓 展望 一月 近年的一月都如此般经典，不过今年新鲜一点 一些新鲜事来自bilibili年终报告：吟游大司人可能是你今年最喜欢的UP主，你一共看了TA的视频 718 次，这或许证明了我对金轮的爱，但是也侧面证明了把很多时间浪费到了短视频上。 来自👩[1]：不同以往的是，我在2020年底因为诸多因素收获了一个👩，所以给朴素的一月增添了许多活力。 [1]👩: 指👩 生日 2021/1/10 每年一趟的生日如期而至，有了👩的我在👩的带领下出去恰饭，由于有👩之前我一向是不咋离校的，一是因为没啥人和我出去，自己出去也没啥意思；二是出去要么就经典石老人，这个我不好评价；所以不得不评价出去恰饭的感觉还挺嗨的。 考试周一如既往的考试周，今年我换了策略，在熟练运用markdown技术后我心血来潮用markdown结合课件开始猛整复习资料，结论是吊用没有。有些cv的东西你cv了也没啥印象，打印了之后排版大量的空余也让我懒得翻页，所以不出意外的考寄了，让疫情给高分后重新带给我的信心又瓦了[2]。 [2] 瓦了：指无了 二月 今年的寒假比往年的寒假充实一点、、 MCM[1] [1] MCM: The Mathematical Contest in Modeling，指美国大学生数学建模竞赛，又名水赛 往年的寒假对于我来说确实是纯纯的假期，但是总有人利用这段时间偷偷学习。正如山东省实验中学校长，党委书记韩相河在开学典礼上的重要讲话：“不怕同学是学霸，就怕学霸放书架[2] ”，我深感赞同。但是今年心血来潮，决定碰碰运气，于是开始进行建模速成[3]。赛前，我做好了充分的时间规划，假装自己是个高手。 最终赛时在两位👴的带领下按照计划，完成了由(&gt;60%)Google翻译构成的、图文并茂的《论真菌》[4]，通篇看起来极为唬人。当晚按时上交，直接倒头就睡，寒假学习之旅告一段落，实际上学了也没啥用。 [2] 书架：通”暑假“，韩相河校长精通山东某地口音，故其讲话声调抑扬顿挫 [3] 建模速成：指观看Blibili《美赛速成》等培训视频(&lt;=2)；一方面配置SumatraPDF+WinEdt的LaTex论文环境、学习LaTex语法；一方面知乎研读往年O奖论文(&lt;=3)，并深感震撼于笔者出色的排版、绘图和美工技术；一方面观看动画片《喜羊羊与灰太狼之筐出胜利》，太精彩了属于是 [4] 《论真菌》：赛时笔者队伍所选的A题为真菌相关的建模，论文具体标题为《XXXX模型：XXXXXX》，文采藻饰，臭词乱拽，看起来很JB高级实则都是屁话 春晚春晚小品就是个寄，不予评价。 三月 开学，再见👩，动物园之旅，第一次感受海底捞 海底捞确实服务比较嗨，但是那个生日歌尬也是尬 四月 一些演出 蓝莲花Bass康复训练的曲目，没啥难度，全是loop😅，但是好久没上过台了，还是起到了丶热身的作用 Take On me 大艺团合唱团最后的谢幕，只能说有点遗憾吧，几首阿卡到最后也没过一次bass solo 6人的阿卡贝拉，排练了很久的一首快歌，从一开始的进度缓慢、产生的一些争执、再到最终演出时舞台的一些设施原因，整个过程并没有那么顺利，但是也是一次美好的经历，演出的效果也还不错 《Take On Me》 The Dawn仍记得小时候听过亡灵序曲的钢琴版，当时深感震撼，如今复刻了一下也可以说是一种致敬 1丶惊喜Meritorious Winner，一个普通的早上醒来，闲的没事干查了查MCM结果，直接从床上坐了起来 只能说是参赛即退役，但没想到这竟是今年所有竞赛的绝唱😅 五月 至今仍在后悔，悔于自己的废物，但后悔又有什么用呢？ 败走银川 众所周知，ACPC[1]银川站就是个笑话[2]。在2021年之前，银川的牌子是公认含金量最低，也是最好拿牌的赛站，但是👴在这里打铁了 ”金川银川，不如👴的铁川。“ 2021/5/14 青岛的晚上大雨滂沱，我匆匆从打印店打好最后的板子，登上了离开的出租车，与指环王，杰宝[3]踏上了离开的旅程。 由于一大早的飞机，所以我们在机场附近找个了私❤️人❤️影❤️院❤️勉强度过一夜，在那里第一次邂逅了情趣礼盒，三个血气方刚的年轻人表示十分的好奇。然后就是一顿瞎JB吹水，这毕竟是我们带学生涯的第一场现场赛，确实比较激动。 2021/5/15 飞机起飞，降落。 终于来到了一个新的城市，一出机门就能看到冒着红光的枸杞宣传板，城市文化了属于是。 随后就坐上了前往石嘴山(即宁理所在城市)的面包车，一路上的景色并不能算得上是什么景色，听说还有什么沙湖游的安排，比较激动，但是后面给取消了😅，现在搜了一下居然是AAAAA级景区，🐴的，亏了。 中午去学校报道，有两个个小改改[4]带着我们简单参观了一下，不得不说，确实挺大，学校就像在一个小岛上一样，周围被不知道是湖还是河的东西围起来，比较空旷加上风还挺大，所以感觉穿的还有点少，挺冷。后来领了个礼袋，里面除了参赛服就是一盒包装还算可以的枸杞，想了想我也用不上这玩意，正好带回家去。临走的时候看见有广播站的在那里拿着个麦克采访，心血来潮和个楞b一样就上去了，说了几句尬话加了个宁理之声广播站的vx润了。 下午热身赛，四道题全给A了，结果判题机炸了，一直不给判，榜也卡着，然后待了一会就润了，想着回去溜达溜达吃顿好的🤡。 晚上🔒棒子骨，恰羊蝎子，有点辣但属实嗨🤡，随后采购了点本地特产，提了一大兜子回了宾馆，静待第二天的正赛。 2021/5/16 早上满怀ak的斗志去了，坐下凳子，发现昨天热身赛榜上“中国海洋大学 没有显卡能打ACM吗 rk7[5]”，有点激动，随后悄么声地把页面关掉，静静等待比赛开始。 比赛过程不想说了，大量的无用思考，全场最签到的一道题三个人九牛二虎之力读了无数遍都读清楚题意WA[6]32也没过，然后有道题卡了行末空格白WA了6，最后时间走完，都没来得及看字典树的简单题，铁了。 我们达成了了几乎很难达成的银川打铁的成就，灰头土脸地逃回了青岛。 除了自己菜，没什么好说的、距今已260天，警钟长鸣。 [1] ACPC：指ACM-ICPC亚洲区域赛，ACM-ACPC为本场开幕式上发言人的逆天口语表达 [2] 笑话：主办方宁夏理工学院乃我国西部枢纽，如何看待 2021 年 ICPC 银川赛区主办方宁夏理工学院获得一金一银？，有三人三机（比赛中应三人一机），更有沈阳站撤硕过题（如何评价宁夏理工学院TS1队参加ICPC沈阳站，并在上厕所后做出了H题？）, 不好评价 [3] 指环王、杰宝：指两名队友，指环王网名脂环，小名我爹，杰宝取自于真名的尾字 [4] 小改改：值小姐姐 [5] 没有显卡能打ACM吗 rk7：前者指鄙队队名，后者指排名即rank [6] WA：指Wrong Answer，对题目的错误提交，后跟数字表示错误提交的次数 摇滚之夜月末，乐队参加了我校吉他社的摇滚之夜，也算是为下个月的各大演出做了提前的一次彩排，效果不错，在这里不多赘述。 六月 演出月、考试月、欧洲杯 山东大学“六月的风” 2021/06/06 应邀参加山带（青岛）“六月的风”毕业歌会，整了个蓝莲花和 It’s my life，坐了五十分钟地铁终于到了山带，虽然在更偏远的郊区但是不得不说建的真是气派，宿舍条件也比我校好（基本没有比我住的地方烂的），里面整了个三层小商圈，卖的东西应有尽有属实看的眼馋。 这次歌会在一块小足球场举行，草皮也是真好，也可能是新建的但是确实好，比得上省体的那个足球公园刚建好的时候那草皮质量，那些设备确实弄的也挺高级，还有两块投屏，和网上直播显示的画面是同步的。下面也的场地也布置的挺好的，只能说是见了世面，毕竟咱也没来过这种露天的演出😅 演出开始。因为接设备需要时间，所以👴即兴发表了一段演讲，大有两校情谊长存之意，实属全是屁话。但是这段宣言全被直播出去了，实属被当场逮捕，现在搜一下录像看还是觉得很尬😅，演完了领了点饭钱润了。 演出效果还行，就是导播不大懂乐队可能，看别人演加州旅馆吉他solo的时候一直给节奏镜头😅😅😅 Livehouse 2021/06/12 DMC 本来想的是个So Downtown[1]一样的带Livehouse，去了才发现是个小酒吧，但是那个音箱确实蛮好的，现场来了很多很好的朋友，气氛也挺嗨的，感受到了大合唱环节，在台上会进入一种忘我的境界，我很享受。在这个账号上我们发布了当天的录像，再体味一遍还是不错的，这算是今年乐队正式演出的完美谢幕吧。(下半年因为大家的时间赶不到一起去，所以暂时停排) [1] So Downtown：青岛某知名Livehouse 欧洲杯葡萄牙的比赛一场不落的看完，确实场面不太好看，踢德国那场也确实被干碎了，淘汰也是情理之中，没想到的是死亡之组法德葡八强全寄了😅 考试月经历了上次考试的惨痛教训，这次我又恢复了手写提纲的方法，修习了三大数学(即离散数学、线性代数、概率统计)的我最后从结果来看整体差强人意，就是课有点多，有几门摆烂了，复习的很少或者是没复习，果然寄了😅，但是整体而言较于上学期还是有了一定的进步 七月 一些生活碎片 体验生活回家了一阵后在青岛体验生活，如题，不详述。 NBA Final伴随cp3和Suns一路走来，打到总决赛已经非常惊喜，虽然最后不敌，虽然有一些裁判和球员的其他原因，但是还是比较满足的，毕竟不可能有这么一帆风顺的旅程，失败永远是人生的主旋律，重头再来吧。 训练在找到稳定的生活节奏前，按时打了Nowcoder多校的训练赛还有HDU的多校联赛，中间打了两三场百度⭐⭐，最后止步复赛。虽然每次都是一个受到打击的过程，但是这也帮助我更有效的认知自己的水平，但是回头来看，做题不补题相当于白打😅 八月 一些锐评 东京奥运虽然奥运会确实是那种让大家都能乐呵起来的大会，带🔥互相聊聊也是没啥毛病的，但是诸如朋友圈、微博等等社交平台上某些啥都不懂就在那乱评头论足蹭热度的我的评价是纯属啥b、、 👩’s Birthday 2021/08/14 准备了挺久的👩生日如期而至，我只能说我准备的礼物确实是纯纯的别出心裁。 CR7老特拉福德的宠儿重新回到了梦剧场，主队从JUV换到了MNU，虽然热血沸腾，但下半年的曼联似乎是纯纯的🤡。 九月 开学啦、、 Web框架编程让我知道了不少高分低能神人的存在，确实不能理解😅😅，不会又不学就开始当乞丐我真笑嘻了😅 国赛建模国赛，狗都不打。本就不想参加但还是打扰了三天的作息😅😅 藏书票修了一门叫做 大学美术鉴赏 的通识课，里面有一项作业是每周手画一张藏书票，我觉得还蛮有意思的，花上三个小时静心完成一幅作品确实已经很久没干过了，让我找回了小学初中的那种感觉。 十月 旧的不去，新的不来 👋，旧手机 2021/10/10 打了场CCPC网络赛，打完发现旧手机寄了。 这里谈一下我的旧手机，它是高考结束后来到的我的身边。仅仅7天，一次出门在外，追赶公交车的时候，眼见着我就要到公交车门前，发生了以下的默剧： ​ “！！！”（师傅开门，让我上车！） ​ “…” (手指地面) ​ “？？！！” （开门啊？我要上车啊！） ​ “…” ​ “…！” （发现手机倒扣在地上） ​ “！！！” (woc！正面碎烂了！) ​ “…” （公交车驶向远方） 大致的过程就是手机干碎了，公交车也跑了，达成双赢。由于手机是刚买的，问了一下修个屏要五伯，修两三次就够我再买一个了，于是我决定节俭下去不修，这就导致了一些和我共事的人见到我的手机都要啧啧称奇，这一用就是两年。 终于，在这天下午，我发现它的屏幕解锁后，只需要五秒，就会逐渐变黄，再过五秒，整个屏幕就变成了一些明暗交织的条带，如同天上的银河。 于是，我告别了它。 Vlog👶🏻横空出世换了录像设备的我如题，剪了一个还不错的Vlog并且深深陶醉其中。 十一月 憧憬就是用来打破的 EDG 2021/10/07 EDG 3-2 战胜了DK，夺得了s11的冠军。 带着👩去操场感受线下观赛的热血，第一把赢了已经出乎意料，现场气氛来到了高潮，但是二三局的失利又让我有些失去信心，结果EDG居然没让淀粉失望，最终翻盘夺冠。 从s5开始当淀粉[1]，六年了，终于爽了一把，晚上刷了半天新闻才睡，纯嗨。 [1] 淀粉：指EDG的粉丝，EDG又被戏称“中国电竞”，故粉丝群体被称为淀粉即“电粉” 海超[2] [2] 海超：海超，全称“中国海洋大学足球超级联赛” 继刚打一场就胎死腹中的新生杯完成的帽子戏法给予我信心之后，我加入了院队，迎来了海超联赛。 作为从信院租借到管院的球员第一场面对旧主被干了个7-0😅，有点无力又深深忏悔于自己的失误。 紧接着在冷风吹着的小雨中迎来了第二场面对法学院的比赛，这场我改变了一些打法，想通过减少带球来增加一脚出球和无球跑动来扰乱对手的后防线，效果还是有一些的。最终4-2有惊无险，没有收获进球但是有一脚助攻，不过也是浪费了三次近在咫尺的良机，前两次是没有把握准第二点，中场前的一脚抽射也是因为左脚没有站稳导致力道不足，比较遗憾，但是那种享受比赛的过程还是令我热血澎湃，没想到的是在雨里懂了俩小时回去居然没有感冒，彳亍。 败走上海 2021/11/28 ICPC亚洲区预赛上海站，线上赛，就在信院打，最终打铁，没什么好说的，能力不足就是能力不足。 准备了很久的字符串没有派上用场，最终被两道DP[3]卡了，事实证明，做出这两道DP也没有什么用，毕竟上海站已经卷到了五题铜牌，还是需要努力，希望下次不留遗憾吧。 [3] DP：Dynamic Programming，动态规划，一种算法 十二月 急 CCSP参加了CCSP的分赛，最后10分钟过了B题30分，最后拿了个华东赛区rk71铜首[1]，校排第5。 虽然结果确实令我血压升高，这种铜首的事也能轮到我头上😅，但是整体而言对结果已经较为满意，毕竟卡了这么久，没啥毛病，继续努力吧。 [1] 铜首：指铜牌第一名，rk70银但rk71铜 软件工程 永远不要和废物组队。 这门课就像他的名字一样，平时是要进行小组分工完成一个项目作为评分指标，我们的项目是完成对图片的20种目标检测。 鄙组由5名成员组成，实则由两名成员组成，我和阿昊，他来完成模型的训练，我来完成GUI界面，说来也惭愧，我这部分的分工明显简单于他，他为这个项目确实付出了最多。 因为我最熟悉C++，于是就想把用pytorch训练的模型移植到通过 libtorch+opencv+msvc+qt 来实现GUI的编写，结果配了好几天的环境，发现模型部分功能的实现libtorch是不支持的，只能卷土重来。时间流逝，当我重新配好pyqt的环境开始动手编写时，距离考试周已经时日不多。 剩下几位b用没有，一边说着不会，“我也知道，我要是会我肯定干点什么”之类的屁话，一遍p也不学，开始了自己的期末复习。 这令我十分烦躁，我是不是不复习啊，我他吗是不是就是纯雷锋非得做好事啊，最后项目我们俩干了半天，到头来最后一个个的都比我们分高或者和我们一样，凭什么呢，他们配吗？于是就剩一天的时候，我们甩了脸，让他们学着干一些事情，比如配置服务器这种简单的事情。虽然心里想着他们肯定干不完，但是至少也得出点力，于是把任务布置了下去，还抱有一丝念想。结果是：——在一整天的时间，有人配了一个小时没配明白就放弃了，有的人根本没怎么看。 在这个过程中，要么是像巨婴一样问低级问题，要么就是开摆，连搜都懒得搜。不想再做评价了。 最后项目的结果是：我俩完成了分内的工作，但是项目的完成度比目标来说只达成了60%，勉强及格罢。 引用 Eric Steven Raymond 在《提问的智慧》中的话结尾： 我们只是毫无歉意地鄙视那些提问前不愿思考、不做功课的人。这种人就像时间黑洞一样，只知道索取，不愿意付出，他们在浪费我们时间，而这些时间我们本可用于其他更有趣的问题或更值得回答的人身上。我们将这种人叫做 loser。 总结 非常简略的总结 迷茫迷茫于自己的未来，迷茫于自己的当下，迷茫于自己的选择，迷茫于对错。 轮廓我似乎渐渐摸清了不远的未来的轮廓，对自己轮廓的描绘也越来越清晰，跟不同人之间的轮廓的区分。 展望克制，规律的作息，扎实地前进。 很荣幸你能够忍受着我抽象的文字、像怨妇一样的抱怨、和一些难听的诋毁看到这里，谢谢你我的朋友，2022新年快乐。","categories":[{"name":"LIFE","slug":"LIFE","permalink":"https://maskros.top/categories/LIFE/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://maskros.top/tags/Life/"}]},{"title":"Educational Codeforces Round 122 (Div.2)","slug":"codeforces/cf Edu 122","date":"2022-01-31T10:00:00.000Z","updated":"2022-02-15T10:05:03.753Z","comments":true,"path":"/post/codeforces/cf Edu 122.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20122.html","excerpt":"Educational Codeforces Round 122 (Div.2)","text":"Educational Codeforces Round 122 (Rated for Div. 2) vp A_Div_7 签 void solve() { int n; cin &gt;&gt; n; if(n % 7 == 0) cout &lt;&lt; n &lt;&lt; '\\n'; else{ if(n &gt;= 990) cout &lt;&lt; 994 &lt;&lt; '\\n'; else { n -= n%10; while(n % 7 != 0) n++; cout &lt;&lt; n &lt;&lt; '\\n'; } } } B_Minority 签 void solve() { string s; cin &gt;&gt; s; int one = 0, zero = 0, ans = 0; rep(i, 0, s.size()){ if(s[i] == '0') zero ++; else one ++; ans = (one == zero)? ans : min(one, zero); } cout &lt;&lt; ans &lt;&lt; '\\n'; } C_Kill_ the_Monster 枚举k的分配种类即可 ceil(double x) ：double 类型向上取整 void solve() { double hc, dc, hm, dm, k, w, a; cin &gt;&gt; hc &gt;&gt; dc &gt;&gt; hm &gt;&gt; dm &gt;&gt; k &gt;&gt; w &gt;&gt; a; rep(i, 0, k+1){ double hhc = 1.0 * i * a + hc; double ddc = 1.0 * (k - i) * w + dc; if(ceil(hm / ddc) &lt;= ceil(hhc / dm)){ cout &lt;&lt; \"YES\\n\"; return ; } } cout &lt;&lt; \"NO\\n\"; } D_Make_Them_Equal (dp) 题意： 给定一个长为 的数组 ，初值全为 ，你可以做这样的操作：选择 和 (x&gt;0) ，然后使 如果操作后 ，你将得到 的奖金，你需要在 次操作内使得奖金最大化，输出奖金的最大值。规定 , 思路： 从 到 的次数是固定的，根据 的范围，我们可以打表预处理每个数的操作次数，然后考虑01背包，dp[i][j]表示前 i 个耗费为 j 的最大奖金，但是开1e6肯定会T，观察打表结果发现最大值为 12，这样可以优化一下dp的范围。 int b[1005], c[1005]; int pre[1005]; // 1 -&gt; 1000 打表 max = 12 void init() { pre[1] = 0; rep(i, 1, 1001) { rep(j, 1, i + 1) { int tmp = i + i / j; if(tmp &lt;= 1000) pre[tmp] = pre[tmp] ? min(pre[tmp], pre[i] + 1) : pre[i] + 1; } } } int dp[12005]; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 1, n + 1) cin &gt;&gt; b[i], b[i] = pre[b[i]]; rep(i, 1, n + 1) cin &gt;&gt; c[i]; int ans = 0; if(k &gt;= 12 * n) { rep(i, 1, n + 1) ans += c[i]; }else { rep(i, 0, 12 * n) dp[i] = 0; rep (i, 1, n + 1) { red(j, k + 1, 0){ if(j - b[i] &gt;= 0) dp[j] = max(dp[j], dp[j - b[i]] + c[i]); else break; } } ans = dp[k]; } cout &lt;&lt; ans &lt;&lt; \"\\n\"; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"}]},{"title":"2022牛客寒假算法基础集训营2","slug":"nowcoder/2022winter/round2","date":"2022-01-30T13:30:50.000Z","updated":"2022-02-24T06:40:23.350Z","comments":true,"path":"/post/nowcoder/2022winter/round2.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round2.html","excerpt":"","text":"2022牛客寒假算法基础集训营2 AC 6 / 12 我是纯废物 *A 小沙的炉石(二分/结论) 题意： 小沙当前的手上有n张法术进攻牌，每张牌都会消耗一点法力，造成一点基础伤害，有m张法术回复牌，不需要消耗法力值，每次可以恢复一点法力。小沙一开始有一点法力，法力没有上限。法术进攻牌的伤害值=当前出的是第几张牌。k次询问，每次询问一个血量x，问能否做到伤害刚好等于血量值，即刚好斩杀。 题解：二分是朴素写法，结论也很好证明，证明如下： 首先我们要证明一个点，对于使用攻击牌是一个定值的话，我们的攻击范围是一个区间上的任意的伤害值：当我们的攻击牌使用次数为a，蓝量使用牌为b时，对于a&lt;=b+1，我们的最小攻击一定为攻，回复，攻，回复…..直到用完所以攻击后补全回复。可得等差数列，求和可得 。在最小攻击的基础上，我们可以将任意一个攻击牌的位置和他后面的回复牌的位置交换，使得伤害+1。最后可得最大伤害为：回复，回复…..攻，攻，攻…..最大，可得等差数列 ,求和可得 void solve() { ll n, m, k, x, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; n = min(n, m + 1); for (int i = 0; i &lt; k; i++) { cin &gt;&gt; x; q = sqrt(x); if (q &gt; n) q = n; if (x &lt;= q * (2 * m + q + 1) / 2) puts(\"YES\"); else puts(\"NO\"); } } C 小沙的杀球 水题 void solve() { ll x,a,b; cin&gt;&gt;x&gt;&gt;a&gt;&gt;b; int ans=0; string s; cin&gt;&gt;s; int len=s.length(); rep(i,0,len){ if(s[i]=='0') x+=b; else{ if(x&gt;=a) {x-=a; ans++;} else x+=b; } } cout&lt;&lt;ans; } *E 小沙的长路 (图论/欧拉图) 题意： ​ 阶竞赛图(可以自定义每条边的方向)，每条边只能走一次，询问最长路径的最小值和最大值 题解： 最长路的最小值：。如果图上有环，那么我们肯定能尽可能多的走环，这样的话我一定会比我不走环更长，所以我们构造的图要尽可能的没环。在没环的情况下，我们只会经过每个点各一次，所以总长度是 最长路的最大值： 为奇数： ; 为偶数： 。我们考虑尽可能的将每一条路都走遍，我们可以理解为对一个完全图进行删边，我们需要删尽可能少的边，从而使他能够从头走到尾，也就是构造出一个欧拉回路。又由欧拉回路的定义可知，我们需要将每个点的出入度控制为偶数即可组成欧拉回路，所以奇偶特判即可。 (TIPS: 删去 即为使原图仅有两个奇度顶点构成欧拉图) void solve() { ll n; cin&gt;&gt;n; ll mx,mn; mn=n-1; if(n&amp;1) { mx=(n-1)*n/2; }else{ mx=n*(n-1)/2-(n-2)/2; } cout&lt;&lt;mn&lt;&lt;\" \"&lt;&lt;mx; } F 小沙的算数 (模拟/桶/逆元) 题意：给定仅有+和×的算式，q次询问，每次将第x个算数变为y，问每次修改后原式的值为多少？答案对1e9+7取模 题解：由于运算有优先级，每个+分开各个区间，提前将区间内的信息整合到数组里保存，然后进行计算即可，需要用逆元处理除法 int a[maxn], pos[maxn]; ll res[maxn]; ll quickpow(ll a, ll b) { ll ans = 1; ll res = a % mod; while (b) { if (b &amp; 1) ans = ans * res % mod; b &gt;&gt;= 1; res = res * res % mod; } return ans % mod; } ll inv(ll x) { return quickpow(x, mod - 2); } void solve(){ int n, q; cin &gt;&gt; n &gt;&gt; q; char c; int tmppos = 1; rep(i, 1, n) { cin &gt;&gt; c; if (i == n - 1) { if (c == '+') { pos[i] = tmppos; pos[i + 1] = tmppos + 1; } else { pos[i] = tmppos; pos[i + 1] = tmppos; } } else { if (c == '+') { pos[i] = tmppos; tmppos++; } else { pos[i] = tmppos; } } } ll ans = 0; ll tmp = 1; tmppos = 1; rep(i, 1, n + 1) { cin &gt;&gt; a[i]; if (pos[i] == tmppos) { tmp = (tmp * (a[i] % mod)) % mod; } else { ans = (ans + tmp) % mod; res[tmppos] = tmp; tmp = a[i] % mod; tmppos++; } } if (tmppos == pos[n]) { ans = (ans + tmp) % mod; res[tmppos] = tmp; } int x, y; rep(i, 0, q) { cin &gt;&gt; x &gt;&gt; y; tmppos = pos[x]; ans = (ans - res[tmppos] + mod) % mod; res[tmppos] = (res[tmppos] * inv(a[x] * 1ll) % mod * y) % mod; ans = (ans + res[tmppos]) % mod; a[x] = y; cout &lt;&lt; ans &lt;&lt; endl; } } H 小沙的数数 (位运算) 题意： 有一个a数组，我们已知他的长度为n，a[+]的和为m，请问如果我们想要a[⊕]的值最大，数组a在满足a[+]=m时有多少种情况？我们定义a[+]指a1+a2….ana_1+a_2….a_na1+a2….an的值；a[⊕]指a1a_1a1⊕a2a_2a2⊕a3a_3a3….an….a_n….an的值，a数组全部为非负整数 题解： 由于在二进制拆位最后同位情况下如果存在不止一个一，那么异或之后的贡献一定小于我们的费用，所以我们要保证对于每一位的个数要么是0，要么是1，这样的话才能保证a=a[+]，随后我们发现对于每一位来说，他们均不相互干扰，那么他们可能产生的情况便都是n种，所以我们只需要求二进制下m有多少个1，随后求n^x次方即可 int foo(ll x) { //计算二进制有多少个1 int count = 0; while (x) { count++; x = x &amp; (x - 1); } return count; } ll quickpow(ll a, ll b) { ll ans = 1; ll res = a % mod; while (b) { if (b &amp; 1) ans = ans * res % mod; b &gt;&gt;= 1; res = res * res % mod; } return ans % mod; } void solve() { ll n,m; cin&gt;&gt;n&gt;&gt;m; int base=foo(m); ll ans = 0; if(base==1) cout&lt;&lt;n%mod; else cout&lt;&lt;quickpow(n,base)%mod; } I 小沙的构造 构造题，贪心构造即可 string all=\"\\\"!\\'*+-.08:=^_WTYUIOAHXVM|\"; //25 string db=\"&lt;&gt;\\\\/[]{}()\"; //10 char s[maxn]; void solve() { int n,m; cin&gt;&gt;n&gt;&gt;m; if(m==36 || n&lt;m) {cout&lt;&lt;-1; return;} int have=0; int dbpos=0,allpos=0; bool add=true; rep(i,0,n/2){ if(have&lt;m){ if(dbpos&lt;10 &amp;&amp; have+2&lt;m){ s[i]=db[dbpos]; dbpos++; s[n-1-i]=db[dbpos]; dbpos++; have+=2; }else{ s[i]=all[allpos]; s[n-1-i]=all[allpos]; have++; if(have&lt;m) allpos++; } }else{ s[i]=all[allpos]; s[n-1-i]=all[allpos]; add=false; } } if(n&amp;1){ s[n/2]=all[allpos]; if(add) have++; } if(have&lt;m) {cout&lt;&lt;-1; return;} rep(i,0,n) cout&lt;&lt;s[i]; } K 小沙的步伐 水题 void solve() { string s; cin&gt;&gt;s; int len=s.length(); int a[15]; mem(a,0); rep(i,0,len){ if(s[i]=='5'){ continue; }else{ a[5]++; int tmp=int(s[i]-'0'); a[tmp]++; } } rep(i,1,10){ cout&lt;&lt;a[i]&lt;&lt;\" \"; } } 待补…","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"图论","slug":"图论","permalink":"https://maskros.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"逆元","slug":"逆元","permalink":"https://maskros.top/tags/%E9%80%86%E5%85%83/"}]},{"title":"Codeforces Round 768 (Div.2)","slug":"codeforces/cf 768","date":"2022-01-29T10:30:00.000Z","updated":"2022-01-29T13:27:03.905Z","comments":true,"path":"/post/codeforces/cf 768.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20768.html","excerpt":"Codeforces Round 768 (Div.2)","text":"Codeforces Round #768 (Div.2) 康复训练第二场cf A_Min_Max_Swap 水题，模拟 int a[200],b[200]; void solve() { int n; cin&gt;&gt;n; rep(i,0,n) cin&gt;&gt;a[i]; rep(i,0,n) cin&gt;&gt;b[i]; rep(i,0,n){ if(a[i]&lt;b[i]) swap(a[i],b[i]); } sort(a,a+n); sort(b,b+n); cout&lt;&lt;a[n-1]*b[n-1]&lt;&lt;endl; } B_Fun_with_Even_Subarrays 题意： 给一个序列，规定操作：选择起点为l将长为k的序列用它相邻的下一个长为k的序列覆盖，问最少经过多少次操作才能使序列中所有数相同？ 思路： 同样粗略地模拟一下，从序列尾部向前反推即可 int a[maxn]; void solve() { int n; cin&gt;&gt;n; rep(i,0,n){ cin&gt;&gt;a[i]; } if(n==1) cout&lt;&lt;0&lt;&lt;endl; else{ int sd=a[n-1]; int len=1; int ans=0; red(i,n-1,0){ if(a[i]==sd){ len++; } else{ ans++; i=i-len+1; len*=2; } } cout&lt;&lt;ans&lt;&lt;endl; } } C_And_Matching 题意： 给定 , , 要求将 构造出 对 ，满足 ​ 规定 是 2 的幂， 思路： 一开始因为读题漏掉了规定条件导致一时没法做，一定要仔细读题。 可以找到规律：序列首尾依次做AND操作一定为0，不妨将 与 相与，因为 必定所有位都为1，所以与值为 。然后再首尾依次相与，原本理应与 相与的数使它与0相与即可。特别的，当 时，特殊考虑一种组合方法即可。 void solve() { ll n,k; cin&gt;&gt;n&gt;&gt;k; if(n==4&amp;&amp;k==3) cout&lt;&lt;-1&lt;&lt;endl; eif(n-1==k){ cout&lt;&lt;n-2&lt;&lt;\" \"&lt;&lt;n-1&lt;&lt;endl; cout&lt;&lt;1&lt;&lt;\" \"&lt;&lt;n-3&lt;&lt;endl; cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;2&lt;&lt;endl; rep(i,3,n/2){ if (i == n - 2 || i == n - 1 || i == n - 3 || n - i - 1 == n - 1 || n - i - 1 == n - 2 || n - i - 1 == n - 3) continue; else cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;n-i-1&lt;&lt;endl; } } else{ cout&lt;&lt;k&lt;&lt;\" \"&lt;&lt;n-1&lt;&lt;endl; rep(i,1,n/2){ if(k!=i &amp;&amp; k!=n-i-1){ cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;n-i-1&lt;&lt;endl; }else{ if(k==i){ cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;n-i-1&lt;&lt;endl; }else{ cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;i&lt;&lt;endl; } } } } } D_Range_and_Partition 题意： 给定一个长为 的序列 ，找到一系列区间 (x&lt;=y)，将序列 分为 个子序列，要求每个序列中在区间 的数严格大于在区间外的数，要求最小化 规定 k&lt;=n&lt;=2e5 思路： 由题可知， 段中每一段在区间的数的数量至少比不在区间内的数的数量多1, 并且只要整个数组满足整个条件那么一定存在将数组分成k段仍然满足的方法。判断条件：设整个数组中在区间内的数的数量为 num，不在区间内的为n-num。只要num-(n-num)&gt;=k即满足条件。于是我们枚举区间的左边界，二分求解满足条件的最小右边界即可。 :::tip 当发现 、最小化差值对象、数据范围为2e5时，我们首先考虑： （1）尺取法(双指针) （2）结论题 （3）枚举一端，另一端 log/O(1) 复杂度 ::: #define maxn 200005 using namespace std; int n,k,a[maxn]; int vis[maxn]; void solve() { cin&gt;&gt;n&gt;&gt;k; mem(vis,0); rep(i,1,n+1){ cin&gt;&gt;a[i]; vis[a[i]]++; //计数 } rep(i,1,n+1) vis[i]+=vis[i-1]; //前缀和统计区间计数 int x=1,y=n; rep(i,1,n+1){ //枚举区间左边界 int l=i, r=n; int num=vis[r]-vis[l-1]; if(num-(n-num)&lt;k) break; // 不存在以i为左边界的合法区间 while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; num=vis[mid]-vis[i-1]; //区间范围内的数 if(num-(n-num)&gt;=k) r=mid-1; else l=mid+1; } if(l-i&lt;y-x){ x=i; y=l;} } cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl; for(int l=1,r=1; l&lt;=n; l=r+1,r=l,k--){ if(k==1){ cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;n&lt;&lt;endl; break; }else{ int cnt1=0, cnt2=0; while(1){ if(a[r]&gt;=x &amp;&amp; a[r]&lt;=y) cnt1++; else cnt2++; if(cnt1&lt;=cnt2) r++; else break; } cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; } } } 反思：一场不如一场，寄","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"2022牛客寒假算法基础集训营1","slug":"nowcoder/2022winter/round1","date":"2022-01-25T15:30:50.000Z","updated":"2022-01-26T04:46:37.746Z","comments":true,"path":"/post/nowcoder/2022winter/round1.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round1.html","excerpt":"","text":"2022牛客寒假算法基础集训营1 AC 9 / 12 *A 九小时九个人九扇门 (dp (0/1背包)) 题意：n 个人，每个人有一个数字 a[i]，可以随意组合，组合起来为数字的加和。一共1~9号门 ，如果组合后的数字根等于门的序号，即可打开。问分别有多少种人物组合可以打开对应的门。数字根：将该数字各数位上的数字相加得到一个新的数，直到得到的数字小于10为止。 有用的结论：一个数的数字根等于这个数对9取模的结果(得0时数字根为9) 思路： 经典0/1背包变形的DP问题，dp[i][j]表示考虑了前 i 个数，选择了一些数字使得求和对9取模得 j的方案数，转移类似0/1背包的转移 // 数字根 = 本身 mod 9 int a[maxn]; int dp[maxn][15]; void solve(){ int n; cin&gt;&gt;n; int t; rep(i,1,n+1){ cin&gt;&gt;t; a[i]=t%9; } dp[1][a[1]]=1; rep(i,2,n+1){ rep(j,0,9){ int k=(j+a[i])%9; dp[i][k]=(dp[i-1][k]%mod+dp[i-1][j]%mod)%mod; } dp[i][a[i]]++; } rep(i,1,10){ if(i==9) cout&lt;&lt;dp[n][0]; else cout&lt;&lt;dp[n][i]&lt;&lt;\" \"; } } C Baby’s first attempt on CPU 题意：计组学过的流水线CPU，解决先写后读相关问题需要中间插入空语句，共n个语句，每个语句三个数字表示和前1/2/3条语句是否存在先写后读相关，总共需要插入多少空语句 题解：水题，当时为了时间乱jb写的，无参考价值；维护三个dis表示和前1/2/3条语句的间隔条数，分类判断即可。 void solve() { int x1,x2,x3; int n; scanf(\"%d\", &amp;n); int ans=0; int dis1=0,dis2=1,dis3=2; rep(i,0,n){ scanf(\"%d%d%d\",&amp;x1,&amp;x2,&amp;x3); if(x1==1) {ans+=3; dis2=4; dis3=5;} eif(x2==1) { if(dis2&gt;=3){dis3=dis2+1; dis2=dis1+1; dis1=0; } else { ans+=(3-dis2); dis2=4-dis2; dis3=3; } }eif(x3==1){ if(dis3&gt;=3) {dis3=dis2+1; dis2=dis1+1; dis1=0;} else{ ans+=(3-dis3); dis2=4-dis3; dis3=4; } }else{ dis3=dis2+1; dis2=dis1+1; dis1=0; } } cout&lt;&lt;ans&lt;&lt;endl; } D 牛牛做数论 (欧拉函数) 题意： 定义对于正整数 , ，给定一个整数 ，分别求 使得 分别取最大值和最小值 题解： ① 根据欧拉函数的性质，我们知道如果 为质数，则 ，此时 ​ 即取最大值； ② 欧拉函数可以根据质因数分解求得： , 回看 ，发现可以约掉 ，故可知是由质数依次相乘一定是最小值: ，故可筛出质数后遍历质数表即可。 const int MAXN = 10000; int prime[MAXN + 1]; void getPrime() { memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= MAXN; i++) { if (!prime[i]) prime[++prime[0]] = i; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++) { prime[prime[j] * i] = 1; if (i % prime[j] == 0) break; } } } bool isPrime(int num) { if (num == 2 || num == 3) { return true; } if (num % 6 != 1 &amp;&amp; num % 6 != 5) { return false; } for (int i = 5; i * i &lt;= num; i += 6) { if (num % i == 0 || num % (i + 2) == 0) { return false; } } return true; } void solve() { int n; cin&gt;&gt;n; if(n==1) {cout&lt;&lt;-1&lt;&lt;endl; return;} int mx,mn=2; red(i,n+1,2){ if(isPrime(i)) {mx=i; break;} } ll tmp=1; rep(i,1,1000){ tmp*=prime[i]; if(tmp&lt;=n) mn=tmp; else break; } cout&lt;&lt;mn&lt;&lt;\" \"&lt;&lt;mx&lt;&lt;endl; } E 炸鸡块君的高中回忆 水题 void solve() { int m,n; cin&gt;&gt;n&gt;&gt;m; if(m==1){ if(n==1) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; return; } int ans; n-=m; int tmp=n%(m-1); ans=n/(m-1)*2; if(tmp!=0) ans+=3; else ans++; cout&lt;&lt;ans&lt;&lt;endl; } F 中位数切分 结论题：如果中位数大于 ，则该列中的大于 的数的个数一定超过一半，划分段数直接等于 大于m的个数 - 小于m的个数，随便推推就知道了。 void solve() { int n,m; scanf(\"%d%d\",&amp;n, &amp;m); int bg=0,sm=0; int t; rep(i,0,n){ scanf(\"%d\", &amp;t); if(t&gt;=m) bg++; else sm++; } if(bg&lt;=n/2) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;bg-sm&lt;&lt;endl; } H 牛牛看云 题意：给出一个序列 , 计算 ，数据范围 n&lt;1e6, 0&lt;=ai&lt;=1000 题解：注意到 n&lt;=1e6 且 a[i]&lt;=1000，知道a[i]范围很小，所以极限数据下会有大量重复值出现，故可以用 cnt[i] 表示 i 出现的次数，枚举(i,j)对(共1e6种)：不同情况直接相乘，特殊处理相同情况 vector&lt;int&gt; v[maxn]; void solve() { int n; cin &gt;&gt; n; ll ans = 0; rep(i, 0, n) { int x; cin &gt;&gt; x; v[x].pb(i); } rep(i, 0, 1001) { rep(j, i, 1001) { ll x = v[i].size(); ll y = v[j].size(); if (i == j) { ans += x * (x + 1) / 2 * abs(i + j - 1000); } else ans += x * y * abs(i + j - 1000); } } cout &lt;&lt; ans &lt;&lt; endl; } *I B站与各唱各的 (概率/逆元) 题意：n个人唱m句，每个人对每一句都可以选择唱或不唱，n个人、m句之间互相独立，如果某一句没人唱或者所有人都唱了则失败，否则成功，求唱成功句子数量的期望值。对1e9+7取模。 题解：​ 由于句子间相互独立，则最终期望为一句话的期望乘 ；每个人唱第每句的唯一策略就是以 的概率决定唱与不唱，所以失败的概率就为 （都唱+都不唱） 当 时，上式取最小值，故失败的概率为 , 故易知成功的概率 注意求逆元, 推式子输出逆元的题比较常见。 ll quickpow(ll a, ll b) { ll ans = 1; ll res = a%mod; while (b) { if (b &amp; 1) ans = ans * res%mod; b &gt;&gt;= 1; res = res * res%mod; } return ans%mod; } void solve() { int n,m; cin&gt;&gt;n&gt;&gt;m; ll a = (quickpow(2,n-1)-1+mod)%mod; a=a*m%mod; ll b = quickpow(2,n-1); ll ans = a*quickpow(b,mod-2)%mod; cout&lt;&lt;ans&lt;&lt;endl; } J 小朋友做游戏 水题 int a[maxn],b[maxn]; int ans = 0; int posa,posb; void goA(){ ans+=a[posa]; posa++; } void goB(){ ans+=b[posb]; posb++; } void solve() { int A,B,n; cin&gt;&gt;A&gt;&gt;B&gt;&gt;n; rep(i,0,A) cin&gt;&gt;a[i]; rep(i,0,B) cin&gt;&gt;b[i]; sort(a,a+A,greater&lt;int&gt;() ); sort(b,b+B,greater&lt;int&gt;() ); ans = 0; if(n&gt;2*A) cout&lt;&lt;-1&lt;&lt;endl; else{ posa=0,posb=0; if(n&amp;1){ rep(i,0,(n+1)/2) ans+=a[i]; posa=(n+1)/2; }else{ rep(i,0,n/2) ans+=a[i]; posa=n/2; } bool AA=true,BB=true; if(posa==A) AA=false; if(posb==B) BB=false; rep(j,posa,n){ if(AA&amp;&amp;BB){ if (a[posa] &gt;= b[posb]) { goA(); }else goB(); if(posa==A) AA=false; if(posb==B) BB=false; }eif(AA){ goA(); }eif(BB) goB(); } cout&lt;&lt;ans&lt;&lt;endl; } } *K 冒险公社(dp) 待补 unsolved L 牛牛学走路 水题 void solve() { int n; cin&gt;&gt;n; char c; double mx=0; double tmp; int x=0,y=0; rep(i,0,n){ cin&gt;&gt;c; if(c=='L') x-=1; eif(c=='R') x+=1; eif(c=='U') y+=1; else y-=1; tmp=sqrt(fabs(x*x)+fabs(y*y)); mx=max(mx,tmp); } printf(\"%.7lf\\n\",mx); }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"euler","slug":"euler","permalink":"https://maskros.top/tags/euler/"},{"name":"逆元","slug":"逆元","permalink":"https://maskros.top/tags/%E9%80%86%E5%85%83/"}]},{"title":"Codeforces Round 767 (Div.2)","slug":"codeforces/cf 767","date":"2022-01-23T05:15:00.000Z","updated":"2022-01-24T04:25:29.824Z","comments":true,"path":"/post/codeforces/cf 767.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20767.html","excerpt":"Codeforces Round 767 (Div.2)","text":"Codeforces Round #767 (Div.2) 荒废了期末考试月的康复训练第一场 A_Download More RAM 水题，排序即可 pair&lt;int,int> pr[105]; bool cmp(pair&lt;int,int> a, pair&lt;int,int> b)&#123; return a.fst&lt;b.fst; &#125; void solve() &#123; int n,k; cin>>n>>k; rep(i,0,n)&#123; cin>>pr[i].fst; &#125; rep(i, 0, n) &#123; cin >> pr[i].sec; &#125; sort(pr,pr+n,cmp); ll tmp=k; rep(i,0,n)&#123; if(tmp>=pr[i].fst) tmp+=pr[i].sec; else break; &#125; cout&lt;&lt;tmp&lt;&lt;endl; &#125; int main() &#123; int T; cin >> T; while (T--) &#123; solve(); &#125; &#125; B_GCD Arrays 题意： 对一个 [l,r] 区间里的数，最多操作k次，每次取两个数，将他们的乘积替代其中一个数放入序列中，问能不能使序列的GCD不为1，能即YES，不能即NO 思路： 粗略的想了一下，乘积之后肯定包含两个原数作为因子，没啥区别，考虑连续区间、奇偶性后，猜测结论：每次操作使奇数*偶数=偶数，将乘积代替奇数，至多k次操作能否使得序列全变为偶数(GCD=2)，注意特判 写的比较仓促，所以比较丑，可以简化= = void solve() &#123; int l,r,k; cin>>l>>r>>k; int ou=0,ji=0; if((r-l+1)&amp;1)&#123; if(l&amp;1)&#123; ji++; &#125;else ou++; ji+=(r-l)>>1; ou+=(r-l)>>1; &#125;else&#123; ou=(r-l+1)>>1; ji=ou; &#125; if(ou==0)&#123; if(l!=1) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125;else&#123; if(ji&lt;=k) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125; &#125; int main() &#123; int T; cin >> T; while (T--) &#123; solve(); &#125; &#125; C_Meximum ArrayMex：一个序列中不存在的最小的非负整数 题意： 给你一个长为n的序列a，每次从a数组的首地址开始选取一段，求mex后将值存入b，随后在a中删去该段。问最终求得的字典序最大的b序列是什么样子的 思路： 模拟（队友用主席树艹过了xD）一个map&lt;int,int&gt; m表示a[i]出现的次数，每次求最大mex的时候即利用该map，删除序列即对map进行操作即可；set&lt;int&gt; S表示从序列开始所有小于mex的数，如果 S.size()&lt;=mex，继续拓展序列的长度就不是最优解，故该位置即作为选取序列的结尾 卡了很久，刚开始想了个n2模拟，结果T了，比较傻逼，后来优化一下就过了 int a[maxn]; map&lt;int, int> m; int check(int start) &#123; rep(i, start, maxn) &#123; if (m[i] == 0) &#123; return i; &#125; &#125; return 0; &#125; vector&lt;int> b; set&lt;int> S; void solve() &#123; int n; cin >> n; int mex = 0; m.clear(); b.clear(); rep(i, 0, n) &#123; cin >> a[i]; m[a[i]]++; if (m[mex] > 0) &#123; mex = check(mex); &#125; &#125; S.clear(); rep(i, 0, n) &#123; if (a[i] &lt; mex) S.insert(a[i]); m[a[i]]--; if (S.size() >= mex) &#123; b.pb(mex); mex = check(0); S.clear(); &#125; &#125; cout &lt;&lt; b.size() &lt;&lt; endl; rep(i, 0, b.size()) cout &lt;&lt; b[i] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; int main() &#123; IOS; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; D_Peculiar Movie Preferences 题意： 给你一堆长&lt;=3的字符串，问能不能通过删掉任意个数的字符串，剩下的字符串按顺序拼接起来为回文串 思路： 沙比题，回文串首尾必定一样，所以如果可以的话最多找两个串即可组成回文串，总长度&lt;=6。首先特判单个串，如果单个回文即为YES；再者分别考虑 2+2/3+3, 2+3/3+2 的情况，特别是后面那一种，这里通过map优化，对字符串做reverse处理，针对不同情况判断即可 TuT map&lt;string,int> mp1,mp2; void solve() &#123; int n; cin >> n; bool can = 0; string s,ss; mp1.clear(); mp2.clear(); rep(i, 0, n) &#123; cin >> s; if(!can)&#123; ss = s; reverse(ss.begin(), ss.end()); if (s.size() == 1) can = 1; eif(s[0] == s[s.size() - 1]) can = 1; else&#123; if(mp1[ss]==1 || mp2[ss]==1) can=1; eif(s.size()==3)&#123; ss.erase(ss.end()-1, ss.end()); if (mp1[ss]) can = 1; &#125; mp1[s]=1; if(s.size()==3)&#123; s.erase(s.end()-1, s.end()); mp2[s]=1; &#125; &#125; &#125; &#125; if (can) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; int main() &#123; int T; IOS; cin >> T; while (T--) &#123; solve(); &#125; &#125; E_Grid Xor 暂时鸽了，出去运动完回来补 构造题 反思：好久不打确实手生+脑残，寒假再接再厉✊","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"利用WeRoBot框架进行微信公众号开发","slug":"note/WeRoBot","date":"2021-12-27T17:24:28.000Z","updated":"2022-01-22T17:29:00.674Z","comments":true,"path":"/post/note/WeRoBot.html","link":"","permalink":"https://maskros.top/post/note/WeRoBot.html","excerpt":"WeRoBot","text":"利用WeRoBot框架进行微信公众号开发 寄网小实验，实现起来不难，记录一下以备不时之需，包括一些对Token的理解 准备微信公众号、云服务器、Xftp&amp;Xshell (Replaceable)、WeRoBot 1.13.1 总体流程step1 : 注册微信公众号 step2 : 通过验证Token将公众号与服务器绑定 step3 : 在服务器代码里加入公众号实现的功能 关于WeRoBot WeRoBot官方文档: link WeRoBot 是一个基于Python的微信机器人框架，采用MIT协议发布。可以将微信服务器发来的消息进行解析和转换，使用 Session 记录用户状态，包括开发自定义菜单等功能，对初学者来讲使用起来也比较简单。WeRoBot 可以作为独立服务运行，也可以集成在其他 Web 框架中一同运行。以下简单举例： 0x01 Hello World# 给收到的每一条信息回复 Hello World import werobot robot = werobot.WeRoBot(token='tokenhere') @robot.handler def hello(message): return 'Hello World!' # 让服务器监听在 0.0.0.0:80 robot.config['HOST'] = '0.0.0.0' robot.config['PORT'] = 80 robot.run() 0x02 消息处理 WeRoBot 会解析微信服务器发来的消息， 并将消息转换成成 Message 或者是 Event 。 Message 表示用户发来的消息，如文本消息、图片消息； Event 则表示用户触发的事件， 如关注事件、扫描二维码事件。 在消息解析、转换完成后， WeRoBot 会将消息转交给 Handler 进行处理，并将 Handler 的返回值返回给微信服务器 @robot.handler #robot 会将所有接收到的消息转交给这个 Handler 来处理 @robot.text # @robot.text 修饰的 Handler 只处理文本消息 @robot.image # @robot.image 修饰的 Handler 只处理图片消息 @robot.subscribe # 用户关注后执行该操作 0x03 demo 实验课原味🐴, 简单完成了消息处理，调了个接口，调了个狗屁不通文本生成器， 糙的一，留做纪念 import werobot import requests import json import gpbtwzbuilder as gp robot = werobot.WeRoBot(token='qwertyuiopasdfghjkl') # 是否菜单模式 isMenu = 1 # 功能模式序号 funCode = 0 # 合法操作 codelist = ['1','2','3'] def menu(): return \"欢迎使用本公众号！\\n 本公众号共有两个模式：菜单模式和功能模式 \\n \" + \"功能选择模式：\\n menu - 查看菜单 \\n 1 - 查询城市的天气状况 \\n 2 - 自言自语模式\\n 3 - 狗屁不通文章生成器\\n\" + \"功能模式：\\n 0 - 退出功能模式返回菜单\" def check(fcode): global codelist global isMenu if fcode in codelist: isMenu = 0 if fcode == '1': return \"输入城市名查询天气\" elif fcode == '2': return \"自言自语！\" elif fcode == '3': return \"输入'文章主题&amp;字数(&lt;=600)'开始狗屁不通\" else: return \"Wrong Operation. Input 'menu' to know more!😅\" @robot.subscribe def subscribe(message): return menu() # @robot.text 修饰的 Handler 只处理文本消息 @robot.text def echo(message, session): global isMenu global funCode if 'first' not in session: isMenu = 1 session['first'] = True msgtext = message.content if isMenu == 1: if \"menu\" in msgtext or \"Menu\" in msgtext: return menu() else: funCode = msgtext return check(funCode) else: if msgtext == '0' or \"menu\" in msgtext or \"Menu\" in msgtext: isMenu = 1 return \"退出成功！\" + menu() if funCode == '1': addr = msgtext url = 'http://wthrcdn.etouch.cn/weather_mini?city=' + addr response = requests.get(url=url) result = json.loads(response.text) #解析json data = result[\"data\"][\"forecast\"][0][\"date\"] high = result[\"data\"][\"forecast\"][0][\"high\"] fengli = result[\"data\"][\"forecast\"][0][\"fengli\"] low = result[\"data\"][\"forecast\"][0][\"low\"] fengxiang = result[\"data\"][\"forecast\"][0][\"fengxiang\"] tian = result[\"data\"][\"forecast\"][0][\"type\"] return \"时间：\" + data + \"\\n最好气温：\" + high + \"\\n最低气温：\" + low + \"\\n风向：\" + fengxiang + \"\\n天气：\" + tian elif funCode == '2': return msgtext elif funCode == '3': ret = msgtext.partition('&amp;') xx = ret[0] for x in xx: tmp = str() maxlength = int(ret[2]) if maxlength > 600: return \"字数超了😅，看不懂中国话是8😅\" while (len(tmp) &lt; maxlength): 分支 = gp.random.randint(0, 100) if 分支 &lt; 5: tmp += gp.另起一段() elif 分支 &lt; 20: tmp += gp.来点名人名言() else: tmp += next(gp.下一句废话) tmp = tmp.replace(\"x\", xx) return tmp # @robot.image 修饰的 Handler 只处理图片消息 @robot.image def img(message): return message.img # 让服务器监听在 0.0.0.0:80 robot.config['HOST'] = '0.0.0.0' robot.config['PORT'] = 80 robot.run() 关于Token 有一篇很好的文章 : link，以下内容部分借鉴 Token：身份认证中代指令牌 Token验证过程Step1 : 用户通过用户名和密码发送请求。 Step2 : 服务器端程序验证。 Step3 : 服务器端程序返回一个带签名的token 给客户端。 Step4 : 客户端储存token,并且每次访问API都携带Token到服务器端的。 Step5 : 服务端验证token，校验成功则返回请求数据，校验失败则返回错误码。 Token的优势 无状态，可扩展 在客户端存储的Token无状态、可扩展(能够创建与其它程序共享权限的程序)。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。tokens自己携带了用户的验证信息。 安全性：防止CSRF 请求中发送token而非发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 ps：token是有时效的，一段时间之后用户需要重新验证。 多平台跨域 这里引入CORS(跨域资源共享)的概念：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 以上只是关于Token的粗略描述，关于其他身份认证机制挖坑待填😅 附：一些Linux命令 使用 nohup 命令使程序在服务器保持后台运行 sudo nohup python .&#x2F;webserver.py &amp; 杀掉 nohup 进程 ps -aux | grep python kill -9 pid End.","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"},{"name":"WeRoBot","slug":"WeRoBot","permalink":"https://maskros.top/tags/WeRoBot/"}]},{"title":"Notes on Kurose's Computer Networking：A TOP-DOWN APPROACH","slug":"note/ComputerNetwork_Note","date":"2021-12-10T05:44:28.000Z","updated":"2022-07-13T08:10:11.492Z","comments":true,"path":"/post/note/ComputerNetwork_Note.html","link":"","permalink":"https://maskros.top/post/note/ComputerNetwork_Note.html","excerpt":"","text":"Notes on Kurose’s Computer NetworkingA TOP-DOWN APPROACH Thanks to 我爹的博客，让我偷了不少😋 Chapter 1 Computer Networks and the Internet1.1 What is the Internet? 因特网：世界范围的计算机网络 Nuts-and-Bolts Description 计算设备称为 主机(host) / 端系统(end system) 端系统通过 通信链路(communication link) 和 分组交换机(packet switch) 连接到一起；不同链路传输速率不同，发送端将数据分段后每段加上首部所形成的信息包称为 分组(packet) 端系统通过 因特网服务提供商(ISP, Internet Service Provider) 接入因特网 端系统、分组交换机和其他部件需要运行一系列协议(protocol) 。因特网的主要协议：TCP/IP (Transmission Control Protocol, 传输控制协议 / Internet Protocol, 网际协议) Service 分布式应用程序：因特网应用中涉及多个相互交换数据的端系统的应用程序 与因特网相连的端系统提供了一个 套接字接口(Socket interface)，规定在一个端系统上的程序请求因特网基础设施向另一个端系统上的目的地程序交付数据的方式 Protocol Def: 定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作 不同的协议用于不同的通信任务 1.2 The Network Edge 主机分类：客户(Client) / 服务器(Server) Access Networks 接入网：将主机物理连接到其边缘路由器(Edge router)的网络 家庭接入：数字用户线(DSL)、电缆因特网接入、光纤到户(FTTH)、拨号、卫星 企业/家庭接入：以太网(Ethernet)、WIFI 广域无线接入：3G、LTE Physical Media 双绞铜线、同轴电缆、光纤、陆地/卫星无线电信道 1.3 The Network Core 通过网络链路和交换机移动数据有两种基本方法：电路交换 和 分组交换 1.3.1 Packet Switching 分组交换 : 端系统彼此交换报文(message)，源端将报文划分成较小的数据块，称为分组；在源和目的地之间每个分组经过通信链路和 分组交换机 (packet switch)传送，两类交换机分别为 路由器(router) 和 链路层交换机(link-layer switch) Store-and-Forward Transmission 存储转发传输：交换机在开始向输出链路传输分组之前需要接收到整个分组 exp: 通过 $N$ 条速率均为 $R$ 的链路组成的路径 (即在源和目的地之间有 $N-1$ 台路由器) 所用 端到端时延为 $d=N \\dfrac{L}{R}$ Queuing Delays and Packet Loss 排队时延和分组丢失：分组交换机具有一个输出缓存(output buffer) 即输出队列，除存储转发时延外分组还要承受输出缓存的排队时延(queuing delay)，如果一个分组到达后发现该缓存空间已满，则发生丢包(packet loss)，到达的分组或已经排队的分组之一将被丢弃 Forwarding Tables and Routing Protocols 转发表和路由选择协议：每台路由器有一个转发表(Forwarding Table)，用于将目的地址/目的地址的一部分映射成输出链路。路由选择协议(routing protocol)用于自动地设置转发表 1.3.2 Circuit Switching 电路交换：建立名副其实的连接，路径上的交换机维护连接状态，电路交换网络上的两主机通信时，网络在两主机间创建一条专用的端到端连接(end-to-end connection) Multiplexing 链路中的电路通过频分复用(FDM, Frequency-Division Multiplexing)或时分复用(TDM, Time-Division Multiplexing)来实现 FDM：链路的频谱由所有连接共享，在连接期间链路为每条连接专用一个频段，频段的宽度称为带宽(band-width) TDM：时间被划分为固定期间的帧，每个帧被划分为固定数量的时隙(slot)，在网络跨越链路创建连接时，在每个帧中为该联结制定一个时隙，由该连接单独使用 分组交换的性能优于电路交换的性能 1.4 Delay, Loss, and Throughput in Packet-Switched Networks 计算机网络的性能测度：时延、丢包、吞吐量 Delay Total nodal delay = 节点处理时延(nodal processing delay) + 排队时延(queuing delay) + 传输时延(transmission delay) + 传播时延(propagation delay) 传输时延：将所有分组的比特推向链路所需要的时间 $\\frac{L}{R}$ 传播时延：将比特从链路的起点到目的地传播所需要的时间 $\\frac{d}{s}$，传播速率 $s$ 取决于物理媒体(光纤/双铜绞线等) Throughput 瞬时吞吐量(instantaneous throughput)：接收到文件的瞬时速率 (bps) 平均吞吐量(average throughput)：文件大小/收到文件所有比特的时间 计算所得的平均速率 (bps) 1.5 Protocol Layers and Their Service Models 分层(Layer)的体系结构 每层通过自己的内部动作/依靠下一层提供的服务来提供服务 Protocol Stack 协议栈：各层的所有协议 因特网协议栈：应用层、运输层、网络层、链路层、物理层 ISO OSI参考模型：应用层、表示层、会话层、运输层、网络层、链路层、物理层 应用层 Application Layer 网络应用程序、应用层协议 HTTP/SMTP/FTP/DNS 协议数据单元(实体交换的数据单位)/信息分组：报文(message) 运输层 Transport Layer TCP/UDP 协议数据单元：报文段(segment) 进程间传输 网络层 Network Layer IP/路由选择协议 协议数据单元：数据报(datagram) 主机间传输 链路层 Link Layer 以太网/802.11(WiFi)/PPP 协议数据单元：帧(frame) 物理层 Physical Layer 控制比特的发送 Encapsulation 封装过程：应用层报文 -&gt; 运输层报文段 -&gt; 网络层数据报 -&gt; 链路层帧 每一层的分组：首部字段 + 有效载荷字段(payload field) ┌───────────┐┌─────────┐ ┌───────┐ ┌────┐ ┌────────┐ │Application││Transport│ │Network│ │Link│ │Physical│ └─────┬─────┘└────┬────┘ └───┬───┘ └─┬──┘ └───┬────┘ │ │ │ │ │ │Message &#x3D; M│ │ │ │ │──────────&gt;│ │ │ │ │ │ │ │ │ │ │Segment &#x3D; H_t + M│ │ │ │ │────────────────&gt;│ │ │ │ │ │ │ │ │ │ │Datagram &#x3D; H_n + H_t + M│ │ │ │ │───────────────────────&gt;│ │ │ │ │ │ │ │ │ │ │Frame &#x3D; H_l + H_n + H_t + M│ │ │ │ │──────────────────────────&gt;│ ┌─────┴─────┐┌────┴────┐ ┌───┴───┐ ┌─┴──┐ ┌───┴────┐ │Application││Transport│ │Network│ │Link│ │Physical│ └───────────┘└─────────┘ └───────┘ └────┘ └────────┘ Chapter 2 Application Layer 应用层 2.1 Principles of Network Applications主流体系结构：客户-服务器体系结构 (C/S, client-server)，对等体系结构 (P2P, peer-to-peer) C/S： 服务器S： 总是打开的主机 (always-on host) 固定的IP地址 (permanent IP address) 服务于客户的请求 客户C: 请求主机 客户间不进行通信 exp: 两个浏览器并不直接通信 动态IP地址 (dynamic IP address) P2P： 没有永远在线的服务器 任意主机对直接通信，对等方 自扩展性 (self-scalability) 新的对等方增加服务能力 exp: P2P文件共享 流量密集型 动态IP地址 Processes Communicating 进程(process) : 运行在主机上的程序 同一主机内的进程：进程间通信 不同主机内的进程：交换报文(Message) 客户进程：发起通信的进程 服务器进程：在会话开始时等待联系的进程 进程与计算机网络间的接口：套接字(socket)，软件接口，进程向/从其套接字发送/接收报文 Reliable Date Transfer Def: 确保应用程序的一端发送的数据正确、完全地交付给了该应用程序的另一端，称为可靠数据传输 2.2 The Web and HTTP Web的应用层协议是 超文本传输协议 (HTTP, HyperText Transfer Protocol) C/S 模式 HTTP客户端：Web浏览器 (Web browser) HTTP服务器端：Web服务器 (Web server) 定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式 支撑运输协议：TCP 客户发起TCP连接，服务器接受TCP连接 建立连接后浏览器和服务器进程就可以通过套接字接口访问TCP 无状态协议(stateless protocol)：HTTP服务器不保存关于客户的信息 HTTP Message Format Request Message 请求报文 第一行为请求行(request line)：方法字段、URL字段、HTTP版本字段 后继四行为首部行(header line) Response Message 响应报文 一个状态初始行(status linge) 六个首部行(header line) 实体体(entity body) Status Code 状态码 200 OK：请求成功，信息在返回的相应报文中 301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解 404 Not Found：被请求的文档不在服务器上 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本 User-Server Interaction: Cookies cookie的4个组件： HTTP响应报文中的一个cookie首部行 HTTP请求报文中的一个cookie首部行 保留在客户端的cookie文件，由用户的浏览器进行管理 保留在Web服务器的后端数据库 Web Caching Web缓存器(Web cache) 又称 代理服务器(proxy server) 代表初始Web服务器来满足HTTP请求的网络实体 浏览器建立到Web缓存器的TCP连接，客户端将所有HTTP请求首先发送到Web缓存器中的对象，Web缓存器检查本地是否存储该对象副本 有：Web缓存器向客户浏览器用HTTP响应报文返回该对象 无：打开一个与该对象的初始服务器的TCP连接，发送该对象的HTTP请求，收到请求后初始服务器向该Web缓存器发送HTTP响应 Web缓存器既是客户也是服务器 服务器：接收浏览器的请求发回响应 客户：向初始服务器发出请求并接收响应 减少了客户端请求的响应时间 减少了一个机构的接入链路到因特网的通信量 The Conditional GET 条件GET：为了保证Web缓存器的对象是最新的 请求报文中使用GET方法并且包含一个”If-Modified-Since”首部行 客户端：在HTTP请求中指定缓存副本的日期 服务器：如果缓存的副本是最新的，则响应不包含任何对象 ┌──────┐ ┌──────┐ │client│ │server│ └──┬───┘ └──┬───┘ │ │ │If-modified-since &lt;date&gt; │ │────────────────────────&gt;│ │ │ │HTTP&#x2F;1.0 304 Not Modified│ │&lt;────────────────────────│ │ │ │If-modified-since &lt;date&gt; │ │────────────────────────&gt;│ │ │ │ HTTP&#x2F;1.0 200 OK &lt;data&gt; │ │&lt;────────────────────────│ ┌──┴───┐ ┌──┴───┐ │client│ │server│ └──────┘ └──────┘ 2.3 Electronic Mail in the InternetComponents of Email 用户代理(User Agent)：邮件客户端 邮件服务器(Mail Server)： 邮箱(mailbox)：包含用户的传入信息 报文队列(message queue)：包含外发(待发)信息 简单邮件传输协议(SMTP, Simple Mail Transfer Protocol)： 向/在邮件服务器上传递/存储消息 C/S模式： 客户端：用户代理或邮件服务器 服务器：邮件服务器 与HTTP的比较： HTTP：拉协议(pull protocol)，用户使用HTTP协议从服务器拉取信息 SMTP：推协议(push protocol)，发送邮件服务器把文件推向接受邮件服务器 因特网邮件访问协议(IMAP, Internet Mail Access Protocol) 检索/删除/文件夹中存储的邮件服务器上的邮件 exp: Alice sends an email to Bob ┌──────────────────┐┌───────────────────┐┌─────────────────┐ ┌────────────────┐ │Alice&#39;s user agent││Alice&#39;s mail server││Bob&#39;s mail server│ │Bob&#39;s user agent│ └────────┬─────────┘└─────────┬─────────┘└────────┬────────┘ └───────┬────────┘ │ │ │ │ │ SMTP │ │ │ │───────────────────&gt;│ │ │ │ │ │ │ │ │ SMTP │ │ │ │──────────────────&gt;│ │ │ │ │ │ │ │ │mail access protocol (IMAP or POP)│ │ │ │─────────────────────────────────&gt;│ ┌────────┴─────────┐┌─────────┴─────────┐┌────────┴────────┐ ┌───────┴────────┐ │Alice&#39;s user agent││Alice&#39;s mail server││Bob&#39;s mail server│ │Bob&#39;s user agent│ └──────────────────┘└───────────────────┘└─────────────────┘ └────────────────┘ 2.4 DNS-The Internet’s Directory Service 域名系统(DNS, Domain Name System)：一个由分层的DNS服务器(DNS server)实现的分布式数据库；一个使得主机能够查询分布式数据库的应用层协议 Services 主机名到IP地址的转换 主机别名(host aliasing)，规范主机名(CNAME, canonical hostname) 邮件服务器别名(mail server aliasing) 负载分配(load distribution)：许多IP地址对应一个名称 How DNS Works 分布式、层次数据库 根DNS服务器，顶级域DNS服务器，权威DNS服务器 本地DNS服务器 递归查询(recursive query)，迭代查询(iterative query) DNS缓存(DNS caching) exp: a distributed, hierarchical database exp: iterative query (more commonly used) vs recursive query 2.6 Video Streaming and Content Distribution Networks 经HTTP的动态适应性流(DASH, Dynamic Adaptive Streaming over HTTP) 内容分发网(CDN, Content Distribution Network) 服务器： 将视频文件分为多个块，每个块以多种不同速率进行编码 不同速率的编码(encoding)存储在不同的文件中 文件被复制到多个CDN节点中 生成告示文件(maifest file)，为不同块提供URL 客户端： 定义估算服务器到客户的带宽 查阅告示文件，每次请求一个分块 决定何时/何种编码率/请求哪台服务器 Streaming stored video: playout buffering Summary: video streaming = encoding + DASH + playout buffering Chapter 3 Transport Layer 传输层 3.1 Introduction and Transport-Layer Services 运输层协议为不同主机上的应用进程之间提供了逻辑通信(logic communication) 发送方 通过套接字传递应用层的报文 确定报文段(segment)报头的值 创建报文段 将报文段传递给网络层 接收方 从网络层接收报文段 检查报头值 提取应用层的报文 通过套接字将报文传递给应用层 Transport vs Network layer services exp: 家庭间的邮件传递 主机：家庭 进程：孩子 应用层报文：信件 运输层协议：两个家庭中由 Ann 和 Bill 为孩子们收发信件 网络层协议：邮政服务 不提供的服务：延迟保证，带宽保证 3.2 Multiplexing and Demultiplexing 复用(multiplexing)：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息生成报文段，将报文段传递给网络层 分用(demultiplexing)：将运输层报文段的数据交付到正确的套接字 套接字有唯一标识符，而每个报文段通过源端口号字段(source port number field)，目的端口号字段(destination port number field)指示报文段所要交付到的套接字 下图展示了复用和分用的过程 3.3 UDP: Connectionless Transport 用户数据报协议 无连接的 UDP发送方和接收方之间没有握手协议 每个UDP数据报独立处理 尽力而为交付服务(best-effort delivery service) 报文段可能丢失 报文段可能不符合顺序 Why there is a UDP 无需建立连接 不需要握手(无RTT延迟) 无连接状态 报头尺寸小 没有拥塞控制 速度快 有面对拥堵时的机制 用例：DNS, SNMP, HTTP/3(在应用层增加所需可靠性以及拥堵控制) UDP Segment Structure ------------ 32bit ------------ ┌───────────────┬───────────────┐ | source port # | dest port # | ├───────────────┼───────────────┤ | length | checksum | ├───────────────┴───────────────┤ | | | application data (payload) | | | └───────────────────────────────┘ 检验和(checksum): 提供差错检测功能，发送方的UDP对报文段中所有16bit字的和进行反码运算得到 3.4 Principles of Reliable Data Transfer 可靠数据传输协议(rdt协议, reliable data transfer protocol)：为TCP的可靠性保证做准备 Building a Reliable Data Transfer Protocol 假设： 单向的数据传输(发送方到接收方) 在不可靠的信道中进行双向控制信息(即ACK)流动 逐步改进rdt协议(提供有限状态机(Finite-State Machine, FSM) )： rdt1.0：信道完全可靠 rdt2.0：信道具有比特差错，使用ACK(肯定确认, positive acknowledgment) /NAK(否定确认, negative acknowledgment)，基于这样重传机制的可靠数据传输协议称为自动重传请求(ARQ, Automatic Repeat reQuest)协议 rdt2.1：如果ACK/NAK被破坏，使用序号(sequence number)来处理重复的信息 rdt2.2：只使用ACK rdt3.0：信道具有比特差错和丢包，使用倒计数定时器(countdown timer)，rdt3.0又称比特交替协议 Stop-and-Wait (starting from rdt2.0) 停等协议：发送方发送一个数据包，然后等待接收方的回应 发送方必须等待发送的数据包到达，或者直到超时，在某些情况下会导致发送方长时间处于空闲状态等待确认 Pipelining successor of Stop-and-Wait 流水线：发送方允许多个发送中的、尚未被ACK的数据包 Go-Back-N(GBN) 发送方： 最多可以有序号范围为N个的、连续传输但未ACK的数据包的窗口，N被称为窗口长度(window size) 累计确认(commulative ACK(n)) 表明接收方以正确收到序号为n的以前且包括n在内的所有数据包 向前移动窗口使起点位于 n+1 对发送时间最早但未被确认的数据包进行计时 超时事件(timeout(n))：重传n号和所有序号更高的数据包 接收方： 仅发送最高序号的ACK 在收到失序的数据包时 丢弃或缓存 重新发送按照顺序的最高序号的ACK Selective Repeat(SR) 发送方： 最多可以有序号范围为N个的、连续传输但未ACK的数据包的窗口 ACK(n)：标记n号数据包已收到，如果n是最小的未ACK的数据包，则窗口向前移动到下一个未ACK的数据包开始 timeout(n)：对未ACK的数据包单独重传 接收方 单独ACK(n) 收到失序的数据包时：缓存 收到有序的数据包时：交付(也交付缓冲的、符合顺序的数据包) 在Go-Back-N中使用的累计确认在TCP中也有使用 发送窗口和接收窗口的大小必须相等 3.5 TCP: Connection-Oriented Transport 传输控制协议 点对点(point-to-point)：一个发送方，一个接收方 可靠的，有序的字节流(byte-stream) 面向连接的(connection-oriented)：在数据交换前 握手(handshaking) 初始化发送方和服务器状态 累计确认(cumulative ACKs) 全双工服务(full-duplex service)：在同一连接中同时进行双向数据流 流水线：流量和拥堵控制 TCP Segment Structure UAPRSF：URG, ACK, PSH, RST, SYN, FIN 序列号(Sequence Number)：分段数据中第一个字节的字节流编号 确认号(Acknowledgement Number)：确认对方下一个字节的序列号，累计ACK RTT Estimation(via EWMA) and Timeout RTT: 连接的往返时间 SampleRTT: 报文段的样本RTT EstimateRTT: 估计往返时间 TimeoutInterval: 超时重传间隔 DevRTT: 偏差RTT EWMA: 指数加权移动平均 Exponential Weighted Moving Average EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT 取α = 0.125 TimeoutInterval = EstimatedRTT + 4·DevRTT DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT| 取β = 0.25 Fast Retransmit TCP快速重传：如果检测到3个冗余的ACK，则TCP执行快速重传，在该报文段的定时器过期之前重传丢失的报文段 Flow Control 流量控制： 接收方控制发送方，这样发送方就不会溢出接收方的缓冲区 接收窗口rwnd(receive window)：在TCP头的rwnd字段中，指示该接收方还有多少可用的缓存空间，或表示发送方将数据量限制在rwnd内 TCP Connection Management 三次握手(three-way handshake)建立连接 四次挥手(four-way handshake)结束连接 TCP状态(TCO state)的变迁，有限状态机(FSM) 3.6 Principles of Congestion Control 拥塞控制 拥塞(Congestion)： 太多的发送者以太快的速度发送太多的数据 表现：高延迟、丢包 与流量控制不同(一个发送方对于一个接收方来说速度太快) The Causes and the Costs of Congestion 吞吐量永远不会超过容量 延迟随着容量的增加而增加 丢失/转发/不必要的中端会降低有效吞吐量(throughput) 上游传输容量/缓冲区会因下游丢包而被浪费 Congestion Control 端到端拥塞控制(end-end approach)： 没有来自网络的明确反馈，从观察到的延迟、损失推断拥塞情况 网络辅助的拥塞控制： IP路由器在拥堵时向发送/接受主机提供直接反馈，可以显示拥堵程度或者明确设置发送速率 3.7 TCP Congestion ControlTCP的拥塞控制算法(CCA, congestion control algorithm)： 拥塞窗口cwnd(Congestion Window) 慢启动(slow-start)： cwnd的值以1个MSS开始，每当传输的报文段首次被确认就增加一个MSS，这一过程中每过一个RTT，发送速率就翻倍，指数增长 慢启动阈值ssthresh：如果存在一个由超时指示的丢包(即拥塞)，TCP发送方将 cwnd 设置为1并重新开始慢启动，将ssthresh设为 cwnd/2, 即当检测到拥塞时将其置位拥塞窗口值的一半。当到达或者超过ssthresh的值时，进入拥塞避免 拥塞避免(Congestion Avoidance) cwnd的值每个RTT只增加一个MSS，线性增长 由3个冗余ACK引起的丢包时, ssthresh = cwnd/2, cwnd = 1MSS, 进入快速恢复 快速恢复(Fast Recovery) 对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值就加一个MSS，当对丢失报文段的一个ACK到达时，TCP降低cwnd后进入拥塞避免状态 加性增、乘性减(AIMD, Additive-Increase, Multiplicative-Decrease) 拥塞控制方式 假定丢包由3个冗余ACK而不是超时指示：每个RTT内cwnd线性(加性)增加1MSS，然后出现3个冗余ACK事件时cwnd减半(乘性减) Chapter 4 The Network Layer: Data Plane网络层：数据平面 4.1 Overview of Network Layer 发送方： 将报文段封装成数据报(datagram)，传递给链路层 接收方： 从数据报中提取报文段，传递给传输层 两种重要功能： 转发(Forwarding)：将数据报从输入链路转移到适当的输出链路上，类比旅游中在每个路口做决定 路由(Routing)：确定数据报从原点到目的地的路线 Two Network Layer Planes Data Plane 数据平面 本地，每台路由器的功能 路由器内的数据报转发 硬件 Control Plane 控制平面 全网 沿着从原点到目的地的路径，在路由器之间进行数据报路由 传统路由算法：在路由器中实现 软件定义网络(SDN, Software-Defined Networking)：在远程服务器中实现 软件 Network layer’s “best effort” service model 尽力而为服务：不保证成功交付，及时/按顺序交付，最小带宽 4.2 What’s inside a Router? 输入端口(input port): 通过header的值进行转发表查询 转发方式： 基于目的地转发：只根据目的地的IP地址进行转发 通用转发：基于任何一组header值的转发，不仅仅是网络层的功能：转发(路由器，交换机)，丢弃(防火墙)，修改(NAT)，封装并转发到控制器(SDN) 最长前缀匹配(longest prefix matching rule)：通常使用三态内容可寻址存储器(TCAM, Tenary Content Address Memory)来查找 交换结构(switching fabric)： 将数据报从输入链路传输到适当的输出链路 交换率：数据报传输的速率，通常以多个输入/输出线路速率来衡量 三种主要类型：内存、总线、互联网 排队(queueing)： 输入排队： 输入端口的综合线路速率大于交换速率 需要缓冲：排队延迟和输入缓冲器溢出造成的损失 阻塞(HOL, Head-Of-the-Line)：排在前面的数据报阻断后面的数据报 输出排队： 交换率大于链路传输速率 需要缓冲：由于输出缓冲区溢出，造成排队延迟和损失 缓冲区管理： 丢弃策略：尾部丢弃，基于优先级的丢弃 标记：ECN，RED Packet Scheduling 先进先出(FIFO, First-In-First-Out) 优先权排队(priority queuing)： 到达时分类 从最高优先级到最低优先级 优先级内的FIFO 循环排队(RR, Round Robin queuing discipline) 到达时分类 通过类循环 依次从每个类中选出一个 加权公平排队(WFQ, Weight Fair Queuing) 广义的Round Robin 每个类别有权重 在每个循环中加权服务量 每个流量类别的最低带宽保证 4.3 The Internet Protocol(IP): IPv4, Addressing, IPv6, and More网际协议IP IPv4 vs IPv6 IPv4 32位地址编码 IPv6 128位地址编码 通过隧道(tunnel)时，IPv6数据报作为IPv4数据报的有效载荷实现共存 IP Addressing： IP地址：与每个主机/路由器接口(interface)相关的32位标识符 接口： 主机/路由器和物理链路之间的连接 接口的数量：路由器通常多个，主机通常一个或两个 有线以太网 无限802.11 点分十进制记法(dotted-decimal notation) 无类别域间路由选择(CIDR, Classless Interdomain Routing) 任意长度的子网地址x，即子网掩码(subnet mask) a.b.c.d/x How to get an IP ? 主机： 硬编码 动态主机配置协议(DHCP, Dynamic Host Configuration)： 主机在加入网络时动态地从DHCP服务器获取一个IP地址 DHCP服务器位于路由器中 地址的重复使用 即插即用协议(plug-and-play protocol) 返回的不仅仅是子网中分配的IP地址 第一跳路由器的地址 DNS服务器的名称和IP地址 子网掩码 子网(subnet) (即网络如何获得其IP地址的子网部分) 从其ISP获得 ISP (即一个ISP如何获得其地址块) 从ICANN Network Address Translation(NAT) 网络地址转换NAT 就外部世界而言，本地网络中的所有设备只共享一个IPv4地址 本地IP地址在3个专用IP地址(private network)范围内 优势 所有设备都有一个来自ISP的IP地址 改变本地地址不需要通知外部世界 改变ISP而不改变本地地址 本地设备不会被外界直接看到，保证安全 实现 (透明) 对发出的数据报： 将 (源IP地址，端口) 替换为 (NAT IP地址，新端口) 远程主机将以 (NAT IP地址，新端口) 作为目的地进行响应 NAT转换表(NAT translation table) 每个 (源IP地址，端口) &lt;-&gt; (NAT IP地址，端口) 对传入的数据报： 用NAT转换表进行反向转换 4.4 Generalized Forwarding and SDNGeneralized Forwarding 通用转发：一张流表(flow table)将基于目的地的转发表一般化 OpenFlow：一个匹配加动作转发抽象的标准 流表：匹配加动作转发表 匹配：入端口、IP源地址、IP目的地址 (允许通配符*) 动作：转发、丢弃、修改字段 Chapter 5 The Network Layer: Control Plane网络层：控制平面 5.1 Introduction构建网络控制平面的两种方法： 每路由器控制(per-router control)：(传统的，分布式) 每个路由器中都有单独的路由算法组件 路由器之间直接互动 逻辑集中式控制(logically centralized/ SDN control) 路由器之间不相互影响 路由算法在两种方法中都是一样的，区别只是如何实现 5.2 Routing Algorithms路由选择算法 Dijkstra’s link state algorithm 链路状态(Link State, LS) 属于集中式路由选择算法(centralized routing algorithm) 必须知道网络中每条链路的开销 Bellman Ford’s (BS) distance vector algorithm 距离向量(Distance Vector, DV) 属于分散式路由选择算法(decentralized routing algorithm) 每个节点维护到网络中所有其他结点的开销(距离)估计的向量 Dijkstra’s Link State Algorithm 集中式 所有节点都知道网络拓扑结构(图) 所有节点都有相同的信息 通过链路状态广播完成 计算从一个节点到所有其他节点的最小成本路径，为该节点生成转发表 迭代(iterative) 经过k次迭代，知道到k个目的地的最低成本路径 算法复杂性: $O(n^2)$ 每次迭代需要检查所有不在N中的节点 有 $O((n+m)logn )$ 的可能，有最小优先级的队列 信息复杂性: $O(n^2)$ 链路状态广播(link state broadcast)：每个路由器必须向所有其他路由器广播链接状态 有效的广播算法：$O(n)$ 个链路交叉点来传播来自一个源的广播消息 每个路由器的消息穿过 $O(n)$​​ 个链接 当链路成本取决于流量时可能出现振荡 Bellman Ford’s Distance Vector Algorithm 分散式(decentralized) 路由器最初只知道连接到邻居的成本 路由选择表(routing table) 迭代的(iterative) 每个节点的行动： 等待触发本地迭代的变化 本地链路成本变化 来自邻居的距离向量更新信息 重新计算本地距离向量 如果变化，发送新的本地距离向量给邻居 异步的(asynchronous) 每个节点的迭代速度可以不同 自我终止的(self stopping) 每个节点只在本地距离向量发生变化时通知其邻居 没有收到通知，不采取任何行动 好消息传得快(链接成本降低)，坏消息传的慢(链接成本增加)：无穷计数(count-to-infinity)问题 算法复杂性：$O(n+m)$ 信息复杂性：(网络直径为 $d$ 的节点) $O(d)$ : 状态信息的扩散 收敛的速度不同导致收敛的时间不同，可能有路由选择环路(routing loop) 和 无穷计数问题 (count-to-infinity) 5.3 Intra-AS Routing in the Internet: OSPF ISP, AS, 域在这里具有相同含义 Autonomous System(AS) 自治系统：将路由器组织进AS 域内路由协议： AS中的所有路由器必须运行相同的域内协议 不同AS种的路由器可以运行不同的域内协议 网关路由器(gateway router)： 域间路由协议： 在AS之间进行路由选择 网关路由器既执行域间路由，也执行域内路由 转发表(Forwarding table)是由域内和域间填充的协议(目的地在AS内: Intra-; 目的地在AS外: Intra- 和 Inter-) OSPF(Open Shortest Path First) 开放最短路优先 最常用的域内路由协议 经典的Dijkstra链路状态算法 每个路由器向AS内所有其他路由器广播选择信息(直接通过IP而非TCP/UDP) 可能有多个指标：带宽、延迟 所有OSPF消息都经过认证以防止恶意入侵 5.4 Routing Among the ISPs: BGP 边界网关协议 (Broder Gateway Protocol, BGP) 既涉及决策，也涉及性能 自治系统间的路由选择协议 (inter- AS routing protocol) BGP为每个AS提供了一种方法来： 从邻近的AS获得可达性信息(eBGP) 将可达性信息传播给AS内的所有路由器(iBGP) BGP会话 两个BGP路由器通过TCP连接交换BGP信息 路径通告：前缀(prefix, CIDR化目标网络) + 属性(BGP attribute) 两个重要的属性： AS-PATH：通告已经通过的AS列表 NEXT-HOP(下一跳)：通往下一跳AS的内部AS路由器 基于策略的路由选择： 是否接受一个路径通告，exp: 永远不通过X的路由 是否发布路径通告，exp: 流量永远不会路由到X Hot Potato Routing 热土豆路由选择：选择域内成本最低的本地网关，不用担心域间成本，即尽可能快地将数据送出 Route-Selection Algorithm 路由器选择算法：当有一条以上的路由可用时 策略决定 最短的AS-PATH 最近的NEXT-HOP路由器(hot potato) 额外标准 5.5 The SDN Control Plane 软件定义网络(Software Defined Networking, SDN) Why a logically centralized control plane? 更容易管理 基于表的转发 (OpenFlow API) 允许对路由器进行编程 集中式编程更容易：集中计算表并分发 开放的实现 促进创新 Chapter 6 The Link Layer and LANs链路层和局域网 6.1 Introduction to the Link Layer 发送方： 将网络层的数据报封装成帧(Frame) 接收方 从帧中提取数据报，传递给网络层 链路层信道： 广播信道：有线局域网、卫星网、HFC 点对点通信链路：点对点协议(PPP, Point-to-Point Protocol) The Services Provided by the Link Layer 成帧(framing) 链路接入(link access)：媒体访问控制(MAC, Media Access Control)协议规定了帧在链路上的传输规则 可靠交付(Reliable delivery)：无差错地经链路层移动每个网络层数据报 差错检测和纠正(Error detection and correction) Where Is the Link Layer Implemented? 网络适配器(network adapter)，也称网卡(Network Interface Card , NIC) 6.2 Error-Detection and -Correction Techniques 奇偶校验(Parity Checks) 前向纠错(Forward Error Correction, FEC)：接收方检测和纠正差错的能力 检验和(Checksumming) 循环冗余检测(CRC, Cyclic Redundancy Check) 多项式编码(polynomial code) 生成多项式(generator) 6.3 Multiple Access Links and Protocols 多路访问链路和协议 信道划分协议(Channel Partitioning Protocols)： TDM（时分多路复用） FDM（频分多路复用） CDMA (码分多址, Code Divison Multiple Access) 随机接入协议(Random Access Protocols) Slotted ALOHA（时隙ALOHA） ALOHA CSMA（载波侦听多路访问） CSMA/CD（具有碰撞检测的载波侦听多路访问） 轮流协议(Taking-Turns Protocols) 轮询协议(polling protocol) 令牌传递协议(token-passing protocol) DOCSIS：用于电缆因特网接入的链路层协议 6.4 Switched Local Area NetworksLink-Layer Addressing and ARP MAC Addresses(物理地址) 长度6字节，2^48个可能的MAC地址 MAC广播地址(broadcast address)：FF-FF-FF-FF-FF-FF ARP(地址解析协议, Address Resolution Protocol) 在IP地址和MAC地址间进行转换 Ethernet Frame Link-Layer Switches 链路层交换机： 交换机表(switch table)：(MAC地址，通向该MAC地址的交换机接口，时间) 自学习(self-learning) 即插即用设备(plug-and-play device) Switches vs Routers 交换机是第二层的分组交换机，路由器是第三层的分组交换机 交换机即插即用，但对于广播风暴(broadcast storms)没有保护措施 路由器和连接到他们的主机需要人为配置IP地址，路由器对第二层的广播风暴提供了防火墙保护(firewall protections) 交换机，路由器和主机中的数据包处理 Virtual Local Area Networks (VLANs) 虚拟局域网的作用：流量隔离(traffic isolation)，管理用户(managing users) Chapter 7 Wireless and Mobile Networks无线网络和移动网络 7.1 Introduction 无线主机(wireless host)：主机本身可能移动也可能不移动 无线链路(wireless communication link)：主机通过无线线路连接到一个基站或者另一台无线主机 基站(base station)：exp: 蜂窝塔(cell tower)，802.11无线LAN中的接入点(access point) 7.2 Wireless Links and Network Characteristicswire link vs wireless link 路径损耗(path loss)：信号强度递减 来自其他源的干扰 多径传播(multipath propagation)：电磁波的一部分受反射在发送方和接收方间走了不同长度的路径 Signal-to-Noise Ratio(SNR) 信噪比(SNR)：所受到的信号和噪声强度的相对测量 比特差错率(BER)：接收方收到的有错传输的比特的概率 给定调制方案，SNR越高BER越低 给定SNR，就要较高比特传输率的调制技术将具有较高的BER 物理层调制技术的动态选择能用于适配对信道条件的调制技术 7.3 WiFi: 802.11 Wireless LANsThe 802.11 Architecture 速率适应(Rate Adaptation)，功率管理(Power Management) 基本构建模块：基本服务集(Basic Service Set, BSS) BSS：一个/多个无线站点，一个接入点(Access Point, AP)的中央基站(base station) Channels and Association exp: 你携带移动设备进入WiFi丛林，找无线因特网接入，设在丛林中有5个AP，为获得因特网接入你的无线站点应加入其中一个子网故需与其中一个AP相关联(associate)，即建立一条虚拟线路 The 802.11 MAC Protocol 随机访问协议：带碰撞避免的CSMA(CSMA with collision avoidance)，CSMA/CA，类比以太网的CSMA/CD 处理隐藏终端：RTS(短请求发送，Reqeust to Send), CTS(允许发送，Clear to Send) The IEEE 802.11 Frame","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://maskros.top/tags/ComputerNetwork/"}]},{"title":"Trie专题训练","slug":"algorithm/exercise/trie_problem","date":"2021-11-27T04:20:00.000Z","updated":"2022-01-22T09:37:15.580Z","comments":true,"path":"/post/algorithm/exercise/trie_problem.html","link":"","permalink":"https://maskros.top/post/algorithm/exercise/trie_problem.html","excerpt":"Trie training","text":"Trie 专题训练0.0 0x01 统计难题 HDU 1251 link 题意：给了一堆字符串，统计以模式串作前缀出现的单词个数 trie入门题，存结点时统计一下过当前结点的单词个数即可 &#x2F;&#x2F;对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树 &#x2F;&#x2F;很多题都是要用到节点下标来表示某个字符串 const int maxn &#x3D; 2e6 + 5; &#x2F;&#x2F;如果是64MB可以开到2e6+5，尽量开大 int tree[maxn][30]; &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号 bool flagg[maxn]; &#x2F;&#x2F;表示以该节点结尾是一个单词 int tot; &#x2F;&#x2F;总节点数 int cnt[maxn]; void insert_(char* str) &#123; int len &#x3D; strlen(str); int root &#x3D; 0; for (int i &#x3D; 0; i &lt; len; i++) &#123; int id &#x3D; str[i] - &#39;a&#39;; if (!tree[root][id]) tree[root][id] &#x3D; ++tot; root &#x3D; tree[root][id]; cnt[root]++; &#125; flagg[root] &#x3D; true; &#125; bool find_(char* str) &#123; &#x2F;&#x2F;查询操作，按具体要求改动 int len &#x3D; strlen(str); int root &#x3D; 0; int ans; for (int i &#x3D; 0; i &lt; len; i++) &#123; int id &#x3D; str[i] - &#39;a&#39;; if (!tree[root][id]) return false; root &#x3D; tree[root][id]; &#x2F;&#x2F; if(!flagg[root] &amp;&amp; i&#x3D;&#x3D;len-1) return false; &#x2F;&#x2F;判断是否两个单词完全匹配 &#125; ans &#x3D; cnt[root]; cout&lt;&lt;ans&lt;&lt;endl; return true; &#125; void init() &#123; &#x2F;&#x2F;最后清空，节省时间 for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123; flagg[i] &#x3D; false; for (int j &#x3D; 0; j &lt; 10; j++) tree[i][j] &#x3D; 0; &#125; memset(cnt,0,sizeof(cnt)); tot &#x3D; 0; &#x2F;&#x2F;RE有可能是这里的问题 &#125; void solve() &#123; char str[15]; init(); while(gets(str)&amp;&amp;str[0]!&#x3D;&#39;\\0&#39;)&#123; insert_(str); &#125; while(gets(str)&amp;&amp;str[0]!&#x3D;EOF)&#123; bool t &#x3D; find_(str); if(!t) cout&lt;&lt;0&lt;&lt;endl; &#125; &#125; 0x02 Remember the Word LA 3942 link 题意： 给出一个由S个不同单词组成的字典和一个长字符串，把这个字符串分解成若干个单词的连接(可重复使用)，有多少种方法。ex: 有四个单词：a, b, cd, ab；则abcd有两种分解方法：a+b+cd 和 ab+cd 思路： dp + Trie 计数问题考虑dp： 考虑状态：dp[i] 为以i开始的后缀的方案数 考虑转移：因为单词长度不大于100，我们可以直接暴力向后看当前单词是否存在，所以可以用Trie或者字符串哈希完成 令dp(i)表示从字符i开始的字符串，dp(i)=sum{dp(i+len(x))}, x是s[i…L]的前缀。然后把所有可分解成的单词构造成一颗Trie树，再让母串在上面跑，dp[0]即是方案总数。 #include &lt;bits&#x2F;stdc++.h&gt; #define maxn 300005 #define mod 20071027 char P[maxn]; #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt;&#x3D; y; i--) using namespace std; int dp[maxn]; &#x2F;&#x2F;dp[i] 为以i开始的后缀的方案数 int tree[maxn][30]; &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号 bool flagg[maxn]; &#x2F;&#x2F;表示以该节点结尾是一个单词 int tot; &#x2F;&#x2F;总节点数 int m; &#x2F;&#x2F;主串长度 void insert_(char* str) &#123; int len &#x3D; strlen(str); int root &#x3D; 0; for (int i &#x3D; 0; i &lt; len; i++) &#123; int id &#x3D; str[i] - &#39;a&#39;; if (!tree[root][id]) tree[root][id] &#x3D; ++tot; root &#x3D; tree[root][id]; &#125; flagg[root] &#x3D; true; &#125; void find_(int id) &#123; &#x2F;&#x2F;查询操作，按具体要求改动 int root &#x3D; 0; for (int i &#x3D; id; i &lt;&#x3D; m; i++) &#123; int k &#x3D; P[i] - &#39;a&#39;; if (!tree[root][k]) break; root &#x3D; tree[root][k]; if (flagg[root]) dp[id] &#x3D; (dp[id] + dp[i + 1]) % mod; &#125; &#125; void init() &#123; for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123; flagg[i] &#x3D; false; for (int j &#x3D; 0; j &lt; 30; j++) tree[i][j] &#x3D; 0; &#125; memset(dp, 0, sizeof(dp)); tot &#x3D; 0; &#125; char c[105]; int main() &#123; long long times &#x3D; 0; init(); while (scanf(&quot;%s&quot;, P)!&#x3D;EOF) &#123; times++; int S; cin &gt;&gt; S; &#x2F;&#x2F; init(); rep(i, 0, S) &#123; scanf(&quot;%s&quot;, c); insert_(c); &#125; m &#x3D; strlen(P); dp[m] &#x3D; 1; red(i, m, 0) &#123; find_(i); &#125; cout &lt;&lt; &quot;Case &quot; &lt;&lt; times &lt;&lt; &quot;: &quot; &lt;&lt; dp[0] &lt;&lt; endl; init(); &#125; &#125; 0x03 “strcmp()” Anyone? link 题意： 输入n个字符串，两两调用一次strcmp()，问字符比较的总次数是多少？ex: strcmp(“than”, &quot;that&quot;)：cnt = 7 题解：两个字符串比较次数其实是 相同字符数*2 + (存在不同字符? 1 : 0)；然后建字典树，dfs一下即可。因为节点的个数比较多，所以用左孩子右兄弟的方法建立字典树。 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxnode &#x3D; 4000 * 1000 + 10; const int sigma_size &#x3D; 26; &#x2F;&#x2F; 字母表为全体小写字母的Trie struct Trie &#123; int head[maxnode]; &#x2F;&#x2F; head[i]为第i个结点的左儿子编号 int next[maxnode]; &#x2F;&#x2F; next[i]为第i个结点的右兄弟编号 char ch[maxnode]; &#x2F;&#x2F; ch[i]为第i个结点上的字符 int tot[maxnode]; &#x2F;&#x2F; tot[i]为第i个结点为根的子树包含的叶结点总数 int sz; &#x2F;&#x2F; 结点总数 long long ans; &#x2F;&#x2F; 答案 void clear() &#123; sz &#x3D; 1; tot[0] &#x3D; head[0] &#x3D; next[0] &#x3D; 0; &#125; &#x2F;&#x2F; 初始时只有一个根结点 &#x2F;&#x2F; 插入字符串s（包括最后的&#39;\\0&#39;），沿途更新tot void insert(const char* s) &#123; int u &#x3D; 0, v, n &#x3D; strlen(s); tot[0]++; for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123; &#x2F;&#x2F; 找字符a[i] bool found &#x3D; false; for (v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) if (ch[v] &#x3D;&#x3D; s[i]) &#123; &#x2F;&#x2F; 找到了 found &#x3D; true; break; &#125; if (!found) &#123; v &#x3D; sz++; &#x2F;&#x2F; 新建结点 tot[v] &#x3D; 0; ch[v] &#x3D; s[i]; next[v] &#x3D; head[u]; head[u] &#x3D; v; &#x2F;&#x2F; 插入到链表的首部 head[v] &#x3D; 0; &#125; u &#x3D; v; tot[u]++; &#125; &#125; &#x2F;&#x2F; 统计LCP&#x3D;u的所有单词两两的比较次数之和 void dfs(int depth, int u) &#123; if (head[u] &#x3D;&#x3D; 0) &#x2F;&#x2F; 叶结点 ans +&#x3D; tot[u] * (tot[u] - 1) * depth; else &#123; int sum &#x3D; 0; for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) sum +&#x3D; tot[v] * (tot[u] - tot[v]); &#x2F;&#x2F; 子树v中选一个串，其他子树中再选一个 ans +&#x3D; sum &#x2F; 2 * (2 * depth + 1); &#x2F;&#x2F; 除以2是每种选法统计了两次 for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) dfs(depth + 1, v); &#125; &#125; &#x2F;&#x2F; 统计 long long count() &#123; ans &#x3D; 0; dfs(0, 0); return ans; &#125; &#125;; const int maxl &#x3D; 1000 + 10; &#x2F;&#x2F; 每个单词最大长度 int n; char word[maxl]; Trie trie; int main() &#123; int kase &#x3D; 1; while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123; trie.clear(); for (int i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, word); trie.insert(word); &#125; printf(&quot;Case %d: %lld\\n&quot;, kase++, trie.count()); &#125; return 0; &#125;","categories":[{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"Trie","slug":"Trie","permalink":"https://maskros.top/tags/Trie/"},{"name":"dfs","slug":"dfs","permalink":"https://maskros.top/tags/dfs/"}]},{"title":"Trie","slug":"algorithm/learn/trie","date":"2021-11-27T03:55:50.000Z","updated":"2022-07-13T09:04:47.137Z","comments":true,"path":"/post/algorithm/learn/trie.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/trie.html","excerpt":"Trie字典树/前缀树 什么是Trie 从根节点到每个单词结点的路径上所有字母连接成的字符串就是该结点对应的字符串 多叉树，最大分支数由字典的字符集含有的字符数决定","text":"Trie字典树/前缀树 什么是Trie 从根节点到每个单词结点的路径上所有字母连接成的字符串就是该结点对应的字符串 多叉树，最大分支数由字典的字符集含有的字符数决定 操作 插入字符串 insert 初始化 root = 0 , 遍历字符串, 对于其每一个字符, 计算其映射值 id 检查Trie[root][id] == 0 是否成立： 若成立, 则进行插入, Trie[root][id] = ++cnt 若不成立,说明该位置已经有该字符,直接找到下一个字符应插入的位置: root = trie[root][id]. 重复上述步骤,直到字符串完全插入Trie树. 匹配字符串 search 初始化root = 0,遍历字符串,对于其每一个字符,计算其映射值id 检查Trie[root][id] == 0是否成立： 若成立, 则说明Trie树当前路径不存在该字符,返回匹配失败 若不成立,则说明当前路径存在该字符,找到下一个字符的位置: root = trie[root][id] 重复上述步骤，若顺利匹配完整个字符串,则应该检查字符串结束的位置在Trie树中是否是结束标志，flag[root] == true成立,表明是结束标志,则返回匹配成功,否则返回匹配失败 模板 附：字符数组操作 char s1[maxn], s2[maxn]; strcpy(s1, s2); &#x2F;&#x2F;复制字符串 s2 到字符串 s1。 strcat(s1, s2); &#x2F;&#x2F;连接字符串 s2 到字符串 s1 的末尾。 strlen(s1); &#x2F;&#x2F;返回字符串 s1 的长度。 strcmp(s1, s2); &#x2F;&#x2F;如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 strchr(s1, ch); &#x2F;&#x2F;返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2); &#x2F;&#x2F;返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 模拟 对结构体Trie进行插入和查询操作 val[i] &gt; 0 表示这是一个单词结点 #define maxn 41000 #define sigmasize 26 &#x2F;&#x2F; 字符集的大小 ex: 全体小写字母：26 struct Trie&#123; int ch[maxn][sigmasize]; int val[maxn]; &#x2F;&#x2F; 结点i对应的附加信息，如每个字符串的权值, 如val[i]&gt;0 当且仅当结点i是单词结点 int sz; &#x2F;&#x2F; 结点总数 Trie() &#123; sz &#x3D; 1; memset(ch[0], 0, sizeof(ch[0]));&#125; &#x2F;&#x2F;初始只有一个根节点 int idx(char c) &#123; return c - &#39;a&#39;; &#125; &#x2F;&#x2F;字符c的编号 &#x2F;&#x2F; 插入字符串s, 附加信息为v。v必须非0, 0 代表“本结点不是单词结点” inline void insert(char *s, int v) &#123; int u &#x3D; 0, n &#x3D; strlen(s); for (int i &#x3D; 0; i &lt; n; i++) &#123; int c &#x3D; idx(s[i]); if (!ch[u][c]) &#123; &#x2F;&#x2F;结点不存在 memset(ch[sz], 0, sizeof(ch[sz])); val[sz] &#x3D; 0; &#x2F;&#x2F;中间节点的附加信息为0 ch[u][c] &#x3D; sz++; &#x2F;&#x2F;新建节点 &#125; u &#x3D; ch[u][c]; &#x2F;&#x2F;往下走 &#125; val[u] &#x3D; v; &#x2F;&#x2F;字符串的最后一个字符的附加信息为v &#125; &#x2F;&#x2F; 查找字符串s inline bool search(char *s) &#123; int u &#x3D; 0, n &#x3D; strlen(s); for (int i &#x3D; 0; i &lt; n; i++) &#123; int c &#x3D; idx(s[i]); if (ch[u][c] &#x3D;&#x3D; 0) return false; u &#x3D; ch[u][c]; &#125; if (val[u] &#x3D;&#x3D; 0) return false; return true; &#125; &#125;trie; 版本2 可以用 find(str) 判断字典树中是否有以 str 作前缀的单词 //对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树 //很多题都是要用到节点下标来表示某个字符串 const int maxn = 2e6 + 5; //如果是64MB可以开到2e6+5，尽量开大 int tree[maxn][30]; //tree[i][j]表示节点i的第j个儿子的节点编号 bool flagg[maxn]; //表示以该节点结尾是一个单词 int tot; //总节点数 void insert_(char* str) &#123; int len = strlen(str); int root = 0; for (int i = 0; i &lt; len; i++) &#123; int id = str[i] - 'a'; if (!tree[root][id]) tree[root][id] = ++tot; root = tree[root][id]; &#125; flagg[root] = true; &#125; bool find_(char* str)&#123; //查询操作，按具体要求改动 int len = strlen(str); int root = 0; for (int i = 0; i &lt; len; i++) &#123; int id = str[i] - 'a'; if (!tree[root][id]) return false; root = tree[root][id]; if(!flagg[root] &amp;&amp; i==len-1) return false; //判断是否两个单词完全匹配 &#125; return true; &#125; void init()&#123; for (int i = 0; i &lt;= tot; i++) &#123; flagg[i] = false; for (int j = 0; j &lt; 30; j++) tree[i][j] = 0; &#125; tot = 0; //RE有可能是这里的问题 &#125; 优化trie树 当结点比较多，sigma_size比较大的时候，采用左儿子-右兄弟建立trie struct Trie &#123; int head[maxn]; &#x2F;&#x2F; head[i]为第i个结点的左儿子编号 int next[maxn]; &#x2F;&#x2F; next[i]为第i个结点的右兄弟编号 char ch[maxn]; &#x2F;&#x2F; ch[i]为第i个结点上的字符 int sz; &#x2F;&#x2F; 结点总数 void clear() &#123; sz &#x3D; 1; tot[0] &#x3D; head[0] &#x3D; next[0] &#x3D; 0; &#125; void insert(const char* s) &#123; int u &#x3D; 0, v, n &#x3D; strlen(s); tot[0]++; for (int i &#x3D; 0; i &lt; n; i++) &#123; bool found &#x3D; false; for (v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) if (ch[v] &#x3D;&#x3D; s[i]) &#123; found &#x3D; true; break; &#125; if (!found) &#123; v &#x3D; sz++; tot[v] &#x3D; 0; ch[v] &#x3D; s[i]; next[v] &#x3D; head[u]; head[u] &#x3D; v; head[v] &#x3D; 0; &#125; u &#x3D; v; tot[u]++; &#125; &#125; &#125;; 题单solution 0x01 统计难题 HDU 1251 link 0x02 背单词 LA 3942 link 0x03 strcmp()函数 UVa 11732 link 假如再来一遍银川","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"Trie","slug":"Trie","permalink":"https://maskros.top/tags/Trie/"}]},{"title":"kmp专题训练","slug":"algorithm/exercise/kmp_problem","date":"2021-11-26T13:59:50.000Z","updated":"2021-11-27T04:15:38.843Z","comments":true,"path":"/post/algorithm/exercise/kmp_problem.html","link":"","permalink":"https://maskros.top/post/algorithm/exercise/kmp_problem.html","excerpt":"kmp training","text":"kmp/ekmp 专题训练 🐴糙人蠢凑合看 0x01 剪花布条 HDU-2087 link 纯纯kmp裸题，不可重叠计数 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; void kmp_pre(string p, int next[]) &#123; int i, j; j &#x3D; next[0] &#x3D; -1; i &#x3D; 0; while (i &lt; p.length()) &#123; while (-1 !&#x3D; j &amp;&amp; p[i] !&#x3D; p[j]) j &#x3D; next[j]; next[++i] &#x3D; ++j; &#125; &#125; int kmp_Count(string x, string y, int next[]) &#123; int i, j; int ans &#x3D; 0; kmp_pre(x, next); i &#x3D; j &#x3D; 0; while (i &lt; y.length()) &#123; while (-1 !&#x3D; j &amp;&amp; y[i] !&#x3D; x[j]) j &#x3D; next[j]; i++; j++; if (j &gt;&#x3D; x.length()) &#123; ans++; j &#x3D; 0; &#x2F;&#x2F;不可重叠计数 &#125; &#125; return ans; &#125; int main()&#123; string a,b; int nxt[1005]; while(1)&#123; cin&gt;&gt;a; if(a&#x3D;&#x3D;&quot;#&quot;) break; else&#123; cin&gt;&gt;b; memset(nxt,0,b.length()+1); int ans&#x3D;kmp_Count(b,a,nxt); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; &#125; 0x02 Secret HDU-6153 link 题意： 给两个串s1,s2，求s2所有的后缀子串的长度乘在主串s1中出现的次数之和 解法： 挨个枚举后缀是🐷b做法，我们可以先把字符串翻转，这样后缀变前缀，就来到了我们熟悉的kmp匹配环节 解法一：exkmp 翻转后发现这不就正好利用extend[]数组的定义直接求解，做一遍ekmp，遍历extend[]数组，对每个值做 (1+entend[i])*entend[i]&gt;&gt;1 处理，全部加和即为答案 解法二：kmp 利用对next[]数组的理解，暂时鸽了，因为想了很久没想明白 解法一： ekmp 猛wa之后给了我深刻的教训：数组开 longlong😅😅 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; const int mod &#x3D; 1000000007; #define ll long long #define maxn 1000005 #define rep(i,x,y) for(int i&#x3D;x;i&lt;y;i++) ll nxt[maxn], extend[maxn]; void ekmp_pre(string x, ll next[]) &#123; int m &#x3D; x.length(); next[0] &#x3D; m; int j &#x3D; 0; while (j + 1 &lt; m &amp;&amp; x[j] &#x3D;&#x3D; x[j + 1]) j++; next[1] &#x3D; j; int k &#x3D; 1; for (int i &#x3D; 2; i &lt; m; i++) &#123; int p &#x3D; next[k] + k - 1; int L &#x3D; next[i - k]; if (i + L &lt; p + 1) next[i] &#x3D; L; else &#123; j &#x3D; max(0, p - i + 1); while (i + j &lt; m &amp;&amp; x[i + j] &#x3D;&#x3D; x[j]) j++; next[i] &#x3D; j; k &#x3D; i; &#125; &#125; &#125; ll ekmp(string x, string y, ll next[], ll extend[]) &#123; ekmp_pre(x, next); int j &#x3D; 0; ll ret &#x3D; 0; int m &#x3D; x.length(), n &#x3D; y.length(); while (j &lt; n &amp;&amp; j &lt; m &amp;&amp; x[j] &#x3D;&#x3D; y[j]) j++; extend[0] &#x3D; j; int k &#x3D; 0; for (int i &#x3D; 1; i &lt; n; i++) &#123; int p &#x3D; extend[k] + k - 1; int L &#x3D; next[i - k]; if (i + L &lt; p + 1) extend[i] &#x3D; L; else &#123; j &#x3D; max(0, p - i + 1); while (i + j &lt; n &amp;&amp; j &lt; m &amp;&amp; y[i + j] &#x3D;&#x3D; x[j]) j++; extend[i] &#x3D; j; k &#x3D; i; &#125; &#125; rep(i, 0, n) &#123; ret &#x3D; (ret % mod + (((1 + extend[i])* extend[i])&gt;&gt;1) % mod) % mod; &#125; return ret; &#125; int main() &#123; int t; ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; reverse(s.begin(), s.end()); reverse(p.begin(), p.end()); memset(nxt, 0, p.length() + 1); memset(extend, 0, s.length() + 1); ll ans; ans&#x3D;ekmp(p, s, nxt, extend); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; 解法二：kmp &#x2F;&#x2F; 寄 0x03 Cow Patterns POJ-3167 link 牛题 题意： 模式串可以浮动的模式匹配问题 给出模式串的相对大小顺序，需要找出在主串中模式串的匹配次数和起始位置 样例： S: 5 6 2 10 10 7 3 2 9 P: 1 4 4 3 2 1 故 2 10 10 7 3 2 符合要求，输出为 1 3 解法： KMP+前缀和 统计比当前数小，和于当前数相等的，然后进行kmp &#x2F;&#x2F;POJ 3167 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; const int MAXN &#x3D; 100005; const int MAXM &#x3D; 25005; int a[MAXN]; &#x2F;&#x2F; 存放主串 int b[MAXM]; &#x2F;&#x2F; 存放模式串 int as[MAXN][30]; &#x2F;&#x2F; as[i][j] &#x3D; k表示0 - i位中有k个数字j int bs[MAXM][30]; &#x2F;&#x2F; bs[i][j] &#x3D; k表示0 - i位中有k个数字j int next[MAXM]; &#x2F;&#x2F; 存放模式串失配时的移动位数 vector&lt;int&gt; ans; &#x2F;&#x2F; 存放结果 int n, m, s; void Init() &#123; ans.clear(); memset(as, 0, sizeof(as)); memset(bs, 0, sizeof(bs)); as[1][a[1]] &#x3D; 1; bs[1][b[1]] &#x3D; 1; for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123; memcpy(as[i], as[i - 1], sizeof(as[0])); ++as[i][a[i]]; &#125; for (int i &#x3D; 2; i &lt;&#x3D; m; ++i) &#123; memcpy(bs[i], bs[i - 1], sizeof(bs[0])); ++bs[i][b[i]]; &#125; &#125; void GetNext() &#123; memset(next, 0, sizeof(next)); int i &#x3D; 1, j &#x3D; 0, k &#x3D; 0; next[1] &#x3D; 0; while (i &lt;&#x3D; m) &#123; int si &#x3D; 0, sj &#x3D; 0, ei &#x3D; 0, ej &#x3D; 0; for (k &#x3D; 1; k &lt; b[i]; ++k) si +&#x3D; bs[i][k] - bs[i - j][k]; ei &#x3D; bs[i][k] - bs[i - j][k]; for (k &#x3D; 1; k &lt; b[j]; ++k) sj +&#x3D; bs[j][k]; ej &#x3D; bs[j][k]; if (0 &#x3D;&#x3D; j || (si &#x3D;&#x3D; sj &amp;&amp; ei &#x3D;&#x3D; ej)) next[++i] &#x3D; ++j; else j &#x3D; next[j]; &#125; &#125; void Kmp() &#123; int i &#x3D; 1, j &#x3D; 1, k &#x3D; 1; while (i &lt;&#x3D; n) &#123; int si &#x3D; 0, sj &#x3D; 0, ei &#x3D; 0, ej &#x3D; 0; for (k &#x3D; 1; k &lt; a[i]; ++k) si +&#x3D; as[i][k] - as[i - j][k]; ei &#x3D; as[i][k] - as[i - j][k]; for (k &#x3D; 1; k &lt; b[j]; ++k) sj +&#x3D; bs[j][k]; ej &#x3D; bs[j][k]; if (0 &#x3D;&#x3D; j || (si &#x3D;&#x3D; sj &amp;&amp; ei &#x3D;&#x3D; ej)) ++i, ++j; else j &#x3D; next[j]; if (j &#x3D;&#x3D; m + 1) &#123; ans.push_back(i - m); j &#x3D; next[j]; &#125; &#125; &#125; int main() &#123; while (scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s) &#x3D;&#x3D; 3) &#123; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) scanf(&quot;%d&quot;, &amp;b[i]); Init(); GetNext(); Kmp(); size_t len &#x3D; ans.size(); printf(&quot;%d\\n&quot;, len); for (size_t i &#x3D; 0; i &lt; len; ++i) printf(&quot;%d\\n&quot;, ans[i]); &#125; return 0; &#125;","categories":[{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"kmp","slug":"kmp","permalink":"https://maskros.top/tags/kmp/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"2021CCPC广州站vp","slug":"xcpc/2021ccpc_guangzhou","date":"2021-11-24T16:42:00.000Z","updated":"2022-01-25T07:51:49.608Z","comments":true,"path":"/post/xcpc/2021ccpc_guangzhou.html","link":"","permalink":"https://maskros.top/post/xcpc/2021ccpc_guangzhou.html","excerpt":"2021CCPC桂林站vp","text":"2021CCPC广州站vp “如何解方程” C_Necklace 二分+贪心 读题比较关键 没改明白wa3 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n')#include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (ll i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 1000005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; ll M,N; ll pos[maxn]; bool check(ll x)&#123; ll last=0,tmp,end; end=N-pos[M-1]+pos[0]; rep(i,0,M)&#123; if(i==0)&#123; if(end&lt;=x) &#123;last=end; end=0; continue;&#125; else&#123; end-=x; last=x; continue;&#125; &#125;eif(i==M-1) tmp=end+pos[i]-pos[i-1]; else tmp=pos[i]-pos[i-1]; ll can=pos[i]-pos[i-1]-1; can=(can>0)?can:0; ll sub=(x-last>can)?can:(x-last); if(tmp>=sub) tmp-=sub; else tmp=0; if(tmp&lt;=x) last=tmp; else return 0; &#125; return 1; &#125; void solve() &#123; // N=read(); M=read(); cin>>N>>M; ll ans=1,tmp,last=1; rep(i,0,M)&#123; cin>>pos[i]; &#125; if(M==1) &#123;cout&lt;&lt;N; return;&#125; ll l=1,r=N; while(l&lt;=r)&#123; ll mid=(l+r)>>1; if(check(mid))&#123; ans=mid; r=mid-1; &#125;else&#123; l=mid+1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; int main() &#123; int T = 1; IOS; // cin >> T; while (T--) &#123; solve(); &#125; &#125; H_Three Intergers (数学) 题意：给a,b,c，求满足x%y=a, y%z=b, z%x=c 的任意一组x,y,z 思路：数学题，方程化简，根据条件直接造，起初忘记了模的性质导致解不出方程，看了题解恍然大悟 题解 #include &lt;bits/stdc++.h> using namespace std; typedef long long ll; int main() &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) &#123; int a, b, c; cin >> a >> b >> c; if (a == b &amp;&amp; b == c) &#123; if (!a) &#123; cout &lt;&lt; \"YES\\n\"; cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; 1 &lt;&lt; \"\\n\"; &#125; else cout &lt;&lt; \"NO\\n\"; continue; &#125; ll x, y, z, k; if (b > a) &#123; k = max(0, (c - a) / b) + 1; x = k * b + a; y = b; z = (k * b + a) * 2 + c; &#125; else if (a > c) &#123; k = max(0, (b - c) / a) + 1; x = a; y = (k * a + c) * 2 + b; z = k * a + c; &#125; else if (c > b) &#123; k = max(0, (a - b) / c) + 1; x = (k * c + b) * 2 + a; y = k * c + b; z = c; &#125; else assert(false); cout &lt;&lt; \"YES\\n\"; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; \"\\n\"; assert(x % y == a &amp;&amp; y % z == b &amp;&amp; z % x == c); assert(x &lt;= 1e18); assert(y &lt;= 1e18); assert(z &lt;= 1e18); &#125; return 0; &#125; I_Pudding Store （打表） 手算了一下太麻烦，全排列打表找规律即可 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> #define mod 998244353 using namespace std; // 1 2 6 12 24 48 96 192 384 768 // int a[50]; // void init(int n)&#123; // rep(i,1,n+1) a[i]=i; // &#125; // void dfs()&#123; // rep(i,1,11)&#123; // ll cnt=0; // init(i); // bool t=true; // while(t)&#123; // bool can=false; // rep(j,1,i+1)&#123; // ll fuck=0; // rep(k,1,j+1)&#123; // fuck+=a[k]; // &#125; // fuck*=2; // if(fuck%j==0) can=true; // else &#123;can=false; break;&#125; // &#125; // if(can) cnt++; // t=next_permutation(a+1,a+i+1); // &#125; // cout&lt;&lt;cnt&lt;&lt;\" \"; // &#125; // &#125; ll qpow(ll a, ll b)&#123; ll ans=1; ll res=a; res%=mod; while(b)&#123;if(b&amp;1) ans=ans*res%mod; b>>=1; res=res*res%mod;&#125; return ans%mod; &#125; void solve() &#123; int n; cin>>n; if(n==1) cout&lt;&lt;1&lt;&lt;endl; eif(n==2) cout&lt;&lt;2&lt;&lt;endl; eif(n==3) cout&lt;&lt;6&lt;&lt;endl; else&#123; ll tmp=6; ll add=qpow(2,n-3); tmp=add%mod*tmp%mod; cout&lt;&lt;tmp&lt;&lt;endl; &#125; &#125; int main() &#123; int T = 1; IOS; // dfs(); cin >> T; while (T--) &#123; solve(); &#125; &#125; 总结：什么时候才能不粗心","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"打表","slug":"打表","permalink":"https://maskros.top/tags/%E6%89%93%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"贪心","slug":"贪心","permalink":"https://maskros.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"2021CCPC桂林站vp","slug":"xcpc/2021ccpc_guilin","date":"2021-11-23T16:03:00.000Z","updated":"2022-01-25T07:52:52.927Z","comments":true,"path":"/post/xcpc/2021ccpc_guilin.html","link":"","permalink":"https://maskros.top/post/xcpc/2021ccpc_guilin.html","excerpt":"2021CCPC桂林站vp","text":"2021CCPC桂林站vp ”祭奠擦肩而过的桂林两日游“ A_Hero Named Magnus 水题。为什么不ban猛犸？输出2n-1 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; ll x; cin>>x; ll ans; ans=x*2-1; cout&lt;&lt;ans&lt;&lt;endl; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; D_Assumption is All You Need 构造题 题意：给你两个序列A，B，对A可执行操作：若 iAj，可将Ai与Aj交换，问能否通过合法的操作将A变成B，并打印操作序列 思路：从屁股往前扫一遍，如果Ai和Bi不一样，就从A[Bi_pos]往前扫，寻求最优解，瞎JB贪心，wa2待补 E_Buy and Delete (图论) 题意：给了你一些带权有向边，Alice可以用已有的c元钱购买一些边形成一张有向图；随后Bob进行删边，每次可以删除一个无环的子集，Alice想最大化删边次数，Bob想最小化，二者都采取最优操作，问Bob需要删除几次 思路：答案只可能是0,1,2，0的情况是Alice一条边都买不起，1的情况是Alice买的无环图，2的情况是Alice买的带环图，无论有几个环，Bob都只需要删两次就够了，这个比较容易理解。 解法：直接把所有边存到一个有向图里，做Dijkstra找从v-&gt;v 的最短路，判断买不买得起就可以了 ps: 开始犯病用 n2 的Dij结果T了，换了 nlogn 的堆优化Dij就不T了；然后还在想改造一下Dij让起点为 i 的dist数组可以存 dist[i]，结果想了想直接Dij完了之后dist[j] + mincost[j][i] 不就是环的长度吗，wssb #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 1000000001 #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 2005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int n, m, c; struct qnode&#123; int v,c; qnode(int _v=0,int _c=0):v(_v),c(_c)&#123;&#125; bool operator &lt;(const qnode &amp;r)const&#123; return c>r.c; &#125; &#125;; struct Edge&#123; int v,cost; Edge(int _v=0,int _cost=0):v(_v),cost(_cost)&#123;&#125; &#125;; vector&lt;Edge>E[maxn]; bool vis[maxn]; int dist[maxn]; int mincost[maxn][maxn]; void Dijkstra(int start)&#123; memset(vis,false,sizeof(vis)); for(int i=1;i&lt;=n;i++)dist[i]=INF; priority_queue&lt;qnode>que; while(!que.empty()) que.pop(); dist[start]=0; que.push(qnode(start,0)); qnode tmp; while(!que.empty())&#123; tmp=que.top(); que.pop(); int u=tmp.v; if(vis[u])continue; vis[u]=true; for(int i=0;i&lt;E[u].size();i++)&#123; int v=E[tmp.v][i].v; int cost=E[u][i].cost; if(!vis[v]&amp;&amp;dist[v]>dist[u]+cost)&#123; dist[v]=dist[u]+cost; que.push(qnode(v,dist[v])); &#125; &#125; &#125; &#125; void addedge(int u,int v,int w)&#123; E[u].push_back(Edge(v,w)); &#125; int main() &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;c); int mncost=INF; int u, v, p; rep(i,1,n+1) rep(j,1,n+1) mincost[i][j]=INF; rep(i,0,m)&#123; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;p); addedge(u,v,p); mincost[u][v]=min(mincost[u][v],p); mncost=min(mncost,p); &#125; if(mncost>c)&#123; cout&lt;&lt;0; return 0; &#125; eif(mncost==c)&#123; cout&lt;&lt;1; return 0;&#125; rep(i,1,n+1)&#123; Dijkstra(i); rep(j,1,n+1)&#123; if(i!=j &amp;&amp; dist[j]+mincost[j][i]&lt;=c)&#123;cout&lt;&lt;2; return 0;&#125; &#125; &#125; cout&lt;&lt;1; return 0; &#125; G_Occupy the Cities 二分答案/dp 题意：一个01串，每次操作可以将串中所有的1的左边一位或右边一位也变成1，问变成全1串需要几次操作 解法：二分答案，check() 中从串的左边到右边对每一位1嗯贪心，dp解法没看 #include &lt;bits/stdc++.h> #define mp make_pair #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define maxn 1000005 #define pb push_back #define fst first #define sec second using namespace std; char s[maxn]; int n; vector&lt;int> one; int need[maxn]; void init(int t) &#123; scanf(\"%s\", s + 1); one.clear(); rep(i, 1, t + 1) &#123; need[i] = 0; if (s[i] == '1') &#123; one.pb(i); &#125; &#125; &#125; int check(int x) &#123; if (one[0] - 1 > x) return 0; if (one[0] - 1 == x) need[1] = 1; int tmp; rep(i, 1, one.size()) &#123; if (one[i] - one[i - 1] == 1) continue; tmp = one[i] - one[i - 1] - 1 + need[i]; if ((tmp + 1) / 2 > x) return 0; else if ((tmp + 1) / 2 == x) &#123; if (tmp / 2 == x) need[i + 1] = 1; &#125; &#125; tmp = n - one[one.size() - 1] + need[one.size()]; if (tmp > x) return 0; return 1; &#125; void solve() &#123; cin >> n; init(n); if (one.size() == n) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return; &#125; int l = 1, r = n; int ret = 0; while (l &lt;= r) &#123; int mid = (l + r) >> 1; //cout &lt;&lt; mid &lt;&lt; \" \" rep(i, 1, n + 2) need[i] = 0; if (check(mid)) &#123; ret = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; int main() &#123; int T; cin >> T; while (T--) &#123; solve(); &#125; &#125; I_PTSD 沙比题，不想复盘了 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 1000005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; char a[maxn]; void solve() &#123; int n; cin &gt;&gt; n; ll ret&#x3D;0; rep(i,0,n)&#123; cin&gt;&gt;a[i]; &#125; int lead&#x3D;0; int mxpos; red(i,n,0)&#123; if(a[i]&#x3D;&#x3D;&#39;0&#39;)&#123; lead++; &#125;else&#123; if(lead&gt;0)&#123; lead--; ret+&#x3D;(i+1); &#125;else&#123; lead++; &#125; &#125; &#125; cout&lt;&lt;ret&lt;&lt;endl; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; 总结：今天想出来D了吗","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"图论","slug":"图论","permalink":"https://maskros.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://maskros.top/tags/Dijkstra/"}]},{"title":"Educational Codeforces Round 117 (Div.2)","slug":"codeforces/cf Edu 117","date":"2021-11-23T10:02:00.000Z","updated":"2022-01-25T07:51:13.529Z","comments":true,"path":"/post/codeforces/cf Edu 117.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20117.html","excerpt":"Educational Codeforces Round 116 (Div.2)","text":"Educational Codeforces Round 117 (Rated for Div. 2)A_Distance 签到 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; void solve() &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; int xx &#x3D; -1, yy &#x3D; -1; int tot &#x3D; x + y; if (abs(tot) % 2 &#x3D;&#x3D; 1) &#123; cout &lt;&lt; xx &lt;&lt; &quot; &quot; &lt;&lt; yy &lt;&lt; endl; return; &#125; else &#123; if (abs(x) % 2 &#x3D;&#x3D; 0 &amp;&amp; abs(y) % 2 &#x3D;&#x3D; 0) &#123; cout &lt;&lt; x &#x2F; 2 &lt;&lt; &quot; &quot; &lt;&lt; y &#x2F; 2 &lt;&lt; endl; return; &#125; else &#123; tot &#x2F;&#x3D; 2; if (x &gt; y) cout &lt;&lt; tot &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; tot &lt;&lt; endl; &#125; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; B_Special_Permutation 贪心构造 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; int num[105]; bool vis[105]; void solve() &#123; int n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; memset(vis,0,sizeof(vis)); memset(num, 0, sizeof(num)); vis[a]&#x3D;1; vis[b]&#x3D;1; num[n&#x2F;2+1]&#x3D;b; num[1]&#x3D;a; int tmp&#x3D;1; bool find; rep(i,n&#x2F;2+2,n+1)&#123; find&#x3D;false; rep(j,tmp,b)&#123; if(!vis[j])&#123; vis[j]&#x3D;1; num[i]&#x3D;j; tmp&#x3D;j+1; find&#x3D;1; break; &#125; &#125; if(!find) &#123;cout&lt;&lt;-1&lt;&lt;endl; return;&#125; &#125; tmp&#x3D;n; rep(i,2,n&#x2F;2+1)&#123; find&#x3D;false; red(j,tmp+1,a)&#123; if(!vis[j])&#123; vis[j]&#x3D;1; num[i]&#x3D;j; tmp&#x3D;j-1; find&#x3D;1; break; &#125; &#125; if(!find) &#123;cout&lt;&lt;-1&lt;&lt;endl; return;&#125; &#125; rep(i,1,n+1)&#123; cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; C_Chat_Ban 题意： 输入k,x ; 你有2k-1条信息要发，信息的长度为1,2,3…k-1,k,k-1…1，在发出当前信息时，你已经发送的总长度必须小于x，问你最多能发多少条 思路： 二分答案即可 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; ll cal(ll begin, ll end)&#123; ll ret; if((begin+end)%2&#x3D;&#x3D;0)&#123; ret&#x3D;(begin+end)&#x2F;2*(end-begin+1); &#125;else&#123; ret&#x3D;(end-begin+1)&#x2F;2*(begin+end); &#125; return ret; &#125; void solve() &#123; ll k,x; cin&gt;&gt;k&gt;&gt;x; ll ans&#x3D;0; ll test&#x3D;cal(1,k); if(test&#x3D;&#x3D;x)&#123; cout&lt;&lt;k&lt;&lt;endl; return; &#125;eif(test&lt;x)&#123; ans+&#x3D;k; x-&#x3D;test; test&#x3D;cal(1,k-1); if(test&lt;&#x3D;x)&#123; cout&lt;&lt;2*k-1&lt;&lt;endl; return;&#125; else&#123; ll l&#x3D;1,r&#x3D;k; ll mid; ll tmp&#x3D;0; while(l&lt;&#x3D;r)&#123; mid&#x3D;(l+r)&gt;&gt;1; test&#x3D;cal(mid,k-1); if(test&#x3D;&#x3D;x)&#123; tmp&#x3D;k-mid; break; &#125;eif(test&lt;x)&#123; tmp&#x3D;k-mid+1; r&#x3D;mid-1; &#125;else&#123; l&#x3D;mid+1; &#125; &#125; ans+&#x3D;tmp; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;else&#123; ll l&#x3D;1,r&#x3D;k; ll mid; while(l&lt;&#x3D;r)&#123; mid&#x3D;(l+r)&gt;&gt;1; test&#x3D;cal(1,mid); if(test&#x3D;&#x3D;x)&#123; ans&#x3D;mid; break; &#125;eif(test&lt;x)&#123; ans&#x3D;mid+1; l&#x3D;mid+1; &#125;else&#123; r&#x3D;mid-1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; D_X_Magic_Pair (gcd) 题意： 给你 a, b, x，每次操作可以将a或b替换为 |a-b|, 询问能否将a或b进行任意次操作后替换为 x 思路： gcd变种，每次判断一下 a%b 是否等于 x%b，即 (a-x)%b==0 ，如果相等即为YES，否则即为NO #include &lt;bits/stdc++.h> #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; ll a, b, x; bool gcd(ll a, ll b)&#123; if(a==x||b==x) return 1; if(b==0) return 0; if(a>x&amp;&amp;(a-x)%b==0) return 1; if(b>x&amp;&amp;(b-x)%a==0) return 1; return gcd(b,a%b); &#125; void solve() &#123; cin>>a>>b>>x; if(x>a&amp;&amp;x>b)&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; return; &#125; if(x==a||x==b)&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; return;&#125; ll tmpa=(a>b)?a:b; ll tmpb=(b&lt;a)?b:a; if(gcd(tmpa,tmpb)) puts(\"YES\"); else puts(\"NO\"); &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; 总结仨签到很顺溜，最后一个题因为判断条件结果sb了，掉分","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"gcd","slug":"gcd","permalink":"https://maskros.top/tags/gcd/"}]},{"title":"进行一个毛概题库的爬","slug":"projects/maogai_crawler","date":"2021-11-10T14:43:00.000Z","updated":"2021-12-25T07:17:11.282Z","comments":true,"path":"/post/projects/maogai_crawler.html","link":"","permalink":"https://maskros.top/post/projects/maogai_crawler.html","excerpt":"Crawler in THEOL","text":"进行一个毛概题库的爬 前言：🐷b毛概题库要截止了，几个时间段的题库各自有截止日期😅，眼见着ddl就要到了可👴又不想去刷，所以萌生了借助python爬虫来进行偷懒的想法 办事流程 由于之前👴说过：“python狗都不用”，“用python的都沙比” 的名言，所以一开始是拒绝的，但是迫于现状，所以简单突击了几天，学到了一些知识，实战用到的也就只有不到 1/5 需求： 题库共计一百多道题目，每次测试15道题，5单选5多选5判断，提交做题结果之后方可获得所有题的正确答案，所以我们的思路就是从所有测试尝试的反馈页面中爬取题目题面和正确答案并持久化存储，over 原先步骤(全自动) 模拟登录 由于这个b bb平台需要信息门户登录成功之后才能做那b题，所以需要模拟登陆之后才能请求到做题结果的页面，所以我们利用session会话对象在向登录页面发起请求后储存cookie，这样后面直接用session对象再对需求的页面进行get请求即可。 自动做题 自动开始新尝试并且提交 开爬 get到了页面之后，利用xpath进行数据解析，持久化存储即可 想法很好，后来出现了一些问题，所以以下是最终流程： 现实步骤(几乎全自动) 2021/11/13 更新了 v1.1 版本：①优化了存储方式：按字典序排序即按题目的章节进行分类；②实现了 v1.0 没实现的自动做题功能 模拟登录(x) 手动登录(√) 按照原先的想法模拟登陆，返回的消息也是登陆成功，但是请求所需页面是还是被拦截了，需要重新登录，由于才疏学浅，一时不知道如何是好，干脆直接手动登录后，利用浏览器F12，找到登录的cookie，手动复制到源码中的 headers 内，直接用 requests 进行 post 和 get 的请求即可获得所需页面 自动做题(√) 开始新尝试：发现开始新尝试的按钮中对应的 &lt;a&gt;标签的 url 中的参数有个有趣的地方 new_attempt=1，直接访问即可以开始一次新的尝试，直接get请求即可 提交新尝试：点击提交按钮后进行抓包，发现有一个post请求对应的 url : do/take/saveAttempt?saveSequence=1/... ，观察数据包中传输的数据发现有这样几个有趣的地方：data_submitted:true, save_and_submit:true；我们猜测这就是对服务器进行的提交结果请求。之后对比两次不同的提交所得的数据包发现，所需修改的参数为current_attempt_id 和 current_attempt_id_backup，二者是一样的，于是观察哪里有这个id，发现和做题页面中的&lt;div&gt;标签的类名有着惊人的一致🤠。直接对做题页面进行xpath解析，解析到div标签的类名传输进post请求的数据中，再发送post请求即可完成自动提交新尝试😪 自动开爬 ！(√) get到所有尝试的页面，利用xpath解析到对应每次做题结果的 &lt;a&gt; 标签的href地址存到 list 中，拼接成完整的url 对每个url 利用xpath解析到对应题目和答案的标签，根据题目类型分别存储，利用字典存储，题目名称为key，题目答案为value，为了防止存储重复题目，每次存储前先查询key是否存在，不存在再存入字典中，写入文件的同时计数器+1，方便统计爬取题目的个数 冻手冻手 🐴来import requests from lxml import etree import os import time if __name__ == '__main__': # 创建文件夹 if not os.path.exists('./maogai/Round_2/'): os.mkdir('./maogai/Round_2/') session = requests.Session() detail_url = 'https://wlkc.ouc.edu.cn' # 使用现成的cookie直接绕过登录页面 headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36', 'Cookie': 'JSESSIONID=AC1DEAF6D6037A4B310E53885942338D; LOGIN=3139303230303331303330; UM_distinctid=17bcb2f4e579ab-0e328a4e032f8-a7d193d-144000-17bcb2f4e58315; SCREEN_NAME=4f566b646b73396b79642f396274486b665a503656773d3d; session_id=4025A5EAD4245D545DCB1E8FD2D1EE4E; s_session_id=864B98DCC97327775D6853902DCD0138; web_client_cache_guid=871e5dc2-27ae-44b8-898f-a44d97e217f2', &#125; # 自动请求开始测试和提交 times_att为次数 每次请求间隔3s times_att = 10 print('attempt started...') for i in range(0,times_att): # 请求测试 attempt_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/take/launch.jsp?course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;new_attempt=1&amp;content_id=_633969_1&amp;step=' atmp = session.get(url=attempt_url, headers=headers) # 拿到本次测试id do_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/take/launch.jsp?course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;content_id=_633969_1&amp;step=null' do = session.get(url=do_url, headers=headers) tree_att = etree.HTML(do.text) atnum = tree_att.xpath('//div[@class=\"takeQuestionDiv \"]/@id')[0] print('attemptid = ' + str(atnum)) # 提交本次测试 submit_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/do/take/saveAttempt?saveSequence=17&amp;takePageId=1636771783088&amp;course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;content_id=_633969_1' data = &#123; 'blackboard.platform.security.NonceUtil.nonce.ajax': 'c87385ed-48d7-4d9c-8c8c-a9f6cb45826d', 'data-submitted': 'true', 'course_assessment_id': '_30131_1', 'course_id': '_13492_1', 'content_id': '_633969_1', 'step': '', 'original_user_id': '_47406_1', 'save_and_submit': 'true', 'timer_completion': '', 'fileUploadType': '', 'toggle_state': 'qShow', 'current_question': '1', 'current_attempt_item_id': atnum, 'current_attempt_item_id_backup': atnum, 'method': 'notajax', 'saveonequestion': '', &#125; submit = session.post(url=submit_url, headers=headers, data=data) print('post finished! times: '+ str(i+1)) time.sleep(3) print('attempt over!') print('--------------------') # 总尝试页面 total_url = 'https://wlkc.ouc.edu.cn/webapps/gradebook/do/student/viewAttempts?method=list&amp;course_id=_13492_1&amp;outcome_definition_id=_95191_1&amp;outcome_id=_2069239_1' page_text_tot = session.get(url=total_url, headers=headers) tree_tot = etree.HTML(page_text_tot.text) attempt_list = tree_tot.xpath('//div[@class=\" columnStep clearfix\"]//a/@href') # 为了去重使用字典保存键值对 danxuan = &#123;&#125; duoxuan = &#123;&#125; panduan = &#123;&#125; cnt1 = 0 cnt2 = 0 cnt3 = 0 fp1 = open('./maogai/Round_2/单选.txt', 'w', encoding='utf-8') fp2 = open('./maogai/Round_2/多选.txt', 'w', encoding='utf-8') fp3 = open('./maogai/Round_2/判断.txt', 'w', encoding='utf-8') times = 0 print('download started...') for attempt in attempt_list: times = times + 1 new_url = detail_url + attempt # print(new_url) page_text = session.get(url=new_url, headers=headers) tree = etree.HTML(page_text.text) pro_list = tree.xpath('//ul[@id=\"content_listContainer\"]/li') cnt = 0 # 每次尝试的内容进行爬取 for li in pro_list: cnt = cnt + 1 pro_name = li.xpath('normalize-space(.//div[@class=\"vtbegenerated inlineVtbegenerated\"])') pro_answer_1 = li.xpath('.//div[@class=\"vtbegenerated inlineVtbegenerated\"]//label/text()') pro_answer_1 = str(pro_answer_1) pro_answer_2 = li.xpath('normalize-space(.//span[@class=\"answerTextSpan\"])') if cnt &lt;= 5: if pro_name not in danxuan: cnt1 = cnt1 + 1 danxuan[pro_name] = pro_answer_1 # fp1.write(str(cnt1) + '. ' + pro_name+'\\n'+pro_answer_1+'\\n') elif cnt &lt;= 10: if pro_name not in duoxuan: cnt2 = cnt2 + 1 duoxuan[pro_name] = pro_answer_1 # fp2.write(str(cnt2) + '. ' + pro_name + '\\n' +pro_answer_1+'\\n') else: if pro_name not in panduan: cnt3 = cnt3 +1 panduan[pro_name] = pro_answer_2 # fp3.write(str(cnt3) + '. ' + pro_name + '\\n'+pro_answer_2+'\\n') print('times: ' + str(times) + ' 单选: ' + str(cnt1) + ',多选：' + str(cnt2) + ',判断: ' + str(cnt3) ) # 将字典进行按key排序实现不同章节分类进行存储 num = 0 for pro in sorted(danxuan): num = num + 1 fp1.write(str(num)+'. '+ pro + '\\n' + danxuan[pro] + '\\n') num = 0 for pro in sorted(duoxuan): num = num + 1 fp2.write(str(num)+'. ' + pro + '\\n' + duoxuan[pro] + '\\n') num = 0 for pro in sorted(panduan): num = num + 1 fp3.write(str(num)+'. ' + pro + '\\n' + panduan[pro] + '\\n') fp1.close() fp2.close() fp3.close() print('total: ' + str(cnt1+cnt2+cnt3) + ' problems have been downloaded.') 一个小实战，效果还行😅，以后会想办法修改自动登录的问题，可以提点意见 github项目地址 link 爬取的题库在文件夹里 over大火","categories":[{"name":"PROJECT","slug":"PROJECT","permalink":"https://maskros.top/categories/PROJECT/"}],"tags":[{"name":"Crawler","slug":"Crawler","permalink":"https://maskros.top/tags/Crawler/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"},{"name":"requests","slug":"requests","permalink":"https://maskros.top/tags/requests/"}]},{"title":"python爬虫杂记","slug":"note/Crawler","date":"2021-11-10T09:03:30.000Z","updated":"2022-01-22T09:37:42.226Z","comments":true,"path":"/post/note/Crawler.html","link":"","permalink":"https://maskros.top/post/note/Crawler.html","excerpt":"Crawler in python","text":"python爬虫杂记Crawler in python 又名 《为了偷懒爬毛概题库的突击学习》 一些知识 爬虫在使用场景中的分类： 通用爬虫：抓取系统重要促成部分，抓取的是一整张页面数据 聚焦爬虫：是建立在通用爬虫的基础上，抓取的是页面中特定的局部内容 增量式爬虫：检测网站中数据更新的情况，只会抓取网站中最新更新出来的数据 robots.txt协议：君子协议，规定网站中哪些数据能爬哪些不能，约定俗成 http &amp; https 协议： http协议：服务器和客户端进行数据交互的一种形式 https协议：安全的超文本传输协议 证书秘钥加密 常用请求头信息： User-Agent：请求载体的身份标识 Connection：请求完毕后，是断开连接还是保持连接 常用响应头信息： Content-Type：服务器响应回客户端的数据类型 requests模块 requests: python原生的基于网络请求的模块，模拟浏览器发请求 .text 字符串 .content 二进制 .json() 对象 编码流程： 指定url 发起请求 获取响应数据 持久化存储 0x00 requests 一血 response.text import requests # 1.指定url url='xxxx/xxx/xxx.xxx' # 2.发起请求 get方法会返回一个响应对象 response = requests.get(url=url) # 3.获取响应数据 .text返回的是字符串形式的响应数据 page_text = response.text print(page_text) # 4.持久化存储 with open('./xxx.html','w',encoding='utf-8') as fp: fp.write(page_text) print('over!') 0x01 网页采集器 UA检测 UA伪装 requests.get(url, params, headers) import requests # UA：User-Agent 请求载体的身份标识 # UA检测：门户网站的服务器会检测对应请求的载体身份标识，如果检测到的标识为基于某一款浏览器的， # 则说明是正常请求，反之服务端就可能拒绝这次请求 # UA伪装：让爬虫对应的请求载体身份标识伪装成某一款浏览器 if __name__ == '__main__': # UA伪装：将对应的User-Agent封装到一个字典中 headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; url = 'https://www.sogou.com/web' # 处理url携带的参数：封装到字典中 kw = input('enter a word:') param = &#123; 'query': kw &#125; # 对指定url发起的请求对应url是携带参数的，并且请求过程中处理了参数 response = requests.get(url=url, params=param, headers=headers) page_text = response.text fileName = './requests_test/test2/'+kw+'.html' with open(fileName, 'w', encoding='utf-8') as fp: fp.write(page_text) print(fileName, ' is saved') 0x02 百度翻译 post请求 (携带了参数) ajax 响应数据是一组json数据 requests.post(url, data, json, headers...) response.json() import requests import json if __name__ == '__main__': # 1.指定url post_url = 'https://fanyi.baidu.com/sug' # 2.进行UA伪装 headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; # 3.post请求参数处理(同get请求一致) word = input('enter a word') data = &#123; 'kw': word &#125; # 4.请求发送 response = requests.post(url=post_url, data=data, headers=headers) # 5.获取响应数据:json()方法返回的是obj(如果确认响应数据是json类型才能使用) dic_obj=response.json() print(dic_obj) # 6.持久化存储 fileName = './requests_test/test3/'+word+'.json' fp = open(fileName,'w',encoding='utf-8') # 由于中文不能用ascii编码，所以令ensure_ascii=False json.dump(dic_obj,fp=fp,ensure_ascii=False) print('over!') 0x03 豆瓣电影 request.get import requests import json if __name__ == '__main__': url = 'https://movie.douban.com/j/chart/top_list' param = &#123; 'type': '24', 'interval_id': '100:90', 'action': '', 'start': '40', # 从库中的第几部电影去取 'limit': '20', # 一次从库中取出的个数 &#125; headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; response = requests.get(url=url, params=param, headers=headers) list_data = response.json() # print(list_data) fp = open('./requests_test/test4/douban.json', 'w', encoding='utf-8') json.dump(list_data, fp=fp, ensure_ascii=False) print('over!') 0x04 综合案例-数据提取import requests import json if __name__ == '__main__': headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; id_list = [] # 存储企业id all_data_list = [] # 存储所有的企业详情数据 # 批量获取不同企业的id值 url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsList' # 参数的封装 for page in range(1,6): page=str(page) data = &#123; 'on': 'true', 'page': page, 'pagesize': '15', 'productName': '', 'conditionType': '1', 'applyname': '', 'applysn': '', &#125; json_ids = requests.post(url=url, headers=headers, data=data).json() for dic in json_ids['list']: id_list.append(dic['ID']) # 获取企业详细数据 post_url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById' for id in id_list: data = &#123; 'id': id &#125; detail_json = requests.post( url=post_url, headers=headers, data=data).json() print(detail1_json, '--------ending--------') all_data_list.append(detail_json) # 持久化存储all_data_list fp = open('./requests_test/test5/allData.json', 'w', encoding='utf-8') json.dump(all_data_list, fp=fp, ensure_ascii=False) print('over!') 数据解析 聚焦爬虫：爬取页面中指定的页面内容 编码流程： 指定url 发起请求 获取响应数据 数据解析 持久化存储 数据解析分类：正则，bs4，xpath 数据解析原理概述： 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储 进行指定标签的定位 标签或者标签对应的属性中存储的数据值进行提取 (解析) 0x00 图片 .content 返回二进制 import requests if __name__ == '__main__': # 如何爬取图片数据 url = 'https://i2.hdslb.com/bfs/archive/237001f0163eb48c1745a906c5b480f449183d66.jpg@672w_378h_1c_100q.webp' # content 返回的是二进制形式图片数据 img_data = requests.get(url=url).content with open('./data_parse_test/test1/dsm.jpg','wb') as fp: fp.write(img_data) 0x01 正则解析 需要导入re模块 常用正则表达式 ex: &lt;div class=\"test\"> &lt;a href=\"/dsadas/sdada\" target=\"_blank\"> &lt;img src=\"//sdadasd/dsadas/dasdas\" alt=\"sdada\"> &lt;/a> &lt;/div> ex='&lt;div class=\"test\">.*?&lt;img src=\"(.*?)\" alt .*?&lt;/div>' 练习：图片分页爬取 import requests import re import os # 需求：爬取所有图片 if __name__ == '__main__': headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; #创建文件夹，保存所有图片 if not os.path.exists('./data_parse_test/test1'): os.mkdir('./data_parse_test/test1/') #设置一个通用url模板 url = 'https://www.qiushibaike.com/pic/page/%d/?s=5184961' for pageNum in range(1,36): #对应页码的url new_url = format(url%pageNum) # 使用通用爬虫对url对应的一整张页面进行爬取 page_text = requests.get(url=url, headers=headers).text # 使用聚焦爬虫将页面中所有漫画进行解析/提取 ex = '&lt;div class=\"thumb\">.*?&lt;img src=\"(.*?)\" alt.*?&lt;/div> ' img_src_list = re.findall(ex, page_text, re.S) # print(img_src_list) for src in img_src_list: #拼接出一个完整的图片url src='https:'+src #请求到了图片的二进制数据 img_data=requests.get(url=src,headers=headers).content #生成图片名称 img_name=src.split('/')[-1] #图片存储的路径 imgPath='./data_parse_test/test1/'+img_name with open(imgPath,'wb') as fp: fp.write(img_data) print(img_name,'下载成功！') 0x02 bs4解析 所需模块：bs4 lxml 数据解析的原理： 标签定位 提取标签、标签属性中存储的数据值 bs4数据解析的原理： 实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中 通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取 如何实例化Beautiful对象： from bs4 import BeautifulSoup 对象的实例化：将本地/互联网上获取的页面源码加载到该对象中 soup=BeautifulSoap(page_text.content,&#39;lxml&#39;) 提供的用于数据解析的方法和属性： soup.tagName 对应html标签 返回的是html中第一次出现的tagName标签 soup.find() : soup.find(&#39;tagName&#39;) 同 soup.tagName 属性定位：soup.find(&#39;tagName&#39;,class_=&#39;xxx&#39;) (class要带下划线) soup.find_all(&#39;tagName&#39;) 返回所有的标签(列表) soup.select() soup.select(&#39;某种选择器(id,class,标签...)&#39;)，返回的是一个列表 #id, tag, .class 层级选择器： soup.select(&#39;.class1 &gt; ul &gt; li &gt; a&#39;)[2] 表示 class1 下的 ul 标签下的 li 标签中的第二个 a 标签。 &gt; 表示一个层级关系 soup.select(&#39;.class1 &gt; ul a&#39;)[2] 表示同上，空格表示的是多个层级关系 获取标签之间的文本数据 soup.a.text/string/get_text() .text/.get_text() 可以获得某一个标签中所有的文本内容 .string 只可以获取改标签下面直系的文本内容 获取标签中属性值 soup.a[&#39;href&#39;] 练习：小说章节名和内容爬取 import requests import lxml from bs4 import BeautifulSoup # 需求：爬取小说的所有章节标题和内容 if __name__ == '__main__': if not os.path.exists('./data_parse_test/test2'): os.mkdir('./data_parse_test/test2/') headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; # 对首页的页面进行爬取 url = 'http://www.banzhu22.org/5_5853/' page_text = requests.get(url=url, headers=headers) # 在首页中解析出章节的标题和详情页的url # 1. 实例化BeautifulSoup对象，将网页源码加载到对象中 soup = BeautifulSoup(page_text.content, 'lxml') dd_list = soup.select('.box_con > #list dd')[9:] fp = open('./data_parse_test/test2/49gifts.txt', 'w', encoding='utf-8') for dd in dd_list: title = dd.a.string detail_url = 'http://www.banzhu22.org' + dd.a['href'] # 对详情页发起请求，解析出章节内容 detail_page_text = requests.get(url=detail_url, headers=headers) # 解析出详情页中相关章节的内容 detail_soup = BeautifulSoup(detail_page_text.content, 'lxml') div_tag = detail_soup.find('div', id='content') # 解析到章内容 content = div_tag.text fp.write(title+'\\n'+content+'\\n') print(title+'downloaded successfully!') print('over!') 0x03 xpath解析 是最常用且最便捷高效的爬取方式，通用性最强 所需模块：lxml xpath解析原理： 实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中 调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获 如何实例化etree对象： from lxml import etree 本地源码：etree.parse(filePath) 互联网源码：etree.HTML(&#39;page_text&#39;) xpath(&#39;xpath表达式&#39;) xpath表达式： 各表达式可以用 | 连接 /：表示的是一个层级，从根节点开始定位 开头./：定位了层级后，当前层级下的层级 //：表示的是多个层级，可以从任意位置开始定位 属性定位：//div[@class=&quot;xxx&quot;] 即 tag[@attrName=&quot;attrValue&quot;] 索引定位：//div[@class=&quot;xxx&quot;]/p[3] 索引是从1开始的 取文本： /text() 标签下直系的文本内容 //text() 标签下所有的文本内容 取属性：/@attrName 通用处理中文乱码的解决方案 name = name.encode('iso-8859-1').decode('gbk') 练习略 验证码识别反爬机制：验证码 识别验证码的操作： 第三方自动识别：云打码 to be added…. 模拟登陆需求：对校园网进行登陆 (无验证码) 点击登陆按钮后会发起一个POST请求，POST请求中会携带登录信息(username,pwd) print(response.status_code) 打印响应状态码，如果打印200则证明模拟登陆成功 需求：爬取当前用户的相关信息 http/https协议特性：无状态 没有请求到对应页面数据的原因：发起的第二次基于页面的请求时，服务器端不知道此次请求是基于登录状态下的请求 cookie：用来让服务端记录客户端的相关状态 cookie值的来源是哪里：模拟登陆post请求后，有服务器端创建 session会话对象： 可以进行请求的发送 如果请求过程中产生了cookie，则cookie会被自动存储/携带在该session对象中 步骤： 创建一个session对象： session = requests.Session() 使用session对象进行模拟登录post请求的发送 (cookie就会被存储在session中) session对象再对登录后页面对应的get请求进行发送 (携带了cookie) selenium工具 解决requests无法执行javaScript代码的问题 用于web应用程序自动化测试的工具，直接运行在浏览器当中，支持chrome、firefox等主流浏览器。可以通过代码控制与页面上元素进行交互（点击、输入等），也可以获取指定元素的内容 缺点： 效率低，速度慢 to be added …","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"Crawler","slug":"Crawler","permalink":"https://maskros.top/tags/Crawler/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"}]},{"title":"2021CCPC女生专场vp","slug":"xcpc/2021ccpc_girl","date":"2021-11-08T14:25:00.000Z","updated":"2022-01-22T09:35:29.311Z","comments":true,"path":"/post/xcpc/2021ccpc_girl.html","link":"","permalink":"https://maskros.top/post/xcpc/2021ccpc_girl.html","excerpt":"2021年中国大学生程序设计竞赛女生专场","text":"2021CCPC女生专场 “假如我是女生” A_公交线路 水题 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int n,x,y; cin>>n>>x>>y; int k[20]; rep(i,1,n+1) cin>>k[i]; int m; cin>>m; int p[20]; rep(i,1,m+1) cin>>p[i]; int lpos=x-1,rpos=x+1; rep(i,1,m+1)&#123; if(k[lpos]!=p[i])&#123; if(y&lt;x) &#123;cout&lt;&lt;\"Wrong\"&lt;&lt;endl; return;&#125; else &#123;cout&lt;&lt;\"Right\"&lt;&lt;endl; return;&#125; &#125; if(k[rpos]!=p[i])&#123; if(x&lt;y) &#123;cout&lt;&lt;\"Wrong\"&lt;&lt;endl; return;&#125; else &#123;cout&lt;&lt;\"Right\"&lt;&lt;endl; return;&#125; &#125; lpos--; rpos++; &#125; cout&lt;&lt;\"Unsure\"&lt;&lt;endl; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; D_修建道路 沙比题，两两取最大值即可，脂环王写了一发线段树优化递归我不是很认可 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 200005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int a[maxn]; void solve() &#123; int n; cin >> n; ll ans = 0; rep(i, 0, n) &#123; cin >> a[i]; if(i>0) ans+=max(a[i],a[i-1]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; G_3G网络 输出1/n即可 我搞错了double 结果wa在精度上了 最后手写了个除法 结果发现 printf(“%.16lf”,ans) 即可，少写个小数点😅 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int n; cin>>n; int x,y; rep(i,0,n)&#123; cin>>x>>y; &#125; int ans[15]; rep(i,0,12)&#123; if(i==0)&#123; if(n==1) &#123;ans[0]=1; tmp=0;&#125; else &#123;ans[0]=0; tmp*=10;&#125; &#125;else&#123; ans[i]=tmp/n; tmp=tmp%n; tmp*=10; &#125; &#125; cout&lt;&lt;ans[0]&lt;&lt;\".\"; rep(i,1,12)&#123; cout&lt;&lt;ans[i]; &#125; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; // ans=1.0/n // printf(\"%.16lf\",ans); I_驾驶卡丁车 楞模拟就行，八个方向 dis[8][2] 直接做掉啊做掉 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; char mp[55][55]; int dis[8][2] = &#123; &#123;-1, 0&#125;, &#123;-1, -1&#125;, &#123;0, -1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;0, 1&#125;, &#123;-1, 1&#125;&#125;; int n, m, x, y, v, face; bool crsh=0; bool check(int x, int y) &#123; if (x &lt;= 0 || x > n || y &lt;= 0 || y > m) return false; if (mp[x][y] == '#') return false; else return true; &#125; void go()&#123; rep(j, 0, v) &#123; if (dis[face][0] != 0 &amp;&amp; dis[face][1] != 0) &#123; if (!check(x + dis[face][0], y) &amp;&amp; !check(x, y + dis[face][1])) &#123; crsh = true; v = 0; break; &#125; &#125; if (check(x + dis[face][0], y + dis[face][1])) &#123; x += dis[face][0]; y += dis[face][1]; &#125; else &#123; crsh = true; v = 0; break; &#125; &#125; &#125; void solve() &#123; cin >> n >> m; v=0, face=0; rep(i, 1, n+1) &#123; rep(j, 1, m+1) &#123; cin >> mp[i][j]; if (mp[i][j] == '*') &#123; x = i, y = j; &#125; &#125; &#125; int opcnt; cin >> opcnt; char op; crsh = false; rep(i, 0, opcnt) &#123; cin >> op; crsh = false; if (op == 'L') &#123; face++; if (face > 7) &#123; face = 0; &#125; go(); &#125; eif(op == 'R') &#123; face--; if (face &lt; 0) &#123; face = 7; &#125; go(); &#125; eif(op == 'U') &#123; v++; go(); &#125; eif(op == 'D') &#123; v = max(v - 1, 0); go(); &#125; if (crsh) cout &lt;&lt; \"Crash! \"; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; &#125; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; K_音乐游戏 沙比题 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; void solve() &#123; int n; cin&gt;&gt;n; string s; int cnt&#x3D;0; rep(i,0,n+1)&#123; getline(cin,s); rep(j,0,s.length())&#123; if (s[j] &#x3D;&#x3D; &#39;-&#39;) cnt++; &#125; &#125; cout&lt;&lt;cnt; &#125; int main() &#123; int T &#x3D; 1; &#x2F;&#x2F; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; 总结：再次化身签到皇帝，还在想B题的字符串，请把“今天想出来B了吗”打在评论区😘","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"Codeforces Round 752 (Div.2)","slug":"codeforces/cf 752","date":"2021-10-31T14:50:00.000Z","updated":"2022-01-25T07:50:06.014Z","comments":true,"path":"/post/codeforces/cf 752.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20752.html","excerpt":"Codeforces Round 750 (Div.2)","text":"Codeforces Round #752 (Div.2)A_Era 水题 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int n; cin >> n; ll ans = 0; int t; int pos = 1; rep(i, 1, n + 1) &#123; cin >> t; if (t > pos) &#123; ans += t - pos; pos += t - pos; &#125; pos++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; B_XOR_Specia_LIS_t 题意： 沙比题，如果序列所分成的若干子序列中，最长的任意递增序列(不需要连续)的长度相异或，可以为0则输出 yes 否则输出 no 思路： 没说咋分，就一个一个分，所以就是 1^1^1^… ，根据序列长度的奇偶性判断一下即可，偶数一定yes，奇数就判断是不是单增序列，不是的话一定yes，反之no #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int a[maxn]; void solve() &#123; int n; cin>>n; int tmp; rep(i,0,n)&#123; cin >> a[i]; &#125; bool is=false; if(n&amp;1)&#123; rep(i,1,n)&#123; if(a[i]&lt;=a[i-1])&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; is=true; break; &#125; &#125; if(!is) cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; C_Di_visible_Confusion 题意： 一个序列，可以对a[i]进行删除操作的前提是 a[i]%(i+1)!=0，问这个序列能不能被删干净 思路： 暴力即可 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int a[maxn]; void solve() &#123; int n; cin>>n; rep(i,1,n+1)&#123; cin>>a[i]; &#125; bool flag=false; rep(i,1,n+1)&#123; flag=false; rep(j,2,i+2)&#123; if(a[i]%j!=0)&#123; flag=true; break; &#125; &#125; if(!flag)&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; return; &#125; &#125; cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; D_Vupsen_Pupsen_and_0 题意： 输入x,y 两个偶数，找出 n，使得 n%x=y%n 思路： 分类讨论即可： x&gt;y 时，n=x+y x&lt;y 时，n=y-(y%x)/2 考虑特例 思考不出来的时候画数轴可以给你灵感 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; ll x, y; cin >> x >> y; if (x == y) &#123; cout &lt;&lt; x &lt;&lt; endl; return; &#125; if (x > y) &#123; cout &lt;&lt; x + y &lt;&lt; endl; &#125; else &#123; if (y % x == 0) &#123; cout &lt;&lt; x &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; y - (y % x) / 2 &lt;&lt; endl; &#125; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125;","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Educational Codeforces Round 116 (Div.2)","slug":"codeforces/cf Edu 116","date":"2021-10-30T06:02:00.000Z","updated":"2021-12-25T07:17:35.361Z","comments":true,"path":"/post/codeforces/cf Edu 116.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20116.html","excerpt":"Educational Codeforces Round 116 (Div.2)","text":"Educational Codeforces Round 116 (Rated for Div. 2)A_AB_Balance 题意： 由ab构成的串，做最少操作使ab和ba出现的次数相同 思路： 如果出现次数不同，最多差1，修改首位即可 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; void solve() &#123; string s; cin &gt;&gt; s; int l &#x3D; s.length(); int ab &#x3D; 0, ba &#x3D; 0; rep(i, 0, l) &#123; if (s[i] &#x3D;&#x3D; &#39;a&#39;) &#123; if (s[i + 1] &#x3D;&#x3D; &#39;b&#39;) ab++; &#125; if (s[i] &#x3D;&#x3D; &#39;b&#39;) &#123; if (s[i + 1] &#x3D;&#x3D; &#39;a&#39;) ba++; &#125; &#125; if (ab &#x3D;&#x3D; ba) cout &lt;&lt; s &lt;&lt; endl; else &#123; if (ab &gt; ba) &#123; if (s[0] &#x3D;&#x3D; &#39;a&#39;) s[0] &#x3D; &#39;b&#39;; &#125; else &#123; if (s[0] &#x3D;&#x3D; &#39;b&#39;) s[0] &#x3D; &#39;a&#39;; &#125; cout &lt;&lt; s &lt;&lt; endl; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; B_Update_Files 水题 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; ll quickpow(ll a, ll b) &#123; ll ans &#x3D; 1; ll res &#x3D; a; while (b) &#123; if (b &amp; 1) ans &#x3D; ans * res; b &gt;&gt;&#x3D; 1; res &#x3D; res * res; &#125; return ans; &#125; void solve() &#123; ll n, k; cin &gt;&gt; n &gt;&gt; k; if (n &#x3D;&#x3D; 1) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; int need &#x3D; 0; ll tmp &#x3D; 0; rep(i, 0, 65) &#123; tmp &#x3D; quickpow(2, i); if (tmp &gt;&#x3D; k || tmp &gt;&#x3D; n) &#123; need &#x3D; i; break; &#125; &#125; if (tmp &gt;&#x3D; n) cout &lt;&lt; need &lt;&lt; endl; else &#123; ll times &#x3D; need; if ((n - tmp) % k &gt; 0) &#123; times +&#x3D; (n - tmp) &#x2F; k + 1; &#125; else &#123; times +&#x3D; (n - tmp) &#x2F; k; &#125; cout &lt;&lt; times &lt;&lt; endl; &#125; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; C_Banknotes 题意： 给定n,k, n代表纸币种类，k代表最多可用纸币数量，接下来给出a[0…n-1]， 顺序由小到大，表示每张纸币的面值为 10^a[i]，求不能表示出的金额的最小值 思路： 贪心，按10进制从低位到高位取，能取够低位就是 a[i+1]-1 的形式，即为 x999… , 如果a[i]取不到a[i+1] 或者 没有更大面值的钞票，答案即为 a[i] * 剩余张数 + a[i]-1 , 能取到就接着找a[i+1]。 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; ll a[20]; ll quickpow(ll a, ll b) &#123; ll ans &#x3D; 1; ll res &#x3D; a; while (b) &#123; if (b &amp; 1) ans &#x3D; ans * res; b &gt;&gt;&#x3D; 1; res &#x3D; res * res; &#125; return ans; &#125; void solve() &#123; ll n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 0, n) &#123; cin &gt;&gt; a[i]; a[i] &#x3D; quickpow(10, a[i]); &#125; a[n] &#x3D; 0; ll ans &#x3D; 0; ll tmp &#x3D; 0; rep(i, 0, n) &#123; if (i &#x3D;&#x3D; 0) &#123; if (n &#x3D;&#x3D; 1) &#123; cout &lt;&lt; k + 1 &lt;&lt; endl; return; &#125; if (a[i] * k + 1 &lt; a[i + 1]) &#123; cout &lt;&lt; a[i] * k + 1 &lt;&lt; endl; return; &#125; else &#123; tmp +&#x3D; a[i + 1] &#x2F; a[i] - 2; ans &#x3D; a[i + 1] - 1; &#125; &#125; else &#123; if ((k - tmp) * a[i] &lt; a[i + 1]) &#123; ans &#x3D; (k - tmp) * a[i] + a[i] - 1; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; eif(a[i + 1] &#x3D;&#x3D; 0) &#123; ans &#x3D; (k - tmp) * a[i] + a[i] - 1; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; else &#123; tmp +&#x3D; a[i + 1] &#x2F; a[i] - 1; ans &#x3D; a[i] - 1; &#125; &#125; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; 总结我真是个沙比，打的时候因为有个判断条件写错了一直wa2，比赛完十分钟就过了，纯掉分飞舞 😅","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Codeforces Round 750 (Div.2)","slug":"codeforces/cf 750","date":"2021-10-27T17:02:50.000Z","updated":"2022-01-25T07:49:43.171Z","comments":true,"path":"/post/codeforces/cf 750.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20750.html","excerpt":"Codeforces Round 750 (Div.2)","text":"Codeforces Round #750 (Div.2)A_Luntik_and_Concerts#include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; ll a, b, c; cin >> a >> b >> c; int mn = min(a, b); if ((mn + c) &amp; 1) &#123; mn--; a -= mn; b -= mn; &#125; else &#123; a -= mn; b -= mn; &#125; b &amp;= 1; if (b) &#123; if (a >= 2) a -= 2; cout &lt;&lt; (a &amp; 1) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; (a &amp; 1) &lt;&lt; endl; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; B_Luntik_and_Subsequences#include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; ll quickpow(int a, int b)&#123; ll ans = 1; ll res = a; while (b) &#123; if (b &amp; 1) ans = ans * res; b >>= 1; res = res * res; &#125; return ans; &#125; void solve() &#123; int n; cin>>n; int a[65]; rep(i,0,n) cin>>a[i]; sort(a,a+n); ll cnt=0; if(a[0]>1) cout&lt;&lt;0&lt;&lt;endl; else&#123; ll cnt0=0,cnt1=0; rep(i,0,n)&#123; if(a[i]==0) cnt0++; eif(a[i]==1) cnt1++; else break; &#125; cnt=cnt1*quickpow(2,cnt0); cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; int main() &#123; IOS; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; C_Grandma_Capa_Knits_a_Scarf 题意： 待补 思路： 待补 #include &lt;iostream> #include &lt;algorithm> #include &lt;cstring> #include &lt;vector> #define ll long long #define pb push_back using namespace std; int sum1[100005], sum2[100005]; int p[1000005]; int main() &#123; int T; cin >> T; //T = 1; while(T--) &#123; int n; cin >> n; string s; cin >> s; int ans = 0x3f3f3f3f; for(int i = 0; i &lt; 26; i++) &#123; string s1 = \"\"; sum1[0] = sum2[n + 1] = sum2[n] = 0; char now = 'a' + i; for(int j = 0; j &lt; s.size(); j++) &#123; if(s[j] == now) &#123; if(j == 0) sum1[j] = 1; else sum1[j] = sum1[j - 1] + 1; &#125; else &#123; if(j == 0) sum1[j] = 0; else sum1[j] = sum1[j - 1]; s1 += s[j]; p[s1.size() - 1] = j; &#125; &#125; for(int j = s.size() - 1; j >= 0; j--) &#123; sum2[j] = sum2[j + 1]; if(s[j] == now) sum2[j]++; &#125; string s2 = s1; reverse(s2.begin(), s2.end()); //cout &lt;&lt; \"fuck\" &lt;&lt; endl; if(s1 == s2) &#123; //cout &lt;&lt; (char)('a' + i) &lt;&lt; endl; int del = 0; for(int k = 0; k &lt; s1.size() / 2 + (s1.size() &amp; 1 ? 1 : 0); k++) &#123; //if(i == 0) cout &lt;&lt; k &lt;&lt; \" \" &lt;&lt; endl; int pos1 = p[k], pos2 = p[s1.size() - 1 - k]; //if(i + 'a' == 'r') cout &lt;&lt; k &lt;&lt; \" \" &lt;&lt; del &lt;&lt; endl; if(k == 0) del += abs(sum1[pos1] - sum2[pos2]); else del += abs((sum1[pos1] - sum1[p[k - 1]]) - (sum2[pos2] - sum2[p[s1.size() - k]])); &#125; ans = min(ans, del); &#125; &#125; if(ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; // 1 // 8 // rprarlap D_Vupsen_Pupsen_and_0 题意： 已知非零数组a[i]，求非零数组b[i]，使得a[i]*b[i] 的和为0 思路： 个数为偶数两两相消，个数为奇数的话，选取尾部三个数，判断两个相加不为零的数出来，当作一个数与剩下的一个数两两相消即可。 坑点：三个数时合并的两个数相加不能为0 #include &lt;bits/stdc++.h> #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int a[maxn]; int n; cin >> n; rep(i, 0, n) &#123; cin >> a[i]; &#125; bool t1 = false, t2 = false, t3 = false; if (n &amp; 1) &#123; if (a[n - 1] + a[n - 2] != 0) &#123; a[n - 2] = a[n - 1] + a[n - 2]; t1 = true; &#125; else &#123; if (a[n - 2] + a[n - 3] != 0) &#123; a[n - 3] = a[n - 2] + a[n - 3]; a[n - 2] = a[n - 1]; t2 = true; &#125; else &#123; a[n - 3] = a[n - 3] + a[n - 1]; t3 = true; &#125; &#125; for (int i = 0; i &lt; n - 1; i += 2) &#123; if (i == n - 3) &#123; if (t1) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \"; &#125; eif(t2) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i]; &#125; eif(t3) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \" &lt;&lt; a[i + 1]; &#125; &#125; else &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \"; &#125; &#125; cout &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; n; i += 2) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125;","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"}]},{"title":"kmp & exkmp","slug":"algorithm/learn/kmp & exkmp","date":"2021-10-23T17:02:50.000Z","updated":"2022-07-13T09:03:32.782Z","comments":true,"path":"/post/algorithm/learn/kmp & exkmp.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/kmp%20&%20exkmp.html","excerpt":"kmp &amp; exkmpKnuth-Morris-Pratt &amp; entend kmp 字符串匹配 kmp Keywords：next[] 由BF改进，O(m+n)，传世经典属于是😅 以下均假设主串为 S，模式串为 P What is next[] ? 针对模式串，next[j] 表示模式串下标 j 之前 最长相同前后缀的长度，这不重要。 你只需要记住：next[j]表示当 P[j]!=S[i] 时，j 指针的下一步移动位置。","text":"kmp &amp; exkmpKnuth-Morris-Pratt &amp; entend kmp 字符串匹配 kmp Keywords：next[] 由BF改进，O(m+n)，传世经典属于是😅 以下均假设主串为 S，模式串为 P What is next[] ? 针对模式串，next[j] 表示模式串下标 j 之前 最长相同前后缀的长度，这不重要。 你只需要记住：next[j]表示当 P[j]!=S[i] 时，j 指针的下一步移动位置。 偷个好图： How to quickly build next[] ? 话不多说，直接上🐎 void kmp_pre(string p, int next[])&#123; int i,j; j&#x3D;next[0]&#x3D;-1; i&#x3D;0; while(i&lt;p.length())&#123; while(-1!&#x3D;j &amp;&amp; p[i]!&#x3D;p[j]) j&#x3D;next[j]; next[++i]&#x3D;++j; &#125; &#125; ① 初始化next[0]=-1 ② 如果 P[next[m]]==P[m] ，那么 next[m+1]=next[m]+1 ③ 如果 P[next[m]]!=P[m]，令 t=m, t=next[t]，比较 P[next[t]]和 P[m]：相同的话 next[m]=next[t]+1 , 不同的令t=next[t] 继续比较，直到 t==-1 时，next[m]=0 kmp计数模板 模式串在主串中出现了几次 (可重叠、不可重叠) void kmp_pre(string p, int next[])&#123; int i,j; j&#x3D;next[0]&#x3D;-1; i&#x3D;0; while(i&lt;p.length())&#123; while(-1!&#x3D;j &amp;&amp; p[i]!&#x3D;p[j]) j&#x3D;next[j]; next[++i]&#x3D;++j; &#125; &#125; int kmp_Count(string x, string y, int next[])&#123; &#x2F;&#x2F;x是模式串，y是主串 int i,j; int ans&#x3D;0; kmp_pre(x,next); i&#x3D;j&#x3D;0; while(i&lt;y.length())&#123; while(-1!&#x3D;j &amp;&amp; y[i]!&#x3D;x[j]) j&#x3D;next[j]; i++;j++; if(j&gt;&#x3D;x.length())&#123; ans++; &#x2F;&#x2F;以下二选一 j&#x3D;next[j]; &#x2F;&#x2F;可重叠计数 j&#x3D;0; &#x2F;&#x2F;不可重叠计数 &#125; &#125; return ans; &#125; exkmp Keywords: extend[] next[] O(m+n) e-kmp 可以找到主串中所有模式串的匹配 What are they? next[i]: 对模式串，表示 P[i...m-1] 与 P[0...m-1] 的最长公共前缀 extend[i] : 对主串和模式串，表示 S[i...n-1]与 P[0...m-1] 的最长公共前缀 How to build them? 🐎来 void ekmp_pre(string x, int next[])&#123; int m&#x3D;x.length(); next[0]&#x3D;m; int j&#x3D;0; while(j+1&lt;m &amp;&amp; x[j]&#x3D;&#x3D;x[j+1]) j++; next[1]&#x3D;j; int k&#x3D;1; for(int i&#x3D;2; i&lt;m; i++)&#123; int p&#x3D;next[k]+k-1; int L&#x3D;next[i-k]; if(i+L&lt;p+1) next[i]&#x3D;L; else&#123; j&#x3D;max(0,p-i+1); while(i+j&lt;m &amp;&amp; xi+j]&#x3D;&#x3D;x[j]) j++; next[i]&#x3D;j; k&#x3D;i; &#125; &#125; &#125; void ekmp(string x, string y, int next[], int extend[])&#123; ekmp_pre(x,next); int j&#x3D;0; int m&#x3D;x.length(), n&#x3D;y.length(); while(j&lt;n &amp;&amp; j&lt;m &amp;&amp; x[j]&#x3D;&#x3D;y[j]) j++; extend[0]&#x3D;j; int k&#x3D;0; for(int i&#x3D;1; i&lt;n; i++)&#123; int p&#x3D;extend[k]+k-1; int L&#x3D;next[i-k]; if(i+L&lt;p+1) extend[i]&#x3D;L; else&#123; j&#x3D;max(0,p-i+1); while(i+j&lt;n &amp;&amp; j&lt;m &amp;&amp; y[i+j]&#x3D;&#x3D;x[j]) j++; extend[i]&#x3D;j; k&#x3D;i; &#125; &#125; &#125; 假设我们已经知道 next[] , 如何求 extend[] 呢？ 此处变量设置会和🐎有所出入，主要是理解过程😅 ① 假设当前 S 串遍历到位置i, 即extend[0...i-1]的值均以求出；首先设置两个变量，a 和 p，p 代表以a为起始位置的字符匹配成功的最右边界，’p = 最后一个匹配成功位置+1’ ，即 S[a...p) == P[0...p-a)，假设下面基于S[i] 对应 P[i-a] 的几种情况开始讨论： ② 如图所示，如果 i+next[i-a] &lt; p ，根据 next[] 数组的定义，易知 extend[i] = next[i-a] ③ 如果 i+next[i-a] == p ，此时S[p]!=P[p-a] 且P[p-i]!=P[p-a]，但是S[p]==P[p-i]的可能仍然存在，所以直接从 S[p] 与 P[p-i] 开始向后匹配即可 ④ 如果 i+next[i-a] &gt; p ，此时说明 S[i...p) 与 P[i-a...p-a]相同，注意到 S[p]!=P[p-a] 并且 P[p-i]==P[p-a]，即 S[p]!=T[p-i] ，所以没必要继续往下判断了，故赋值extend[i]=p-i ⑤ 由上面的过程，求解next[i]的过程即为 P 自己和自己匹配的过程，over 需要细品 题单Solution 0x01 剪花布条 HDU-2087 link 0x02 Secret HDU-6153 link 0x03 Cow Patterns POJ-3167 link … 待更 kmp 和 exkmp 整的头晕….","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"SpringMVC学习杂记","slug":"note/springMVC","date":"2021-09-15T18:37:28.000Z","updated":"2022-01-22T09:37:58.349Z","comments":true,"path":"/post/note/springMVC.html","link":"","permalink":"https://maskros.top/post/note/springMVC.html","excerpt":"SpringMVC","text":"SpringMVC学习杂记 注：杂记即为看到啥记啥 毫无章法 乱jb记 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等 SpringSpring 是最受欢迎的企业级 Java 应用程序开发的轻量级框架 Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践 三层架构 表现层 web层 MVC是表现层的一个设计模型 业务层 service层 持久层 dao层 优良特性 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API 控制反转：IOC——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。 依赖注入：DI——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。 面向切面编程：Aspect Oriented Programming——AOP 容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC） 体系结构 MVC职责分析 Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 MVC框架需要做哪些事情： 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求—调用相关的业务处理—封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . Servletjsp：本质就是一个servlet 添加pom依赖 新建空Maven项目 Add Framework Support 选择Web Application添加 变成web项目 导入servlet和jsp的依赖 编写一个Servlet类，用来处理用户的请求 public class HelloServlet extends HttpServlet 在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp 在web.xml中注册Servlet 配置Tomcat 并启动测试 SpringMVC Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量 级Web框架 Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁 中心控制器Spring MVC框架以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080 服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 配置版 配置web.xml ， 注册DispatcherServlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"> &lt;!--1.注册DispatcherServlet--> &lt;servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value> &lt;/init-param> &lt;!--启动级别-1--> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!--/ 匹配所有的请求；（不包括.jsp）--> &lt;!--/* 匹配所有的请求；（包括.jsp）--> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;/beans> 添加 处理映射器 &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/> 添加 处理器适配器 &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/> 添加 视图解析器 &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"> &lt;!--前缀--> &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/> &lt;!--后缀--> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； package com.maskros.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //注意：这里我们先导入Controller接口 public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; &#125; &#125; 将自己的类交给SpringIOC容器，注册bean &lt;!--Handler--> &lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/> 写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; $&#123;msg&#125; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 配置tomcat启动测试 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ ※注解版 由于Maven可能存在资源过滤的问题，我们将配置完善 &lt;build> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;/resources> &lt;/build> 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入 配置 web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"> &lt;!--1.注册servlet--> &lt;servlet> &lt;servlet-name>SpringMVC&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动顺序，数字越小，启动越早 --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!--所有请求都会被springmvc拦截 --> &lt;servlet-mapping> &lt;servlet-name>SpringMVC&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 会匹配 .jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错 添加 SpringMVC 配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --> &lt;context:component-scan base-package=\"com.kuang.controller\"/> &lt;!-- 让Spring MVC不处理静态资源 --> &lt;mvc:default-servlet-handler /> &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --> &lt;mvc:annotation-driven /> &lt;!-- 视图解析器 --> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"> &lt;!-- 前缀 --> &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /> &lt;!-- 后缀 --> &lt;property name=\"suffix\" value=\".jsp\" /> &lt;/bean> &lt;/beans> 创建 Contronller @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 // 编写控制类 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/HelloController\") public class HelloController &#123; //真实访问地址 : 项目名/HelloController/hello @RequestMapping(\"/hello\") public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\",\"hello,SpringMVC\"); //web-inf/jsp/hello.jsp return \"hello\"; &#125; &#125; 创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息 &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;SpringMVC&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; $&#123;msg&#125; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 配置 Tomcat 运行 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 控制器和RestFul 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种，一般使用注解@Controller 实现Controller接口 mvc的配置文件只留下 视图解析器 ControllerTest1 //定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; &#125; &#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 &lt;bean name=\"/t1\" class=\"com.maskros.controller.ControllerTest1\"/> 编写前端test.jsp &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; $&#123;msg&#125; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --> &lt;context:component-scan base-package=\"com.kuang.controller\"/> 增加一个ControllerTest2类，使用注解实现 //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2&#123; //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; &#125; &#125; 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 @RequestMapping 使用 @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径 // 只注解在方法上面 @Controller public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125; &#125; //访问路径：http://localhost:8080 / 项目名 / h1 // 同时注解类与方法@Controller @RequestMapping(\"/admin\") public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125; &#125; //访问路径：http://localhost:8080 / 项目名/ admin /h1 RestFul风格 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。localhost:8080/a/b/c/d/…… 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上 @Controller public class RestFulController &#123; //映射访问路径 @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\") public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; &#125; &#125; 使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 //映射访问路径,必须是POST请求 @RequestMapping(value = \"/hello\",method = &#123;RequestMethod.POST&#125;) public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\"; &#125; // 我们使用浏览器地址栏进行访问默认是Get请求，会报错405 // 如果将POST修改为GET则正常了 //映射访问路径,必须是Get请求 @RequestMapping(value = \"/hello\",method = &#123;RequestMethod.GET&#125;) public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\"; &#125; Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\\ 所有的地址栏请求默认都会是 HTTP GET 类型的 方法级别的注解变体有如下几个：组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多, 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式 数据处理和跳转转发 重定向 接受请求参数以及数据回显 @RequestParam(\"xxx\") //必须要求传这个参数 Json JavaScript Object Notation, JS 对象标记 是一种轻量级的数据交换格式，目前使用特别广泛，采用完全独立于编程语言的文本格式来存储和表示数据 @Controller：定义一个控制器类， @RestController： 注解相当于 @Controller ＋ @ResponseBody 合在一起的作用。 @ResponseBody：标记Controller类中的方法。把return的结果变成JSON对象返回。 语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值 &#123;\"name\": \"QinJiang\"&#125; &#123;\"age\": \"3\"&#125; &#123;\"sex\": \"男\"&#125; Json 和 JavaScript 对象互转： JSON.parse() //从JSON字符串转换为JavaScript 对象 JSON.stringify() //从JavaScript 对象转换为JSON字符串 Controller返回Json数据Jackson使用导入它的jar包 配置SpringMVC 编写Controller时需要运用到两个新东西：@ResponseBody，ObjectMapper对象 乱码处理 FastJson使用 阿里开发 方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换 乱码问题&lt;!-- Json乱码问题配置 --> &lt;mvc:annotation-driven> &lt;mvc:message-converters register-defaults=\"true\"> &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"> &lt;constructor-arg value=\"UTF-8\"/> &lt;/bean> &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"> &lt;property name=\"objectMapper\"> &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"> &lt;property name=\"failOnEmptyBeans\" value=\"false\"/> &lt;/bean> &lt;/property> &lt;/bean> &lt;/mvc:message-converters> &lt;/mvc:annotation-driven> Ajax Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 可以通过 iframe 标签来伪造一个Ajax 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 …. jQuery.ajax Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据 jQuery是一个库，提供大量的JavaScript函数 jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 Ajax异步加载数据实现了数据回显 &lt;script> $(function () &#123; $(\"#btn\").click(function () &#123; $.post(\"$&#123;pageContext.request.contextPath&#125;/a2\",function (data) &#123; console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) &#123; html+= \"&lt;tr>\" + \"&lt;td>\" + data[i].name + \"&lt;/td>\"+ \"&lt;td>\" + data[i].age + \"&lt;/td>\" + \"&lt;td>\" + data[i].sex + \"&lt;/td>\" + \"&lt;/tr>\" &#125; //html拼接 $(\"#content\").html(html); &#125;); &#125;) &#125;) &lt;/script> 拦截器Interceptor SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。可用于验证用户是否登录 (认证用户) 过滤器和拦截器的区别： 过滤器： servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 (是AOP思想的具体应用) 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 想要自定义拦截器，必须实现 HandlerInterceptor 接口 在springmvc的配置文件中配置拦截器 &lt;!--关于拦截器的配置--> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;!--/** 包括路径及其子路径--> &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--> &lt;!--/admin/** 拦截的是/admin/下的所有--> &lt;mvc:mapping path=\"/somewhere/**\"/> &lt;!--拦截somewhere下的 somewhere用@RequestMapping()配置 --> &lt;!--bean配置的就是拦截器--> &lt;bean class=\"com.maskros.interceptor.MyInterceptor\"/> &lt;/mvc:interceptor> &lt;/mvc:interceptors> 每写一个拦截器要到xml中配置这个拦截器 exp：未登录时点击主页按钮会被拦截器重定向到登录页面 杂记SpringMVC + Vue + SpringBoot + SpringCloud + Linux Spring：IOC 和 AOP SpringMVC：SpringMVC的执行流程，SSM框架整合 SSM = javaweb做项目 MVC：模型 (dao, service) , 视图 (jsp) , 控制器 (servlet) servlet: 转发 重定向 前端 数据传输 实体类 实体类：用户名 密码 生日 ….. n个 前端：用户名 密码 pojo: User vo: UserVo MVVM: M - V - VM (ViewModel: 双向绑定) form表单 method: get/post &lt;form action&#x3D;&quot;&#x2F;hello&quot; method&#x3D;&quot;post&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;method&quot;&gt; &lt;input type&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;form&gt; Spring: 大杂烩，我们可以将SpringMVC中所有要用到的Bean，注册到Spring中 访问网站：-&gt; Servlet(中转调度) &lt;=&gt; Service -&gt; Dao -&gt; Sql 前后端分离时代： 后端部署后端，提供接口，提供数据：json 前端独立部署，负责渲染后端的数据 js: 函数：闭包() () Dom id, name, tag create, remove Bom window document ES6: import require js: data:&#123;'name':$(\"#username\").val()&#125;, // data传键值对 &#123;x:y&#125; .val()==value 左边的name对应controller的name 右边的username对应下面输入框的id,加#才能取到！ IDEA alt+insert 快捷键 实现接口等等","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"java","slug":"java","permalink":"https://maskros.top/tags/java/"},{"name":"springMVC","slug":"springMVC","permalink":"https://maskros.top/tags/springMVC/"}]},{"title":"STL使用手册","slug":"algorithm/learn/STL使用手册","date":"2021-08-13T06:15:31.000Z","updated":"2022-07-13T09:04:28.669Z","comments":true,"path":"/post/algorithm/learn/STL使用手册.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/STL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html","excerpt":"STL使用手册Standard Template Library 又名《👴怕忘了先把他写下来》 我 是 谁 ?斯丹德儿的 坦普雷特 莱博瑞 即标准模板库 重要特点：数据结构和算法的分离 重要特性：不是面向对象的 逻辑层次：体现了泛型化程序设计的思想 实现层次：以一种类型参数化的方式实现，基于模板(template) 六大组件： 容器（Container），是一种数据结构，如list，vector，deques ，以模板类的方法提供 ; 迭代器（Iterator），提供了访问容器中对象的方法。迭代器就如同一个指针。C++的指针也是一种迭代器。迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象； 算法（Algorithm），是用来操作容器中的数据的模板函数。如sort()，find()，函数本身与他们操作的数据的结构和类型无关 ; 仿函数（Functor） 适配器（Adaptor） 分配器（allocator）","text":"STL使用手册Standard Template Library 又名《👴怕忘了先把他写下来》 我 是 谁 ?斯丹德儿的 坦普雷特 莱博瑞 即标准模板库 重要特点：数据结构和算法的分离 重要特性：不是面向对象的 逻辑层次：体现了泛型化程序设计的思想 实现层次：以一种类型参数化的方式实现，基于模板(template) 六大组件： 容器（Container），是一种数据结构，如list，vector，deques ，以模板类的方法提供 ; 迭代器（Iterator），提供了访问容器中对象的方法。迭代器就如同一个指针。C++的指针也是一种迭代器。迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象； 算法（Algorithm），是用来操作容器中的数据的模板函数。如sort()，find()，函数本身与他们操作的数据的结构和类型无关 ; 仿函数（Functor） 适配器（Adaptor） 分配器（allocator） 👴 常用的 以下不按顺序，想到啥就写啥，有个🥚的顺序 容器string字符串 &#x2F;&#x2F;构造函数 string s(str,index); &#x2F;&#x2F;将字符串str内“始于位置index”的部分当作字符串的初值 string s(str,index,n); &#x2F;&#x2F;将字符串str内“始于index且长度顶多n”的部分作为字符串的初值 string s(n,c); &#x2F;&#x2F;生成一个字符串，包含n个c字符(char) string s(str.begin(),str.end()); &#x2F;&#x2F;以区间begin():end() (不包含end())内的字符作为字符串s的初值 &#x2F;&#x2F;操作函数 s.erase(s.begin(),s.end()); &#x2F;&#x2F;删除 s.replace(pos,len,str); &#x2F;&#x2F;替换，从pos开始长为len被替换为str s.find(str,pos&#x3D;0); &#x2F;&#x2F;从pos向右查找，返回str第一次出现的位置 s.rfind(str,pos&#x3D;npos); &#x2F;&#x2F;从pos反向查找，返回找到位置 s.find_first_of(str); &#x2F;&#x2F;查找第一个属于str中字符的位置 s.find_first_not_of(str); &#x2F;&#x2F;查找第一个不属于str中字符位置 s.find_last_of(str); s.find_last_not_of(str); s1.compare(s2); &#x2F;&#x2F;比较，相等0大于1小于-1 s1.compare(pos,len,s2)&#x2F;&#x2F;从s1的pos开始长为len与s2比较 stringstream自动且直接的类型转换 stringstream sstream; &#x2F;&#x2F;数据类型转换 string str; int a&#x3D;123; sstream &lt;&lt; a; sstream &gt;&gt; str; cout&lt;&lt;str; cout&lt;&lt;sstream.str(); &#x2F;&#x2F;多个字符串拼接 sstream &lt;&lt; &quot;xxxx&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;aaaaa&quot;; &#x2F;&#x2F;清空stringstream sstream.clear(); sstream.str(&quot;&quot;); pair便携结构体 &#x2F;&#x2F;访问通过first second &#x2F;&#x2F;可以通过一般运算符比较，先比较first再second pair&lt;string,int&gt; p (str,123); pair&lt;string,int&gt; p &#x3D; make_pair(str,123); vector向量容器，动态存储 vector&lt;int&gt; v; v.front(); v.back(); v.begin(); v.end(); v.push_back(); v.size(); v.empty(); v.clear(); v.pop_back(); &#x2F;&#x2F;删除表尾元素 v.insert(it,x); &#x2F;&#x2F;向迭代器it 指向的元素前插入新元素x v.insert(it,n,x); &#x2F;&#x2F;插入n个x v.insert(it, first, last); &#x2F;&#x2F;将由迭代器first和last 所指定的序列[first, last)插入到迭代器it指向的元素前面 v.erase(it); &#x2F;&#x2F;删 v.erase(first,last); v.reverse(n); &#x2F;&#x2F;预分配缓冲空间，使存储空间至少可容纳n个元素 v.resize(n); &#x2F;&#x2F;改变序列长度，超出元素删除，若源空间小于n，则默认值填满空间 v.resize(n,val); &#x2F;&#x2F;超出的用val填满 stack栈 stack&lt;int&gt; s; s.push(x); s.pop(); s.top(); s.empty(); s.size(); queue队列，优先队列，双端队列 &#x2F;&#x2F; queue queue&lt;int&gt; q; q.push(x); q.pop(); q.front(); q.back(); q.empty(); q.size(); &#x2F;&#x2F; priority_queue priority&lt;int&gt; q; &#x2F;&#x2F;默认大者优先 priority&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; &#x2F;&#x2F;小的先出队 三个模板参数：元素类型，容器类型，比较算子 &#x2F;&#x2F; 优先级设置：定义结构体 struct Student&#123; int num; int grade; friend bool operator &lt; (Student s1, Student s2)&#123; return s1.grade&lt;s2.grade; &#x2F;&#x2F;此处小于号还是小于的作用，故队列中以成绩高的学生优先，若反之变号即可 &#125; &#125;; priority_queue&lt;Student&gt; q; &#x2F;&#x2F;也可以把重载的函数写在结构体外面 struct cmp&#123; bool operator() (Student s1, Student s2)&#123; return s1.grade&lt;s2.grade; &#125; &#125;;&#x2F;&#x2F;tips:优先队列中的cmp和sort中的cmp效果相反 priority_queue&lt;Student,vector&lt;Student&gt;,cmp&gt; q; &#x2F;&#x2F;如果结构体内数据庞大，像出现字符串或者数组，建议使用引用来提高效率。此时比较类的参数需要加上 const 和 &amp; friend bool operator &lt; (const Student &amp;s1, const Student &amp;s2)&#123; return s1.grade&lt;s2.grade; &#125; &#x2F;&#x2F;deque deque&lt;int&gt; d; d.push_back(x); &#x2F;&#x2F;尾部插入 d.push_front(x); &#x2F;&#x2F;首部插入元素 d.insert(d.begin()+len,x); &#x2F;&#x2F;中间插入元素 &#x2F;&#x2F;可以通过 d[0] d[1] 访问 d.pop_front(); &#x2F;&#x2F;删除头部 d.pop_back(); d.erase(d.begin()+len); &#x2F;&#x2F;删除指定位置元素，可以写多个 map键值对，元素按关键字有序，内部红黑树 &#x2F;&#x2F; map空间占用率高 map&lt;string,int&gt; m; m[key]&#x3D;value; m.insert(make_pair(key,value)); m.erase(key); m.erase(it); m.clear(); m.size(); map&lt;string,int&gt;::iterator it; for(it&#x3D;mp.begin();it!&#x3D;mp.end();++it)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; &#x2F;&#x2F; unordered_map 效率较高 内部哈希表 &#x2F;&#x2F; 对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map set无重复，按键值自动排序 数据结构为红黑树。以节点形式保存（动态)，用迭代器访问 set&lt;int&gt; s; s.begin(); s.end(); s.clear(); s.empty(); s.erase(x); s.find(x); s.insert(x); s.size(); s.lower_bound(value); &#x2F;&#x2F;返回第一个大于等于value的定位器 s.upper_bound(value); &#x2F;&#x2F;返回最后一个大于等于value的定位器 set&lt;int&gt;::iterator it; for(it&#x3D;s.begin();it!&#x3D;s.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; list链表 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector 如果你需要大量的插入和删除，而不关心随即存取，则应使用list 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque list&lt;int&gt; a(n); list&lt;int&gt; a&#123;1,2,3,4&#125;; a.push_back(x); a.push_front(x); a.empty(); a.resize(n); a.clear(); a.front(); a.back(); a.reverse(); a.merge(b); &#x2F;&#x2F;b变空，a尾插入b a.insert(pos,x); a.insert(pos,b.begin(),b.end()); a.erase(a.begin(),a.end()); a.remove(x); bitset存放二进制0/1的容器，可以声明非常大的二进制位而不限于64，用来优化 bitset&lt;N&gt; b; &#x2F;&#x2F;表示长为N的二进制串 &#x2F;&#x2F; 通过b[pos]访问 b.any(); &#x2F;&#x2F;存在为1的二进制位 b.none(); &#x2F;&#x2F;不存在为1的二进制位 b.count(); &#x2F;&#x2F;置1的二进制位的个数 b.size(); b.test(pos); &#x2F;&#x2F;在pos位处是否为1 b.set(); &#x2F;&#x2F;所有位置1 b.set(pos); b.reset(); &#x2F;&#x2F;所有位置0 b.reset(pos); b.flip(); &#x2F;&#x2F;逐位取反 b.flip(pos); functions查找&#x2F;&#x2F; 对于sort(a, a + n) 升序排列 lower_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于等于x的位置 upper_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于x的位置 &#x2F;&#x2F; 对于sort(a, a + n, greater&lt;int&gt;()) 降序排列 lower_bound(a,a+n,x,greater&lt;int&gt;(); &#x2F;&#x2F;二分查找第一个小于等于x的位置 upper_bound(a,a+n,x,greater&lt;int&gt;(); &#x2F;&#x2F;二分查找第一个小于x的位置 find(); rfind(); 排序sort(a,a+n,cmp); &#x2F;&#x2F;默认ASC 修改swap(a,b); &#x2F;&#x2F;交换 replace(pos,len,str); &#x2F;&#x2F;替换 unique(a,a+n); &#x2F;&#x2F;去除相邻的重复元素,会把重复的藏到末尾，使用前需要先排序 排列next_permutation(a,a+n); &#x2F;&#x2F;下一个全排列 prev_permutation(a,a+n); &#x2F;&#x2F;上一个全排列 &#x2F;&#x2F;函数返回bool值，一般配合while() 其他__builtin_popcount(n); &#x2F;&#x2F;返回n的二进制1的个数 isalpha(char x); &#x2F;&#x2F;小写字母返回2，大写字母1，非字母0 tolower(char x); toupper(char x); &#x2F;&#x2F;返回小写，大写字母的ASCII值，非字母则相等 &#x2F;&#x2F;海伦公式 p&#x3D;(a+b+c)&#x2F;2; s&#x3D;sqrt(p*(p-a)*(p-b)*(p-c)); abs(int x); &#x2F;&#x2F;只用于整数 fabs(double x); &#x2F;&#x2F;精度更高 暂时就这些了，寄！","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"我确实不会线段树","slug":"algorithm/learn/线段树","date":"2021-08-06T08:14:31.000Z","updated":"2022-07-13T09:05:32.640Z","comments":true,"path":"/post/algorithm/learn/线段树.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"线段树Segment Tree 一个问题，只要能化成对一些连续点l的修改和统计问题，基本就可以用线段树来艹了 原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2,b]。","text":"线段树Segment Tree 一个问题，只要能化成对一些连续点l的修改和统计问题，基本就可以用线段树来艹了 原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2,b]。 作用：对编号连续的一些点的区间信息进行修改或者统计操作，用线段树统计的东西，必须符合区间加法。与树状数组不同的是，线段树不止适用于区间求和的查询，也可以进行区间最大值，区间最小值，或者区间异或值的查询。 主要操作：区间查询、点更新、区间更新 例如： 给定s和t，求其区间上的最小值 给定i和x，把ai的值改成x 更新和区间查询的复杂度都是 O(log(N)) 操作 build, update(内含push_down), query 建树 (build)线段树是一棵平衡二叉树，每个节点都对应一条线段(区间)，反之不成立，每个节点 的左右子节点的编号分别为 和 ，假如节点 储存区间 的和，设 ，那么两个子节点分别储存 和 的和。可以发现，左节点对应的区间长度，与右节点相同或者比之恰好多 。 故建树可考虑递归进行： void build(ll l = 1, ll r = n, ll p = 1) { if (l == r) // 到达叶子节点 tree[p]=A[l]; // 用数组中的数据赋值 else{ ll mid = (l + r) / 2; build(l, mid, p * 2); // 先建立左右子节点 build(mid + 1, r, p * 2 + 1); tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 该节点的值等于左右子节点之和 } } 这里👴偷了个 gif 来演示一下过程 (虽然大部分都是偷的🤡) 区间修改(update)首先定义”懒标记“(即“延迟标记”) mark[]： 对于区间修改，朴素的想法是用递归的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个标记，将来要用到它的子区间的时候，再向下传递 直接上🐴 (非最简): void update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n) { if (cl &gt; r || cr &lt; l) // 区间无交集 return; // 剪枝 else if (cl &gt;= l &amp;&amp; cr &lt;= r) // 当前节点对应的区间包含在目标区间中 { tree[p] += (cr - cl + 1) * d; // 更新当前区间的值 if (cr &gt; cl) // 如果不是叶子节点 mark[p] += d; // 给当前区间打上标记 } else // 与目标区间有交集，但不包含于其中 { ll mid = (cl + cr) / 2; mark[p * 2] += mark[p]; // 标记向下传递 mark[p * 2 + 1] += mark[p]; tree[p * 2] += mark[p] * (mid - cl + 1); // 往下更新一层 tree[p * 2 + 1] += mark[p] * (cr - mid); mark[p] = 0; // 清除标记 update(l, r, d, p * 2, cl, mid); // 递归地往下寻找 update(l, r, d, p * 2 + 1, mid + 1, cr); tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 根据子节点更新当前节点的值 } } 更新时，我们是从最大的区间开始，递归向下处理。注意到，任何区间都是线段树上某些节点的并集。于是我们记目标区间为 ，当前区间为 ， 当前节点为 ，我们会遇到三种情况： 当前区间与目标区间没有交集： 直接结束递归 当前区间被包括在目标区间里： 可以更新区间，不能忘记乘上区间长度 tree[p] += (cr - cl + 1) * d; 然后打上懒标记（叶子节点可以不打标记，因为不会再向下传递了） mark[p] += d; //表示“该区间上每一个点都要加上d”。因为原来可能存在标记，所以是+=而不是= 当前区间与目标区间相交，但不包含于其中: 这时把当前区间一分为二，分别进行处理。如果存在懒标记，要先把懒标记传递给子节点（注意也是+=，因为原来可能存在懒标记) ll mid = (cl + cr) / 2; mark[p * 2] += mark[p]; mark[p * 2 + 1] += mark[p]; 两个子节点的值也就需要相应的更新（后面乘的是区间长度) :[p * 2] += mark[p] * (mid - cl + 1); tree[p * 2 + 1] += mark[p] * (cr - mid); 不要忘记清除该节点的懒标记： mark[p]=0; 因为贵标记和👴一样是个懒蛋，只往下传递一层，所以这个过程并不是递归的，以后要用再才继续传递。其实我们常常把这个传递过程封装成一个函数扑屎裆 : inline void push_down(ll p, ll len){ mark[p * 2] += mark[p]; mark[p * 2 + 1] += mark[p]; tree[p * 2] += mark[p] * (len - len / 2); tree[p * 2 + 1] += mark[p] * (len / 2); // 右边的区间可能要短一点 mark[p] = 0; } //这样儿 update() 里面调用的时候直接 push_down(p, cr - cl + 1); 就彳亍 传递完标记后，再递归地去处理左右两个子节点就彳亍乐 下面儿👴又偷了个视频展示一下区间 加上 的过程： 至于单点修改，只需要令左右端点相等即可~ 区间查询(query)还就那个直接上🐴 ll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n){ if (cl &gt; r || cr &lt; l) return 0; else if (cl &gt;= l &amp;&amp; cr &lt;= r) return tree[p]; else{ ll mid = (cl + cr) / 2; push_down(p, cr - cl + 1); return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr); // 上一行拆成三行写就和区间修改格式一致了 } } 一样的递归，一样自顶至底地寻找，一样的合并信息，即插即用😍 模板 source : 洛谷P3372 【模板】线段树 1 题目描述如题，已知一个数列，你需要进行下面两种操作：1.将某区间每一个数加上x2.求出某区间每一个数的和输入格式第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。接下来M行每行包含3或4个整数，表示一个操作，具体如下：操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和输出格式输出包含若干行整数，即为所有操作2的结果。 tips: 本模板分为龙鸣版和贵族版 龙鸣version (此龙鸣非彼龙鸣，意为把上面的龙鸣🐴整合起来): #define MAXN 100005 ll n, m, A[MAXN], tree[MAXN * 4], mark[MAXN * 4]; inline void push_down(ll p, ll len){ mark[p * 2] += mark[p]; mark[p * 2 + 1] += mark[p]; tree[p * 2] += mark[p] * (len - len / 2); tree[p * 2 + 1] += mark[p] * (len / 2); mark[p] = 0; } void build(ll l = 1, ll r = n, ll p = 1){ if (l == r) tree[p] = A[l]; else{ ll mid = (l + r) / 2; build(l, mid, p * 2); build(mid + 1, r, p * 2 + 1); tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } void update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n){ if (cl &gt; r || cr &lt; l) return; else if (cl &gt;= l &amp;&amp; cr &lt;= r){ tree[p] += (cr - cl + 1) * d; if (cr &gt; cl) mark[p] += d; } else{ ll mid = (cl + cr) / 2; push_down(p, cr - cl + 1); update(l, r, d, p * 2, cl, mid); update(l, r, d, p * 2 + 1, mid + 1, cr); tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } ll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n){ if (cl &gt; r || cr &lt; l) return 0; else if (cl &gt;= l &amp;&amp; cr &lt;= r) return tree[p]; else{ ll mid = (cl + cr) / 2; push_down(p, cr - cl + 1); return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr); } } int main(){ n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) A[i] = read(); build(); for (int i = 0; i &lt; m; ++i){ ll opr = read(), l = read(), r = read(); if (opr == 1){ ll d = read(); update(l, r, d); } else printf(\"%lld\\n\", query(l, r)); } return 0; } 贵族version 豪华升级plus，本来想加个乘除的发现板子不兼容，👴是懒狗 const int MAXN = 1e5 + 5; ll tree[MAXN &lt;&lt; 2], mark[MAXN &lt;&lt; 2], n, m, A[MAXN]; void push_down(int p, int len){ tree[p &lt;&lt; 1] += mark[p] * (len - len / 2); mark[p &lt;&lt; 1] += mark[p]; tree[p &lt;&lt; 1 | 1] += mark[p] * (len / 2); mark[p &lt;&lt; 1 | 1] += mark[p]; mark[p] = 0; } void build(int p = 1, int cl = 1, int cr = n){ if (cl == cr) { tree[p] = A[cl]; return; } int mid = (cl + cr) &gt;&gt; 1; build(p &lt;&lt; 1, cl, mid); build(p &lt;&lt; 1 | 1, mid + 1, cr); tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]; } ll query(int l, int r, int p = 1, int cl = 1, int cr = n){ if (cl &gt;= l &amp;&amp; cr &lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) &gt;&gt; 1, ans = 0; if (mid &gt;= l) ans += query(l, r, p &lt;&lt; 1, cl, mid); if (mid &lt; r) ans += query(l, r, p &lt;&lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n){ if (cl &gt;= l &amp;&amp; cr &lt;= r) { tree[p] += d * (cr - cl + 1), mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) &gt;&gt; 1; if (mid &gt;= l) update(l, r, d, p &lt;&lt; 1, cl, mid); if (mid &lt; r) update(l, r, d, p &lt;&lt; 1 | 1, mid + 1, cr); tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]; } 常见模型步骤： 将问题转化成点信息和目标信息 将目标信息根据需要扩充成区间信息 增加信息符合区间加法 增加标记支持区间操作 代码中的主要模块：区间加法，标记下推，点信息-&gt;区间信息，各种操作(修改、查询…) 字符串哈希 URAL1989 Subpalindromes 题解 给定一个字符串(长度&lt;=100000)，有两个操作。 1：改变某个字符。 2：判断某个子串是否构成回文串 分析： 直接判断会超时，此处用 线段树维护字符串哈希 对于一个字符串它对应的哈希函数为$a[0]+a[1]K + a[2]K^2 +…+a[n-1]*K^{n-1}$ 再维护一个从右往左的哈希值： $a[0]K^{n-1} + a[1]K^{n-2} +…+a[n-1]$ 若是回文串，则左右的哈希值会相等。而左右哈希值相等，则很大可能这是回文串。 若出现误判，可以再用一个K2，进行二次哈希判断，可以减小误判概率。实现上，哈希值最好对某个质数取余数，这样分布更均匀。 解题模型： 目标信息：某个区间的左，右哈希值 点信息：一个字符 目标信息已经符合区间加法，所以区间信息=目标信息 故线段树结构： 区间信息：区间哈希值 点信息：一个字符 核心：就是找到区间信息， 写好区间加法 最长连续零 Codeforces 527C Glass Carving 题解 给定一个矩形，不停地纵向/横向切割，问每次切割后，最大的矩形面积是多少 分析： 最大矩形面积=最长的长*最宽的宽 长宽范围均为1e5，故用01序列表示每个点是否被切割 最长的长就是长的最长连续0的数量+1，宽同理，于是可用用线段树维护最长连续零 解题模型： 目标信息：区间最长连续零的个数 点信息：0或1 由于目标信息不符合区间加法，所以要扩充目标信息 故线段树结构： 区间信息：从左，右开始的最长连续零，本区间是否全零，本区间最长连续零 点信息：0或1 计数排序 Codeforces 558E A Simple Task 题解 给定一个长度不超过1e5的字符串（小写英文字母），和不超过5000个操作，每个操作 L R K 表示给区间[L,R]的字符串排序，K=1为升序，K=0为降序。 最后输出最终的字符串 解题模型： 目标信息：区间的计数排序结果 点信息：一个字符 目标信息是符合区间加法的，但是为了支持区间操作，还是需要扩充信息 故线段树结构： 目标信息：区间的计数排序结果，排序标记，排序种类（升降） 点信息：一个字符 To be continued…","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"博弈论","slug":"algorithm/learn/博弈论","date":"2021-07-31T01:51:28.000Z","updated":"2022-07-13T09:05:00.714Z","comments":true,"path":"/post/algorithm/learn/博弈论.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E5%8D%9A%E5%BC%88%E8%AE%BA.html","excerpt":"博弈论Game Theory Nim游戏属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下： 两名选手交替移动，在有限的合法移动集合中任选一种进行移动 对于任何一种局面，合法的移动集合只取决于局面本身 到谁无法移动谁就输了 以下给出 P/N 的定义：","text":"博弈论Game Theory Nim游戏属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下： 两名选手交替移动，在有限的合法移动集合中任选一种进行移动 对于任何一种局面，合法的移动集合只取决于局面本身 到谁无法移动谁就输了 以下给出 P/N 的定义： P-Position：先手必败点 (Previous) N-Position：先手必胜点 (Next) 可知所有终结点都是P点，一步就能到P点的一定是N点，通过一步只能到N点的一定是P点 下面来说说Nim游戏：“有若干堆石子，每堆石子的数量有限，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为没有任何合法的移动）“，简单来想，我们可以想到一个递归的算法：对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P，那么向这个子局面的移动就是必胜策略。这其中有大量的重叠子问题，所以可以用DP或者记忆化搜索的方法以提高效率。 但是👴们已经有了一个nb的结论： 对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1^a2^…^an=0，其中^表示异或(xor)运算 根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。 Sprague-Grundy函数ICG的抽象模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负 首先定义mex(minimal excludnt) 运算： 施加于集合，表示最小的不属于这个集合的非负整数，exp: mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 下面给出SG函数的定义： 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数如下：sg(x)=mex{ sg(y) | y是x的后继 }。 结论：当SG[x] = 0时，x为必败状态；当SG[x] &gt; 0时，x为必胜状态 所以从1~n的SG函数值应该如何计算呢？ 使用 数组 f[ ] 将可改变当前状态 的方式记录下来 然后我们使用 另一个数组 S[ ] 将当前状态x 的后继状态标记 模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x) 不断重复 2-3 的步骤，即完成计算 1-n 的SG函数值 SG定理：SG(G)=SG(G1)^SG(G2)^…^SG(Gn)，原游戏的SG函数值是它的所有子游戏的SG函数值的异或 解题模型 把原游戏分解成多个独立的子游戏，则原游戏的SG函数值就变为SG(G)=SG(G1)^SG(G2)^…^Sg(Gn) 分别考虑每一个子游戏，计算其SG值 SG值的计算方法（important）： ​ a. 可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1) （Bash game） ​ b. 可选步数为任意步，SG(x) = x（Nim game） ​ c. 可选步数为一系列不连续的数，用模板计算 板子 首选打表预处理，打表没法使的时候就怼dfs ☆打表&#x2F;&#x2F;打表 int f[N],SG[MAXN],S[MAXN]; &#x2F;&#x2F; f[] 可改变当前状态的方式(可取走石子个数) S[] 当前状态的后继状态集合 void getSG(int n) &#123; int i,j; memset(SG,0,sizeof(SG)); for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; memset(S,0,sizeof(S)); for(j&#x3D;0; f[j]&lt;&#x3D;i &amp;&amp; j&lt;&#x3D;N;j++) S[SG[i-f[j]]]&#x3D;1; &#x2F;&#x2F;S[]数组来保存当前状态的后继状态集合 for(j&#x3D;0;j&lt;&#x3D;n;j++)&#123; if(!S[j])&#123;&#x2F;&#x2F;模拟mex运算 SG[i]&#x3D;j; break; &#125; &#125; &#125; &#125; 深搜&#x2F;&#x2F;注意 f数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍 &#x2F;&#x2F;n是集合f的大小 f[i]是定义的特殊取法规则的数组 int f[110],SG[10010],n; int SG_dfs(int x)&#123; int i; if(SG[x]!&#x3D;-1) return SG[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i&#x3D;0;i&lt;n;i++)&#123; if(x&gt;&#x3D;f[i])&#123; SG_dfs(x-f[i]); vis[SG[x-f[i]]]&#x3D;1; &#125; &#125; int e; for(i&#x3D;0;;i++) if(!vis[i])&#123; e&#x3D;i; break; &#125; return SG[x]&#x3D;e; &#125; 常见博弈Bash Game只有一堆n个物品，两个人轮流取物，每次至少取一个，最多取m个。最后取光者得胜（谁拿了最后一个谁赢） 结论：最优选择为保持给对手留下 m+1 的倍数 if(n%(m+1) != 0) 则先手必赢 if(n%(m+1) == 0) 则后手必赢 Wythoff Game 各位👴属实🐮，黄金分割数（1+√5）/2 = 1.618 都给整上了 有两堆各若干个物品，两个人轮流从某一堆取物或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜 这里用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势 由ak，bk组成的矩形近似为黄金矩形 结论： (int)((bk-ak)*(1+sqrt(5.0))/2) != ak , 先手必赢 (int)((bk-ak)*(1+sqrt(5.0))/2) == ak , 后手必赢 Nim Game若干堆石子，每堆石子的数量有限，两个人可以选择一堆石子并拿走若干颗 结论：xor 略 Fibonacci Nim有一堆个数为n的石子，游戏双方轮流取石子，满足: (1)先手不能在第一次把所有的石子取完 (2)每次可以取的石子数介于1到对手刚取的石子数的2倍之间(包含) (3) 取走最后一个石子的人为赢家 结论：当n为Fibonacci数的时候，必败 f[i]：1,2,3,5,8,13,21,34,55,89……","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"博弈","slug":"博弈","permalink":"https://maskros.top/tags/%E5%8D%9A%E5%BC%88/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"sql学习笔记","slug":"note/sql","date":"2021-07-28T16:07:28.000Z","updated":"2022-01-22T09:36:48.564Z","comments":true,"path":"/post/note/sql.html","link":"","permalink":"https://maskros.top/post/note/sql.html","excerpt":"Structured Query Language","text":"SQL结构化查询语言-Structured Query Language @author：Maskros Type类型 字符型 VARCHAR型和CHAR型 文本型 TEXT 数值型 整数INT 、小数NUMERIC、钱数MONEY) 逻辑型 BIT 日期型 DATETIME Operation操作 增删改查 CURD tips : 不区分大小写，列名表名前``可以省略 SELECT(FROM) SELECT COLUMN 查询单个列 SELECT `column_name` FROM `table_name`; SELECT COLUMN, COLUMN 查询多个列 SELECT `column_name_1`, `column_name_2` FROM `table_name`; 使用 SELECT * 查询所有列 SELECT * FROM `table_name`; 使用 SELECT DISTINCT 查询不同行 SELECT DISTINCT `column_name` FROM `table_name` ​ 希望查询的值都是唯一不重复的 SELECT WHERE 对行进行筛选过滤 SELECT `column_name1`,`column_name2`… FROM `table_name` WHERE `column_name` operator `value`; INSERT(INTO) INSERT INTO 在不指定列的情况下插入数据 INSERT INTO `table_name` VALUES (value1, value2, value3,...); # 'value' INSERT INTO 在指定的列中插入数据 INSERT INTO `table_name` (`column1`, `column2`, `column3`,...) VALUES (value1, value2, value3,...); UPDATE(SET) UPDATE 更新数据 UPDATE `table_name` SET `column1`=value1,`column2`=value2,... WHERE `some_column`=some_value; # WHERE 可以省略 DELETE(FROM) DELETE 删除数据 DELETE FROM `table_name` WHERE `some_column` = `some_value`; TRUNCATE TABLE 清空表 Condition条件 比较运算符WHERE A OPERATOR B tips: &lt;&gt; , != 均为不等于，但用法不同 逻辑运算符 AND 连接多条件 OR 连接多条件 NOT 过滤不满足条件的数据 SELECT `column_name` FROM `table_name` WHERE NOT `condition`; # (condition1 operator condition2) 特殊条件 IN 查询多条件 Where `column_name1` IN (condition) # condition 中也可以写 IN (select `column_name1` xxxxxxxx) NOT IN 排除 SELECT * FROM `table_name` WHERE `column_name` (NOT) IN `value`; # （value1, value2） BETWEEN AND 查询两值间的数据范围 SELECT * FROM `table_name` WHERE `column_name` BETWEEN `value` AND `value`; IS NULL 查询空数据 使用 LIKE 模糊查询 SELECT * FROM `table_name` WHERE `column_name` LIKE `value`; # LIKE `D%` # 'D%' 表示以D开头的所有单词，% 表示为通配符，可以替代0~n个字符 ORDER BY &amp; LIMIT ORDER BY 对数据进行排序（一列/多列(多列按SELECT顺序)） ASC (ascend)升序(默认) | DESC(descend) 降序 SELECT &#96;column_name&#96;, &#96;column_name&#96; FROM &#96;table_name&#96; # WHERE XXXX ORDER BY &#96;column_name&#96;, &#96;column_name&#96; ASC|DESC; 使用 LIMIT 限制输出行数 offset ：是返回集的初始标注，起始点是0 count ：制定返回的数量 SELECT `column_name`, `column_name` FROM `table_name` # ORDER BY XXXX LIMIT `offset` , `count`; # offset和count通常只用一个count：LIMIT (0,)1 Function函数 算数函数 AVG() 函数求数值列的平均值 SELECT AVG(`column_name`) # AS `column2_name` FROM `table_name`; MAX() 函数返回指定列中的最大值 MIN() 函数返回指定列中的最小值 SUM() 函数统计数值列的总数 ROUND() 函数将数值四舍五入 ROUND() 返回值数据类型会被变换为一个BIGINT 。 当 decimals 为正数时，column_name 四舍五入为 decimals 所指定的小数位数。省略decimals自动保留四舍五入后的整数。当 decimals 为负数时，column_name 则按 decimals 所指定的在小数点的左边四舍五入。 SELECT ROUND(`column_name`, `decimals`) FROM `table_name`; #decimals 规定要返回的小数位数 NULL() 函数判断空值 ISNULL() SELECT ISNULL(`column_name`) FROM `table_name`; # 返回 0 或 1 IFNULL() SELECT IFNULL(`column_name`, `value`) FROM `table_name`; # 是 NULL 则返回 value 值，不是则返回对应内容 COUNT() 函数计数 # COUNT(column_name) 对列具有的行数进行计数 除去值为 NULL 的行 # 主要用于查看各列数据的数量情况，便于统计数据的缺失值 SELECT COUNT(`column_name`) FROM `table_name`; # COUNT(*) 对表中行的数目进行计数,包括 NULL 所在行和重复项所在行 # 主要用于查看表中的记录数 SELECT COUNT(*) FROM `table_name`; # COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目 SELECT COUNT(DISTINCT `column_name`) FROM `table_name`; 时间函数 NOW()，CURDATE()、CURTIME() 获取当前时间 NOW() 返回当前日期和时间 YYYY-MM-DD hh:mm:ss CURDATE() 返回当前日期 YYYY-MM-DD CURTIME() 返回当前时间 hh:mm:ss 要精确的秒以后的时间的话，可以在 () 中加数字，加多少，就表示精确到秒后多少位 DATE()、TIME() 函数提取日期和时间 EXTRACT() 函数提取指定的时间信息 FROM 返回日期/时间的单独部分 unit : YEAR (年)、MONTH (月)、DAY (日)、HOUR (小时)、MINUTE (分钟)、 SECOND (秒) SELECT EXTRACT(unit FROM date) # unit 为单独部分名 FROM `table` # date - 合法column DATE_FORMAT() 格式化输出日期 %Y 年份 %m 月份 %d 日期 %w 星期 %H 小时 %i 分钟 %s 秒 小写y 表示年份后两位，小写h表示12小时计的小时 SELECT DATE_FORMAT(date,'format'); DATE_ADD() 增加时间 INTERVAL 向日期添加指定的时间间隔 expr 是希望添加的时间间隔的数值 type : MICROSECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , QUARTER , YEAR SELECT DATE_ADD(date, INTERVAL expr type) FROM table_name DATE_SUB() 减少时间 DATEDIFF() 和 TIMESTAMPDIFF() 计算日期差 时间1-时间2 DATEDIFF() 默认只能计算天数差 SELECT DATEDIFF(时间1,时间2) AS date_diff FROM courses; TIMESTAMPDIFF() 计算相差年月周日时 类型YEAR,MONTH,WEEK,DAY,HOUR SELECT TIMESTAMPDIFF (类型,时间1,时间2) AS year_diff； Constraints约束 NOT NULL非空约束 强制列不接受 NULL 值 # 建表 CREATE TABLE &#96;Persons&#96; ( &#96;ID&#96; int NOT NULL, &#96;LastName&#96; varchar(255) ); # 已建表 ALTER TABLE &#96;Persons&#96; MODIFY &#96;Age&#96; int NOT NULL; # 撤销 ALTER TABLE &#96;Persons&#96; MODIFY &#96;Age&#96; int NULL; UNIQUE唯一约束 不希望出现重复记录 CONSTRAINT 命名 DROP 撤销 # 建表 ## MySQL CREATE TABLE `Persons`( `P_Id` int NOT NULL, UNIQUE (`P_Id`) ) ## SQL Server / Oracle / MS Access CREATE TABLE `Persons`( `P_Id` int NOT NULL UNIQUE, ) ## 命名+多列 CREATE TABLE `Persons`( `P_Id` int NOT NULL, `LastName` varchar(255) NOT NULL, CONSTRAINT uc_PersonID UNIQUE (`P_Id`,`LastName`) ) # 已建 ALTER TABLE `Persons` ADD UNIQUE（`P_Id`） ## 多列 ALTER TABLE `Persons` ADD CONSTRAINT uc_PersonID UNIQUE (`P_Id`,`LastName`) # 撤销 ## MySQL ALTER TABLE `Persons` DROP INDEX uc_PersonID ## SQL Server / Oracle / MS Access ALTER TABLE `Persons` DROP CONSTRAINT uc_PersonID PRIMARY KEY主键约束 简单的说，PRIMARY KEY = UNIQUE + NOT NULL NOT NULL UNIQUE 可以将表的一列或多列定义为唯一性属性，而 PRIMARY KEY 设为多列时，仅能保证多列之和是唯一的，具体到某一列可能会重复。 PRIMARY KEY 可以与外键配合，从而形成主从表的关系 PRIMARY KEY 一般在逻辑设计中用作记录标识，这也是设置 PRIMARY KEY 的本来用意，而 UNIQUE 只是为了保证域/域组的唯一性 # 建表 ## MySQL CREATE TABLE `Persons( `P_Id` int NOT NULL, PRIMARY KEY (`P_Id`) ); ## SQL Server / Oracle / MS Access CREATE TABLE `Persons`( `P_Id` int NOT NULL PRIMARY KEY, ) ## 命名+多列 CONSTRAINT pk_PersonID PRIMARY KEY (`P_Id`,`LastName`) # 已建 ALTER TABLE `Persons` ADD PRIMARY KEY (`P_Id`) ## 多列 ALTER TABLE `Persons` ADD CONSTRAINT pk_PersonID PRIMARY KEY (`P_Id`,`LastName`) # 撤销 ## MySQL ALTER TABLE `Persons` DROP PRIMARY KEY ## SQL Server / Oracle / MS Access ALTER TABLE `Persons` DROP CONSTRAINT pk_PersonID FOREIGN KEY外键约束 一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY 保证数据的完整性和一致性 在两个表之间建立关系，需要指定引用主表的哪一列，REFERENCES 表示引用一个表 # 建表 ## MySQL CREATE TABLE `Orders`( `P_Id` int, FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) ) ## SQL Server / Oracle / MS Access CREATE TABLE `Orders`( P_Id int FOREIGN KEY REFERENCES Persons(P_Id) ) ## 命名+多列 CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) # 已建 ALTER TABLE `Orders` ADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) ## 命名 ALTER TABLE `Orders` ADD CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) # 撤销 ## MySQL ALTER TABLE `Orders` DROP FOREIGN KEY fk_PerOrders ## SQL Server / Oracle / MS Access ALTER TABLE `Orders` DROP CONSTRAINT fk_PerOrders CHECK检查约束 限制列中的值的范围，评估插入或修改后的值。满足条件插入，否不插 可以为同一列指定多个 CHECK 约束 # 建表 CREATE TABLE `courses`( `student_count` int, … CHECK (Condition1 AND Condition2) ) ## 命名 CONSTRAINT chk_courses CHECK (`student_count` > 0); # 已建 ALTER TABLE `courses` ADD CHECK ( `student_count` > 0); ## ADD CONSTRAINT XXX CHECK (Condition); # 撤销 ## MySQL ALTER TABLE `courses` DROP CHECK chk_courses ## SQL Server / Oracle / MS Access ALTER TABLE `courses` DROP CONSTRAINT chk_courses DEFAULT默认约束 `City` varchar(255) DEFAULT 'Sandnes' `OrderDate` date DEFAULT GETDATE() # 可以用函数 ALTER TABLE `Persons` ALTER `City` SET DEFAULT 'SANDNES' ADD CONSTRAINT ab_c DEFAULT 'SANDNES' for `City` ALTER `City` DROP DEFAULT ALTER COLUMN `City` DROP DEFAULT Join多表联结 联结 在一条 SELECT 语句中关联多个表，返回一组输出 两大主角 : 主键 (PRIMARY KEY) 和外键 (FOREIGN KEY) 使用完全限定列名（用一个点分隔表名和列名） # condition `table1`.`common_field` = `table2`.`common_field` JOIN 连接子句 INNER JOIN 内连接：如果表中有至少一个匹配，则返回行 OUTER JOIN 外连接 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN 全连接：只要其中一个表中存在匹配，则返回行 CROSS JOIN 交叉连接：又称笛卡尔积，两个表数据一一对应，返回结果的行数等于两个表行数的乘积 INNER JOIN内连接 又称为EQUIJOIN 等值连接 内连接就是取两个表的交集，返回的结果就是连接的两张表中都满足条件的部分 SELECT `table1`.`column1`, `table2`.`column2`... FROM `table1` (INNER) JOIN `table2` # INNER 可省略不写 ON `table1`.`common_field` = `table2`.`common_field`; # ON CONDITION # exp SELECT `c`.`id`, `c`.`name` AS `course_name`, `t`.`name` AS `teacher_email` FROM `courses` `c` (INNER) JOIN `teachers` `t` ON `c`.`teacher_id` = `t`.`id`; courses c 等同于 courses AS c ，给courses 表取别名为 c OUTER JOIN外连接 分为左外连接 右外连接 全外连接 外连接可以将某个表格中，在另外一张表格中无对应关系，但是也能将数据匹配出来 SELECT column_name 1,column_name 2 ... column_name n FROM table1 LEFT | RIGHT | FULL (OUTER) JOIN table2 ON CONDITION; LEFT JOIN : 以左表为参考表，返回左表中的所有记录，加上右表中匹配到的记录 RIGHT JOIN : 以右表为参考表 FULL JOIN : 只要左表和右表其中一个表中存在匹配，则返回行 tips : MySQL 数据库不支持全连接，想要实现全连接可以使用 UNION ALL 来将左连接和右连接结果组合在一起实现全连接 UNION : 联合，把两次或多次查询结果合并起来 要求：两次查询的列数必须一致，同时，每条 SELECT 语句中的列的顺序必须相同 UNION 会去掉重复的行。 如果不想去掉重复的行，可以使用 UNION ALL 如果子句中有 order by , limit，需用括号()包起来。推荐放到所有子句之后，即对最终合并的结果来排序或筛选 SELECT column_name 1,column_name 2 ... column_name n FROM table1 LEFT JOIN table2 ON CONDITION UNION SELECT column_name 1,column_name 2 ... column_name n FROM table1 RIGHT JOIN table2 ON CONDITION ; CROSS JOIN交叉连接 结果也称作笛卡尔积 返回左表中的所有行，左表中的每一行与右表中的所有行组合。即将两个表的数据一一对应，其查询结果的行数为左表中的行数乘以右表中的行数。 # 隐式连接 不需要使用 CROSS JOIN 关键字 SELECT `table1`.`column1`, `table2`.`column2`... FROM `table1`,`table2`; # 显式连接 SELECT `table1`.`column1`, `table2`.`column2`... FROM `table1` CROSS JOIN `table2`; 通过增加联结条件，使用 WHERE 子句帮助筛选过滤无效的数据 Advanced Select分组查询 GROUP BY 子句 对同类的数据进行分类 SELECT `column_name`, aggregate_function(`column_name`) FROM `table_name` WHERE `column_name` operator value GROUP BY `column_name`; HAVING 子句 使用 WHERE 条件子句时不能与聚合函数联合使用 HAVING 子句经常与 GROUP BY 联合使用，HAVING 子句就是对分组统计函数进行过滤的子句 HAVING 子句对于 GROUP BY 子句设置条件的方式其实与 WHERE 子句与 SELECT 的方式类似，语法相近，但 WHERE 子句搜索条件是在分组操作之前，而 HAVING 则是在之后 SELECT `column_name`, aggregate_function(`column_name`) FROM `table_name` WHERE `column_name` operator value GROUP BY `column_name` HAVING aggregate_function(`column_name`) operator value; ex: 查询教师表 teachers计算不同国籍教师的平均年龄和所有教师的平均年龄，比较两者的大小，最后返回大于所有教师平均年龄的不同国籍下的全部教师信息 # 子查询 SELECT * FROM teachers WHERE country IN (SELECT country FROM teachers GROUP BY country HAVING AVG(age) > (SELECT AVG(age) FROM teachers)) 子查询(Base) SELECT 语句中的子查询 SELECT `column_name(s)` FROM `table_name` WHERE `column_name` OPERATOR ( SELECT `column_name(s)` FROM `table_name` ); INSERT 语句中的子查询 INSERT INTO `table_name` SELECT `colnum_name(s)` FROM `table_name` [ WHERE VALUE OPERATOR ] UPDATE 语句中的子查询 UPDATE `table_name` SET `column_name` = `new_value` WHERE `column_name` OPERATOR (SELECT `column_name` FROM `table_name` [WHERE] ) DELETE 语句中的子查询 DELETE FROM `table_name` WHERE `column_name` OPERATOR (SELECT `column_name` FROM `table_name` [WHERE] ) 子查询(Adv.) 内联视图子查询 将查询的结果集作为一个查询表，继续进行查询操作 SELECT * FROM ( SELECT * xxxx ) `T` WHERE xxx = ( SELECT xxxx ); IN 操作符的多行子查询 / NOT IN ANY 操作符的多行子查询 在子查询中使用 ANY ，表示与子查询返回的任何值比较为真，则返回真 SELECT `column_name(s)` FROM `table_name` WHERE `column_name` OPERATOR ANY(SELECT column_name FROM table_name) ALL 操作符的多行子查询 在子查询中使用 ALL ，表示与子查询返回的所有值比较为真，则返回真 多列子查询 HAVING 子句中的子查询","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"sql","slug":"sql","permalink":"https://maskros.top/tags/sql/"}]},{"title":"竞赛记录","slug":"life/竞赛记录","date":"2019-08-24T16:00:01.000Z","updated":"2022-06-09T04:32:20.221Z","comments":true,"path":"/post/life/竞赛记录.html","link":"","permalink":"https://maskros.top/post/life/%E7%AB%9E%E8%B5%9B%E8%AE%B0%E5%BD%95.html","excerpt":"算法废物的打铁记录","text":"竞赛记录 = 打铁记录 2020.10 CCPC威海打铁2020.10.17 蓝桥省二打铁2020.11 华为杯校赛三等2020.12 ICPC南京线上赛打铁2021.3 ICPC山东省赛打铁 这也能铁？纯废物 2021.5.16 ICPC银川现场赛打铁 阅读签到WA32，卡行末空格AC+6，Trie当时没掌握 2021.4.18 蓝桥省二打铁2021.8.21 百度之星复赛打铁2021.8 CCPC网络预选赛打铁2021.9 ICPC网络预选赛打铁2021.10 CCPC网络赛重赛打铁2021.11.28 ICPC上海线上赛打铁 卡树上DP签到，DP变形 2021.12 CCSP分赛铜首华东rk712022.4 蓝桥杯A组省一2022.4.17 ICPC昆明站线上赛打铜 亲手A掉铜牌题 2022.5 天梯赛省一2022.5.22 ICPC山东省赛打银 差7名，可惜了计算几何没调出来","categories":[{"name":"LIFE","slug":"LIFE","permalink":"https://maskros.top/categories/LIFE/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"Life","slug":"Life","permalink":"https://maskros.top/tags/Life/"}]}],"categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"},{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"},{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"},{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"},{"name":"LIFE","slug":"LIFE","permalink":"https://maskros.top/categories/LIFE/"},{"name":"PROJECT","slug":"PROJECT","permalink":"https://maskros.top/categories/PROJECT/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"深度学习","slug":"深度学习","permalink":"https://maskros.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"math","slug":"math","permalink":"https://maskros.top/tags/math/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://maskros.top/tags/OpenCV/"},{"name":"视觉","slug":"视觉","permalink":"https://maskros.top/tags/%E8%A7%86%E8%A7%89/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"树状数组","slug":"树状数组","permalink":"https://maskros.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"java","slug":"java","permalink":"https://maskros.top/tags/java/"},{"name":"springBoot","slug":"springBoot","permalink":"https://maskros.top/tags/springBoot/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"hash","slug":"hash","permalink":"https://maskros.top/tags/hash/"},{"name":"STL","slug":"STL","permalink":"https://maskros.top/tags/STL/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"dfs","slug":"dfs","permalink":"https://maskros.top/tags/dfs/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"https://maskros.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"bfs","slug":"bfs","permalink":"https://maskros.top/tags/bfs/"},{"name":"讨论","slug":"讨论","permalink":"https://maskros.top/tags/%E8%AE%A8%E8%AE%BA/"},{"name":"差分","slug":"差分","permalink":"https://maskros.top/tags/%E5%B7%AE%E5%88%86/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"LCA","slug":"LCA","permalink":"https://maskros.top/tags/LCA/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线段树","slug":"线段树","permalink":"https://maskros.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"欧拉降幂","slug":"欧拉降幂","permalink":"https://maskros.top/tags/%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"博弈","slug":"博弈","permalink":"https://maskros.top/tags/%E5%8D%9A%E5%BC%88/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"ST表","slug":"ST表","permalink":"https://maskros.top/tags/ST%E8%A1%A8/"},{"name":"Life","slug":"Life","permalink":"https://maskros.top/tags/Life/"},{"name":"图论","slug":"图论","permalink":"https://maskros.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"逆元","slug":"逆元","permalink":"https://maskros.top/tags/%E9%80%86%E5%85%83/"},{"name":"euler","slug":"euler","permalink":"https://maskros.top/tags/euler/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"},{"name":"WeRoBot","slug":"WeRoBot","permalink":"https://maskros.top/tags/WeRoBot/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://maskros.top/tags/ComputerNetwork/"},{"name":"Trie","slug":"Trie","permalink":"https://maskros.top/tags/Trie/"},{"name":"kmp","slug":"kmp","permalink":"https://maskros.top/tags/kmp/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"打表","slug":"打表","permalink":"https://maskros.top/tags/%E6%89%93%E8%A1%A8/"},{"name":"贪心","slug":"贪心","permalink":"https://maskros.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://maskros.top/tags/Dijkstra/"},{"name":"gcd","slug":"gcd","permalink":"https://maskros.top/tags/gcd/"},{"name":"Crawler","slug":"Crawler","permalink":"https://maskros.top/tags/Crawler/"},{"name":"requests","slug":"requests","permalink":"https://maskros.top/tags/requests/"},{"name":"springMVC","slug":"springMVC","permalink":"https://maskros.top/tags/springMVC/"},{"name":"sql","slug":"sql","permalink":"https://maskros.top/tags/sql/"}]}