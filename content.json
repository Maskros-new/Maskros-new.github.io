{"meta":{"title":"Maskros' Blog","subtitle":"","description":"","author":"Maskros","url":"https://maskros.top","root":"/"},"pages":[{"title":"about","date":"2021-08-27T03:12:31.000Z","updated":"2022-01-24T12:27:04.590Z","comments":true,"path":"about/index.html","permalink":"https://maskros.top/about/index.html","excerpt":"","text":"ACM铁牌收集大师，cs无名小卒，各种球类运动爱好者，乐队混子bass 联系我请用 E-mail，顺着也能摸到我的QQ，欢迎吹水约架"},{"title":"友情链接","date":"2022-05-15T15:11:46.359Z","updated":"2022-05-15T15:11:46.359Z","comments":true,"path":"links/index.html","permalink":"https://maskros.top/links/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-11-01T16:00:00.000Z","updated":"2021-07-29T02:44:39.630Z","comments":true,"path":"categories/index.html","permalink":"https://maskros.top/categories/index.html","excerpt":"","text":"","author":"Maskros"},{"title":"message-board","date":"2022-02-04T15:50:10.174Z","updated":"2022-02-04T15:50:10.174Z","comments":true,"path":"message-board/index.html","permalink":"https://maskros.top/message-board/index.html","excerpt":"","text":"这是一个留言板，欢迎带🔥开喷🤡"},{"title":"tags","date":"2020-09-19T08:19:22.000Z","updated":"2021-07-29T02:41:27.086Z","comments":true,"path":"tags/index.html","permalink":"https://maskros.top/tags/index.html","excerpt":"","text":"","author":"Maskros"}],"posts":[{"title":"树 状 数 组","slug":"algorithm/learn/树状数组","date":"2022-05-13T03:55:50.000Z","updated":"2022-05-19T09:41:14.664Z","comments":true,"path":"/post/algorithm/learn/树状数组.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.html","excerpt":"Binary Indexed Tree","text":"树状数组Binary Indexed Tree 二进制下标树 引入基本操作： 的单点修改和区间查询 核心：巧妙利用二进制，如果我们要求前11项和，可以分别查询, , 的和再相加，即不断去掉二进制数最右边的一个1的过程。如果区间求和，使用前缀和的思想做差即可。 核心实现：求二进制最低位的1： Code0x01 单点修改 &amp; 区间查询#define maxn 100005 #define lowbit(x) x &amp; (-x) int tr[maxn]; // 单点修改 init void update(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr[pos] += x; } } // 前缀和 int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr[pos]; } return ans; } // 区间查询 int query(int l, int r) { return query(r) - query(l - 1); } 0x02 区间修改 &amp; 单点查询 树状数组采用差分建立，单点查询即采用原数组的区间查询即可 // 区间修改 void update(int l, int r, int x) { update(l, x); update(r + 1, -x); } // 单点查询 即做前缀和 int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr[pos]; } return ans; } *0x03 区间修改 &amp; 区间查询pf: 由差分形式可知，第 个数到第 个数可表示为: ​ 结论： ​ 可用区间修改和查询来维护，而​ 用另一个update来存即可 完整板子: #define maxn 100005 #define lowbit(x) x &amp; (-x) #define rep(i, x, y) for (int i = x; i &lt; y; i++) int tr[maxn], tr2[maxn]; // 单点修改 init void update(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr[pos] += x; } } void update2(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr2[pos] += x * (i - 1); } } // 区间修改 void update(int l, int r, int x) { update(l, x); update(r + 1, -x); update2(l, x); update2(r + 1, -x); } // 前缀和 单点查询 int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr[pos]; } return ans; } int query2(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ans += tr2[pos]; } return ans; } // 区间查询 int query(int l, int r) { return (r * query(r) - query2(r)) - ((l - 1) * query(l - 1) - query2(l - 1)); } 应用：逆序对 Def: 逆序对： &amp;&amp; ，可用归并排序实现，此处用树状数组求解，其实求解的 核心：离散化+树状数组求顺序对 Step1: 离散化：另开一个数组d，d[i]用来存放第i大的数在原序列的什么位置，ex: a={3, 8, 5, 4, 6} ==&gt; d={2, 3, 5, 4, 1} int a[maxn], d[maxn], tr[maxn]; bool cmp(int x, int y) { if (a[x] == a[y]) return x &gt; y; // 避免元素相同、重要 return a[x] &gt; a[y]; // 按原序列第几大排列 } signed main() { cin &gt;&gt; n; rep(i, 1, n + 1) cin &gt;&gt; a[i], d[i] = i; // 初始化 sort(d + 1, d + 1 + n, cmp); // 离散化 } 经简易证明可知，d数组的顺序对个数等于a数组的逆序对个数，故可使用树状数组进行求解。 Step2: 求顺序对：每次把新的x放进去后，query(x-1)查找小于x的数的个数，统计答案 void update(int i, int x) { for (int pos = i; pos &lt; maxn; pos += lowbit(pos)) { tr[pos] += x; } } int query(int n) { // 查询1-n有几个数存在 int ret = 0; for (int pos = n; pos; pos -= lowbit(pos)) { ret += tr[pos]; } return ret; } signed main() { cin &gt;&gt; n; rep(i, 1, n + 1) cin &gt;&gt; a[i], d[i] = i; // 初始化 sort(d + 1, d + 1 + n, cmp); // 离散化 int ans = 0; rep(i, 1, n + 1) { update(d[i], 1); ans += query(d[i] - 1); // 计数 } cout &lt;&lt; ans; } end.","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"树状数组","slug":"树状数组","permalink":"https://maskros.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"字符串Hash 给我狠狠的哈希！","slug":"algorithm/learn/字符串Hash","date":"2022-04-13T10:55:00.000Z","updated":"2022-05-17T16:52:33.642Z","comments":true,"path":"/post/algorithm/learn/字符串Hash.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E5%AD%97%E7%AC%A6%E4%B8%B2Hash.html","excerpt":"String Hash","text":"字符串Hash本质：把每个不同的字符串转化成不同的整数 难点：如何构造一个合适的Hash函数 性质：Hash值不一样的两个字符串一定不一样，但Hash值一样的字符串不一定不一样 (但大概率一样) 单Hash 偷懒也可以 unsigned long long 自然溢出不用取mod，不过可能会被卡 要求： 和 均为质数，， 取尽量大 可任取131,233… 双Hash ※子串Hash若已知 的字符串的Hash值，, 子串 的Hash值就可以 O(1) 求解： 如果需要反复求解子串Hash值，预处理 效果更佳 素数选择上界和下界指的是离素数最近的 的值。 lwr uBr % err prime 2^5 2^6 10.416667 53 2^6 2^7 1.041667 97 2^7 2^8 0.520833 193 2^8 2^9 1.302083 389 2^9 2^10 0.130208 769 2^10 2^11 0.455729 1543 2^11 2^12 0.227865 3079 2^12 2^13 0.113932 6151 2^13 2^14 0.008138 12289 2^14 2^15 0.069173 24593 2^15 2^16 0.010173 49157 2^16 2^17 0.013224 98317 2^17 2^18 0.002543 196613 2^18 2^19 0.006358 393241 2^19 2^20 0.000127 786433 2^20 2^21 0.000318 1572869 2^21 2^22 0.000350 3145739 2^22 2^23 0.000207 6291469 2^23 2^24 0.000040 12582917 2^24 2^25 0.000075 25165843 2^25 2^26 0.000010 50331653 2^26 2^27 0.000023 100663319 2^27 2^28 0.000009 201326611 2^28 2^29 0.000001 402653189 2^29 2^30 0.000011 805306457 2^30 2^31 0.000000 1610612741 题单 0x00 P3370 【模板】字符串哈希 模板 0x01 P2957 谷仓里的回声 同上 0x02 P1381 单词背诵 尺取 尺取(双指针)： 对给定的一个序列，在序列中寻找包含全部需求的，长度最小的一段子序列 O(n) 初始化左右下标 l, r 到适当位置 不停向右移动r，直到 r 出界或者[l, r] 自区间已经满足要求 ans = min(ans, r - l + 1) 移动 l 到适当位置，重复第一个过程 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define int ll #define p 233 #define mod 1610612741 #define maxn 1000005 int Hash1[1000005], Hash2[1000005], Hashtmp[1000005]; int b[1000005]; void add(int Hash[], string s) { Hash[0] = 0; for (int i = 0; i &lt; s.size(); i++) { Hash[i + 1] = (Hash[i] * p + (s[i] - 'a')) % mod; } } void init() { b[0] = 1; for (int i = 1; i &lt;= 1e6; i++) { b[i] = b[i - 1] * p % mod; } } int getHash(int Hash[], int l, int r) { return ((Hash[r] - Hash[l - 1] * b[r - l + 1]) % mod + mod) % mod; } map&lt;ll, int&gt; words; map&lt;ll, bool&gt; vis; string ss[maxn]; int cnt[maxn]; signed main() { init(); int n; cin &gt;&gt; n; while (n--) { string s; cin &gt;&gt; s; add(Hash1, s); words[Hash1[s.size()]]++; } int m; cin &gt;&gt; m; int tot = 0; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; ss[i]; add(Hashtmp, ss[i]); Hash2[i] = Hashtmp[ss[i].size()]; if (words[Hash2[i]] &amp;&amp; !vis[Hash2[i]]) { vis[Hash2[i]] = 1; tot++; cnt[i] = tot; } else if (words[Hash2[i]]) { cnt[i] = tot; } else { cnt[i] = 0; } } cout &lt;&lt; tot &lt;&lt; '\\n'; if (!tot) cout &lt;&lt; 0; else { int l = 1, r = 1; map&lt;ll, int&gt; haved; int ans = maxn; int tmp = 0; for (int l = 1, r = 1; r &lt;= m; r++) { if (words[Hash2[r]]) { if (haved[Hash2[r]] == 0) { tmp++; } haved[Hash2[r]]++; } if (tmp &lt; tot) continue; while (haved[Hash2[l]] &gt; 1 || !words[Hash2[l]]) { if (haved[Hash2[l]] &gt; 1) haved[Hash2[l]]--; l++; } ans = min(ans, r - l + 1); } cout &lt;&lt; ans; } } 0x03 EOJ 3486 最大的子串 二分 + Hash 求后缀的最长公共前缀 0x04 [JSOI2016]扭动的回文串","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"hash","slug":"hash","permalink":"https://maskros.top/tags/hash/"}]},{"title":"Java Syntax in 算法竞赛","slug":"note/java syntax","date":"2022-04-06T17:07:28.000Z","updated":"2022-04-08T15:05:49.396Z","comments":true,"path":"/post/note/java syntax.html","link":"","permalink":"https://maskros.top/post/note/java%20syntax.html","excerpt":"","text":"Java Syntax for ACM 临阵磨枪 0x00 Headerimport java.util.*; import java.math.*; import java.io.*; public class Main&#123; public static void main(String[] args)&#123; // hot key : main &#125; &#125; 0x01 I/OScanner cin = new Scanner(System.in); Scanner cin = new Scanner(new BufferedInputStream(System.in)); // more fast // most fast // main 函数要 throw IOException 每次输入前 cin.nextToken() // 数字输入cin.nval 字符串cin.sval static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); // 注意 sval 如果字符串纯数字会返回为null 应提前转义 cin.ordinaryChars('0', '9') ; cin.wordChars('0', '9'); int n = cin.nextInt(); String s = cin.next(); double t = cin.nextDouble(); String s = cin.nextLine(); // 读一整行 char[] c = cin.next().toCharArray(); // 多行输入 while (cin.hasNextInt()) while (cin.hasNext()) while (cin.nextToken() != StreamTokenizer.TT_EOF) // 文件末尾 // 读入一行，分割字符串 String s = cin.nextLine(); String[] split = s.split(\" \"); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); // more fast out.printf(); out.flush(); // 在代码的最后out.flush() System.out.println(); //sout System.out.printf(); 0x02 Common API vs STL 三级标题括号内容即对应c++ STL内容 0. 进制转换String s = Integer.toString(a, x); //把int型数据转换乘X进制数并转换成string型 x ∈ [2, 36] int b = Integer.parseInt(s, x); //把字符串当作X进制数转换成int型 1. sort默认排序 (对基本类型如int char) Arrays.sort(int[] a, int fromIndex, int toIndex); // 默认排序 升序 实现Comparator接口自定义比较器 (要使用基本类型所对应的类：(Integer, Character) ) @Override public int compare(type x, type y) Arrays.sort(a, 1, n + 1, Collections.reverseOrder()); // 降序的简便写法 public class Main &#123; public static void main(String[] args) &#123; //注意，要想改变默认的排列顺序，不能使用基本类型（int,double,char）而要使用它们对应的类 Integer[] a = &#123;9, 8, 7, 2, 3, 4, 1, 0, 6, 5&#125;; //定义一个自定义类Mycmp的对象 Comparator cmp = new MyCmp(); Arrays.sort(a, cmp); &#125; &#125; // 放在Main类外面 // Comparator是一个接口，所以这里我们自己定义的类MyComparator要implents该接口 class Mycmp implements Comparator&lt;Integer>&#123; //返回值为负则x排在y前面，反之在后面，为0则表示相等 @Override public int compare(Integer x, Integer y) &#123; if (x &lt; y) return 1; if (x > y) return -1; return 0; &#125; &#125; 实现Comparable接口自定义类排序 @Override public int compareTo(classname x) class Point implements Comparable&lt;Point>&#123; int x,y; //自定义的比较函数，跟2的语法类似，此例中先x后y从小到大排序 @Override public int compareTo(Point o) &#123; return x!=o.x? x-o.x: y-o.y; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; //Java里的数组要先new数组，再new每个元素，不是数组有了每个元素也就有了 Point[] p = new Point[10]; //其实应该在Point里重载有参的构造函数，直接在new的时候初始化，这样代码简洁些 for (int i = 1; i &lt;= n; i++) &#123; p[i] = new Point(); //不把每个元素new出来直接进行下面的赋值会空指针的 p[i].x = cin.nextInt(); p[i].y = cin.nextInt(); &#125; Arrays.sort(p, 1, n + 1);//先x后y从小到大排序 &#125; &#125; 2. String/StringBuilderString 是 final 类型，每一次拼接，都会构建一个新的String对象， 相加除外，但是 + 操作比较耗时 String s; char[] c; s = s.toCharArray(); // 字符串转换为字符数组 s.charAt(idx); // 返回下标对应的字符 s.equals(str); // 比较 s.split(str); // 根据str分割s, 返回String数组 s.substring(i, j); // 截取子串 s.concat(str); // 在后面连接子串 s = s.replace('x', 'y'); // 将x全部替换为y s.indexOf('c'); // 查找第一次出现c的地方 s.lastIndexOf('c'); // 查找最后一次出现c的地方 s.startsWith(str); s.endsWith(str); // 是否以指定字符串开始和结束 s.trim(); // 去除首尾空格 StringBuilder 一般拼接时使用 StringBuilder sb = new StringBuilder(); sb.append(x); // 末尾添加，任意数据类型都可以，都转换成string sb.append(x).append(y).append(z); // 可链式写法 sb.reverse(); // 翻转字符串 String s = sb.toString(); // 转换成String StringBuilder sb = new StringBuilder(s); // String转换成sb sb.equals(sb2); String s = sb.substring(l, r); // 区间截取 [l, r) sb.delete(l, r); sb.replace(l, r, str); 3. HashMap/TreeMap (map)无序HashMap 对应 unordered_map HashMap&lt;Character, Integer> mp = new HashMap&lt;Character, Integer>(); mp.put(c, x); // 存 mp.get(x); // 取，key不存在则返回null mp.remove(c); // 删 mp.replace(c, x) // 改, key不存在则无事发生 // 用迭代器遍历 Iterator&lt;Entry&lt;Character, Integer> > it = mp.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Character, Integer> e = it.next(); System.out.println(e.getKey() + \" \" + e.getValue()); &#125; // 用for-each循环遍历 更便捷 // entry 使用 getKey() 和 getvalue() 方法来获得键值 for (Map.Entry&lt;Character, Integer> e : mp.entrySet()) &#123; System.out.println(e.getKey() + \" \" + e.getValue()); &#125; // 检查键值是否存在 返回boolean mp.containsKey(c); mp.containsValue(x); 有序Treemap - map // 基本操作同上，多了查找方法 TreeMap&lt;K, V> mp = new TreeMap&lt;K,V>(); // 返回K 或 Map.Entry&lt;K,V> mp.ceilingKey(K key); //第一个大于等于key mp.floorKey(K key); //第一个小于等于key mp.lowerKey(K, key); //第一个小于key mp.higherKey(K, key); //第一个大于key 4. ArrayList (vector)ArrayList&lt;Integer> v = new ArrayList&lt;Integer>(); // 二维 ArrayList[] v = new ArrayList[n + 1]; for (int i = 0; i &lt; n; i++) &#123; v[i] = new ArrayList&lt;Integer>(); &#125; v.add(1); // 增 v.remove(idx); // 删除 v.remove(Integer.valueOf(1)); // 删除值为1的元素 v.set(idx, 1); // 改 v.get(idx); // 查 5. ArrayDeque/PriorityQueue ((queue/stack/deque)/priority_queue)ArrayDeque ArrayDeque&lt;Integer> q = new ArrayDeque&lt;Integer>(); // 无论如何都可以Foreach遍历 for(Integer x : q) &#123;...&#125; // queue q.offer(x); // 入队 q.peek(); // 队头 q.pop(); // 出队，同时返回值 while (!q.isEmpty()) &#123; System.out.println(q.pop()); // 弹出的同时可以返回队头元素，不像c++是void的 &#125; // stack s.push(x); // 入栈 s.peek(); // 栈顶 s.pop(); // 弹出栈顶，同时返回值 // deque d.addFirst(x); d.addLast(x); // 入队 d.getFirst(); d.getLast(); // 队头队尾 d.removeFirst(); d.removeLast(); // 删 PriorityQueue // 默认从小到大 foreach遍历不报错 但乱序 PriorityQueue&lt;Integer> q = new PriorityQueue&lt;Integer>(); q.offer(x); // 增 q.peek(); //获得第一个元素 q.poll(); //获取并移除第一个 q.remove(x); //移除指定元素 // 自定义优先队列比较器：实现Comparator接口即可 class Mycmp implements Comparator&lt;Integer> &#123; @Override public int compare(Integer x, Integer y) &#123; return y - x; &#125; &#125; PriorityQueue&lt;Integer> q = new PriorityQueue&lt;Integer>(new Mycmp()); 6. HashSet/TreeSet (set)HashSet无序 TreeSet有序 以下用TreeSet演示 TreeSet&lt;Integer> s = new TreeSet&lt;Integer>(); s.add(x); s.contains(x); // 返回boolean是否存在 s.remove(x); s.ceiling(x); s.floor(x); s.higher(x); s.lower(x); s.headSet(x); // 小于x组成的set s.tailSet(x); // 大于x组成的set s.subset(x, false, y, true); // (x, y]组成的set // 遍历 Iterator&lt;Integer> it = s.iterator(); while(it.hasNext())&#123; // 遍历 int x = it.next(); // ... &#125; 7. BigInter/BigDemical大整数/高精度 (直接根据自动补全名称使用对应方法即可) 8. Math// 除基本的Math.max, min, abs, sqrt, pow外 Math.ceil(x); // 向上取整 Math.floor(x); // 向下取整 Math.round(x); // 四舍五入 Math.random(); // 生成[0, 1) 之间的double伪随机数 Math.cos(x); Math.acos(x); Math.sin(x); Math.asin(x); Math.tan(x); Math.atan(x); // 三角函数 Math.acos(-1) = pi; ok","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"java","slug":"java","permalink":"https://maskros.top/tags/java/"},{"name":"STL","slug":"STL","permalink":"https://maskros.top/tags/STL/"}]},{"title":"Use Eclipse as a Coding IDE","slug":"note/Eclipse","date":"2022-04-04T16:07:28.000Z","updated":"2022-04-06T16:58:09.881Z","comments":true,"path":"/post/note/Eclipse.html","link":"","permalink":"https://maskros.top/post/note/Eclipse.html","excerpt":"","text":"Eclipse for Lanqiao 不咋用Eclipse 为了参加蓝桥记录一下 Eclipse Config0x01 自动补全Window —&gt; Preferences —&gt; Java —&gt; Editor —&gt; Content Assist Auto activation triggers for Java : .qwertyuiopasdfghjklzxcvbnm Disable insertion triggers except ‘Enter’ [Y] // 表示只有回车时才触发自动补全 Project —&gt; Build Automatically 取消勾选 关闭自动编译 0x02 新建文件New —&gt; Java Project —&gt; input your project name —&gt; new package —&gt; new Class —&gt; input your Class name —&gt; public static void main(String[] args) [Y] 0x03 快捷键 Keys Features Alt+↑/↓ 将当前行内容往上/下移动 Ctrl+shift+F 格式化 Ctrl+D 删除当前行 Alt+/ 代码助手 Ctrl+/ 注释 Ctrl+F11 运行 Ctrl+Alt+↑/↓ 复制当前行","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"}]},{"title":"数位dp专题训练","slug":"algorithm/exercise/数位dp_problem","date":"2022-03-23T12:30:00.000Z","updated":"2022-03-24T03:57:11.955Z","comments":true,"path":"/post/algorithm/exercise/数位dp_problem.html","link":"","permalink":"https://maskros.top/post/algorithm/exercise/%E6%95%B0%E4%BD%8Ddp_problem.html","excerpt":"","text":"数位dp专题训练猛练！ 0x00 Digit link 洛谷板子题 题意：定义一个正整数的价值是把这个数的十进制写出来之后，最长的等差子串的长度。求 范围内数字价值的总和。 /* 定义一个正整数的价值是把这个数的十进制写出来之后，最长的等差子串的长度。 求[l,r]范围内数字价值的总和。 */ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int T, n, m, len, a[20]; ll l, r, dp[20][15][25][25][20]; ll dfs(int pos, int pre, ll st, ll sum, int d, int lead, int limit) //pos搜到的位置 //pre前一位数 //st当前公差最大差值 //sum整个数字的最大价值 //d共差 //lead判断是否有前导0 //limit判断是否有最高位限制 { if (pos &gt; len) return sum; //dp结束 //记录状态（计划搜索） //注意d有负数，最小可以到-9，所以记录时数组下标是d+10 if ((dp[pos][pre][st][sum][d + 10] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre][st][sum][d + 10]; ll ret = 0; int res = limit ? a[len - pos + 1] : 9; //最高位最大值 for (int i = 0; i &lt;= res; i++) { //有前导0且这位也是前导0，一切不变只有位数变化 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 0, -38, 1, limit &amp;&amp; (i == res)); //有前导0但这位不是前导0（这位是数字的最高位）开始有前一位，一个数形成等差数列 else if (i &amp;&amp; lead) ret += dfs(pos + 1, i, 1, 1, -38, 0, limit &amp;&amp; (i == res)); //之前刚搜到1位还没有共差，两位数形成等差数列，记录共差 else if (d &lt; -9) ret += dfs(pos + 1, i, 2ll, 2ll, i - pre, 0, limit &amp;&amp; (i == res)); //搜到2位以后，共差若与前两位相同当前等差数列长度增加，若公差变化则更新整个数字的最大价值，等差数列长度又变为2 else if (d &gt;= -9) ret += dfs(pos + 1, i, (i - pre == d) ? st + 1 : 2, max(sum, (i - pre == d) ? st + 1 : 2), (i - pre == d) ? d : i - pre, 0, limit &amp;&amp; (i == res)); } //没有前导0和最高限制时可以直接记录当前dp值以便下次搜到同样的情况可以直接使用。 return (!limit &amp;&amp; !lead) ? dp[pos][pre][st][sum][d + 10] = ret : ret; } ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof(dp)); return dfs(1, 0, 0, 0, -38, 1, 1); //-38是随便赋的其实赋成-10就行了…… } int main() { cin &gt;&gt; T; while (T--) { cin &gt;&gt; l &gt;&gt; r; //l是0的时候要特别注意！ if(l) cout &lt;&lt; (part(r) - part(l - 1)) &lt;&lt; '\\n'; else cout &lt;&lt; part(r) - part(l) + 1 &lt;&lt; '\\n'; } return 0; } 0x01 HDU2089 不要62 link 题意： 入门题，统计区间内不含4或62的数字个数 int a[10], len; ll l, r; ll dp[15][15]; ll dfs(int pos, int pre, int lead, int limit) { if (pos &gt; len) return 1; //剪枝 if ((dp[pos][pre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { if (i == 4) continue; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 else { if (i == 2 &amp;&amp; pre == 6) continue; ret += dfs(pos + 1, i, 0, i == res &amp;&amp; limit); } } if (!limit &amp;&amp; !lead) dp[pos][pre] = ret; //当前状态方案数记录 return ret; } //把数按位拆分 ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 1, 1); //进入记搜 } int main() { while(cin &gt;&gt; l &gt;&gt; r) { if(!l &amp;&amp; !r) break; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; } } 0x02 数位小孩 link 题意： 给定区间，统计区间中有多少个数同时满足：每相邻两个数位和为素数，其中至少一个数位为1，且没有前导0 int a[20], len; ll l, r; bool prime[25]; ll dp[20][20]; ll dfs(int pos, int pre, bool one, int lead, int limit) //记搜 { if (pos &gt; len) if (one) return 1; else return 0; //剪枝 if ((dp[pos][pre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead) &amp;&amp; one)) return dp[pos][pre]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { bool nextone = one; if (i == 1 || pre == 1) nextone = 1; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 if (i &amp;&amp; lead) ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); // else else { if (!prime[i + pre]) continue; ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); } } if (!limit &amp;&amp; !lead &amp;&amp; one) dp[pos][pre] = ret; //当前状态方案数记录 return ret; } //把数按位拆分 ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 0, 1, 1); //进入记搜 } void pr(int x) { prime[x] = 1; } void init() { pr(2), pr(3), pr(5), pr(7), pr(11), pr(13), pr(17), pr(19); } int main() { init(); cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; } 0x03 AT4540 Digit Sum link 题意： 区间 ​ 内有多少个数，使得十进制表示的数字之和是 D 的倍数？ 答案对 1e9 + 7 取模，K &lt; 1e10000. D &lt; 1e2 题解：只需维护前缀和num即可，pre都用不到，注意输入数字较大，爆longlong要用string翻转处理，(开始没翻转过来wa了半天…) int a[maxn], len; ll l, r, D; ll dp[maxn][115]; ll dfs(int pos, int num, int lead, int limit) { if (pos &gt; len) return num == 0; //剪枝 if ((dp[pos][num] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][num] % mod; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { int num_ = (num + i) % D; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret = (ret + dfs(pos + 1, num_, 1, i == res &amp;&amp; limit) % mod) % mod; //有前导0但当前位不是前导0，当前位就是最高位 else if (i &amp;&amp; lead) ret = (ret + dfs(pos + 1, num_, 0, i == res &amp;&amp; limit) % mod) % mod; else { ret = (ret + dfs(pos + 1, num_, 0, i == res &amp;&amp; limit) % mod) % mod; } } if (!limit &amp;&amp; !lead) dp[pos][num] = ret % mod; //当前状态方案数记录 return ret % mod; } ll part(string x) { len = x.size(); // reverse for (int i = 0; i &lt; x.size(); i++) { a[len - i] = x[i] - '0'; } memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 1, 1); //进入记搜 } int main() { string s; cin &gt;&gt; s; cin &gt;&gt; D; cout &lt;&lt; (part(s) - part(\"0\") + mod) % mod &lt;&lt; '\\n'; } 0x04 SAC#1 - 萌数 link 题意： 只有满足“存在长度至少为2的回文子串”的数是萌的，求区间内萌数的个数。 题解： 正难则反，当一个数的任意一位都不和前两位的数字相同时，这个数就不含回文串 故dp[pos][pre][ppre]，pre表示上一位，ppre表示上二位的数字。 但是由于输入范围超过ll，所以需读入string，并且用总长度减去dp求得的方案数。 在这里没有更加简洁优化自己的代码，写了个丑陋的大数减法，虽然AC了但是待优化、、 优化细节： 由于答案是 sum[r] - sum[l - 1] 那么对于 ：需要写高精度减法吗？ 不用。直接求sum[r] 和 sum[l] 然后特判一下 这个左边界是否合法就行。 由于正难则反，取补集，需要使用 再减去答案，需要写高精度吗？ 不用。直接对 和 取模然后相减，得出的结果与 一致。 string l, r; int len, a[maxn]; int dp[maxn][15][15]; // pos pre ppre ll dfs(int pos, int pre, int ppre, int lead, int limit) { if (pos &gt; len) return 1; //剪枝 if ((dp[pos][pre][ppre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre][ppre] % mod; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { if ((!i) &amp;&amp; lead) ret = (ret + dfs(pos + 1, 0, -1, 1, i == res &amp;&amp; limit) % mod) % mod; else if (i &amp;&amp; lead) ret = (ret + dfs(pos + 1, i, -1, 0, i == res &amp;&amp; limit) % mod) % mod; else { if (pre == ppre || i == pre || i == ppre) continue; ret = (ret + dfs(pos + 1, i, pre, 0, i == res &amp;&amp; limit) % mod) % mod; } } if (!limit &amp;&amp; !lead) dp[pos][pre][ppre] = ret % mod; //当前状态方案数记录 return ret % mod; } ll part(string x, bool flag) { len = x.size(); rep(i, 0, len) { a[len - i] = x[i] - '0'; } if(flag) { if(len == 1 &amp;&amp; a[1] == 0) { a[1] = 0; } else { int idx = 1; while (idx &lt;= len) { if(a[idx] &gt; 0) { a[idx]--; break; } else a[idx] = 9, idx++; } } } memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, -1, 1, 1); //进入记搜 } // y - x + 1 int ret[maxn]; ll calc(string x, string y) { int lead = 1; int leny = y.size(), lenx = x.size(); if(lenx == 1 &amp;&amp; x[0] == '0') lead = 0; rep(i, 1, lenx + 1) { int tmp = y[leny - i] - '0' - (x[lenx - i] - '0') + lead; if(tmp &gt;= 10) { lead = 1; tmp = tmp % 10; } else if(tmp &lt; 0) { lead = -1; tmp = tmp + 10; } else lead = 0; ret[i] = tmp; } rep(i, lenx + 1, leny + 1) { int tmp = y[leny - i] - '0' + lead; if(tmp &gt;= 10) { lead = 1; tmp = tmp % 10; } else if(tmp &lt; 0) { lead = -1; tmp = tmp + 10; } ret[i] = tmp; } ll ans = 0; red(i, leny + 1, 1) { ans = (ans * 10 % mod + ret[i]) % mod; } return ans; } signed main() { cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; (calc(l, r) - (part(r, 0) - part(l, 1) + mod) % mod + mod) % mod &lt;&lt; '\\n'; } 0x05 [ZJOI2010]数字计数 link 题意：给定区间，统计区间内每个数各位数字出现的次数 思路：对0~9每个数字单独记搜 #define int ll ll l, r; int len, a[20]; int dp[20][20]; // pos int num = 0; ll dfs(int pos, int cnt, int lead, int limit) { if (pos &gt; len) return cnt;//剪枝 if ((dp[pos][cnt] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][cnt]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { // ret += dfs(pos + 1, cnt + ((i == num) &amp;&amp; (i || !lead)), lead &amp;&amp; (i == 0), i == res &amp;&amp; limit); int cnt_ = (i == num) ? cnt + 1 : cnt; if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 1, i == res &amp;&amp; limit); else if (i &amp;&amp; lead) ret += dfs(pos + 1, cnt_, 0, i == res &amp;&amp; limit); else ret += dfs(pos + 1, cnt_, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][cnt] = ret; //当前状态方案数记录 return ret; } ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 1, 1); //进入记搜 } signed main() { cin &gt;&gt; l &gt;&gt; r; while(num &lt;= 9) cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; ' ', num++; } 0x06 [AHOI2009] 同类分布 link 题意：统计区间内每个数各位数字之和能整除原数的数的个数，l, r &lt; 1e18 思路：模数就是各位数字之和。所以我们可以先确定这个值再搜。可以枚举各位数字之和。那么最坏的情况就是10^18-1，各位数字和为17 * 9=153，所以我们枚举153次即可。 dp数组维护各位数字之和d, 以及数字对mod取模的值sum即可，剪枝条件为 d == mod &amp;&amp; sum == 0 #define int ll ll l, r; int len, a[25]; int dp[25][180][180]; // pos sum d int mod; ll dfs(int pos, int sum, int d, int lead, int limit) { if (pos &gt; len) return d == mod &amp;&amp; sum == 0;//剪枝 if ((dp[pos][sum][d] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][sum][d]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { if(d + i &gt; mod) break; if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 1, i == res &amp;&amp; limit); else if (i &amp;&amp; lead) ret += dfs(pos + 1, i % mod, i, 0, i == res &amp;&amp; limit); else ret += dfs(pos + 1, (sum * 10 + i) % mod, d + i, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][sum][d] = ret; //当前状态方案数记录 return ret; } ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; ll ans = 0; rep(i, 1, 9 * len + 1) { memset(dp, -1, sizeof dp); mod = i; ans += dfs(1, 0, 0, 1, 1); } return ans; } signed main() { cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)); } 0x07 P4317 花神的数论题 link 题意： 表示 的二进制中 的个数，给定 , 求从 到 , 的乘积。对 1e7 + 7 取模，N &lt; 1e15 思路： 将 按照二进制存储，根据范围1e15可知，一个数的二进制有50位1，于是我们枚举1的个数，dp[pos][cnt] 维护1的个数cnt，剪枝时cnt=枚举个数即可返回计数。对枚举的每种情况进行计数用ksm乘即可。 ll qpow(ll a, ll b) { ll ans = 1; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; } return ans; } ll l, r; int len, a[70], tmp; int dp[70][70]; // pos cnt ll dfs(int pos, int cnt, int lead, int limit) { if (pos &gt; len) return cnt == tmp; if ((dp[pos][cnt] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][cnt]; ll ret = 0; int res = limit ? a[len - pos + 1] : 1; for (int i = 0; i &lt;= res; i++) { if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 1, i == res &amp;&amp; limit); else if (i &amp;&amp; lead) ret += dfs(pos + 1, i == 1, 0, i == res &amp;&amp; limit); else ret += dfs(pos + 1, (i == 1) + cnt, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][cnt] = ret; return ret; } ll part(ll x) { len = 0; while (x) a[++len] = x &amp; 1 ? 1 : 0, x /= 2; ll ans = 1; rep(i, 1, 70) { tmp = i; memset(dp, -1, sizeof dp); int fuck = dfs(1, 0, 1, 1); ans = ans * qpow(i, fuck) % mod; } return ans; } signed main() { cin &gt;&gt; r; cout &lt;&lt; part(r); }","categories":[{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"https://maskros.top/tags/dfs/"}]},{"title":"数位dp","slug":"algorithm/learn/数位dp","date":"2022-03-17T15:00:00.000Z","updated":"2022-03-24T03:54:04.578Z","comments":true,"path":"/post/algorithm/learn/数位dp.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E6%95%B0%E4%BD%8Ddp.html","excerpt":"","text":"数位dp数位dp是在范围内按位递推出最大值的快捷算法，由于是按位dp，所以数的大小对复杂度影响很小 ref: blog in luogu 导 经典题面： 求出一段区间 中，满足某一特殊条件的数有多少个，条件一般与数的大小无关而与数字的组成有关 数位dp较普通dp比较冷门，但是不会写就只能暴力骗分 = = 注：L, R 巨大爆longlong时要用字符串处理 注：由于搜索的速度很快，所以可以根据题意考虑枚举每种情况后分别进行记搜计数，最后再汇总。 基本原理 通过记忆化搜索来实现动态规划，相比正面递推在大多数情况下更简洁。 0X01 记忆化搜索从起点向下搜索，到最底层得到方案数，一层一层向上返回答案累加，最终从搜索起点得到最终答案。 对于区间 , 一般转化成两次数位dp，即找 和 两段，结果相减即可。 0x02 状态设计 考虑在哪一层，判断当前的状态 数位dp的状态能记录的最好都记录上 dfs()函数的一些参量： 数字位数 , 记录答案的 , 最高位限制 判断前导0的标记 由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系，所以一般在 dfs() 中也要记录前一位或前几位数 ​ 参量解释： 前导0标记 有的时候前导0不需要判断，根据题意即可 由于我们要搜的数可能很长，所以我们的直接最高位搜起 举个例子：假如我们要从找任意相邻两数相等的数 显然等等是符合题意的数 但是我们发现右端点是四位数 因此我们搜索的起点是，而三位数的记录都是等等 而这种情况下如果我们直接找相邻位相等则符合题意而都不符合题意了 所以我们要加一个前导0标记： 当前位 = 1 且当前位置为0，那么当前位置也是前导0，使 + 1 继续搜 当前位 = 1 但当前位不是0，那么本位为当前数字的最高位， + 1 继续搜 最高位标记 我们知道在搜索的数位搜索范围可能发生变化； 举个例子：我们在搜索 的数时，显然最高位搜索范围是 ~ ，而后面的位数的取值范围会根据上一位发生变化：当最高位是 ~ 时，第二位取值为 ; 当最高位是 时，第二位取值为 （再往上取就超出右端点范围了） 为了分清这两种情况，我们引入了 标记： 当前位 = 1 而且已经取到了能取到的最高位时，下一位 = 1； 当前位 = 1 但是没有取到能取到的最高位时，下一位 = 0； 当前位 = 0 则下一位也为0。 我们设这一位的标记为 ，这一位能取到的最大值为 ，则下一位的标记就是i == res &amp;&amp; limit ( ​ 枚举这一位填的数) 0x03 dp数位dp在记忆化搜索的框架下进行，每找到一种情况我们就将这种情况记录下来，等到后面搜到相同情况时直接使用当前记录的值即可。 dp数组的下标：表示一种状态。只要当前状态和之前搜过的某个状态完全一样，就可以直接返回原来已经记录下的dp值。 重要的例子： 区间： 搜到 时，dfs从下返回上来的数值就是 当前位是第5位，前一位是0的方案数，搜完之后记录方案数字。 当搜到 时，就发现当前状态一样是 搜到第5位，且前一位是0，与之前记录情况完全相同，所以就不用向下搜，直接返回上次dp值即可。 如果搜到 ，不能直接返回当前位是第5位，前一位是4的dp值。 因为这个状态的dp值被记录时，当前位也就是第5位的取值是 ，而这次当前位的取值是​，方案数一定比之前记录的dp值要小。当前 = 1, 最高位有取值的限制。 结论： 当 = 1时，不能记录和取用dp值，同理 = 1 时也不行。 板子ll dfs(int pos, int pre, int st, ……, int lead, int limit) //记搜 { if (pos &gt; len) return st; //剪枝 if ((dp[pos][pre][st]……[……] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead))) return dp[pos][pre][st]……[……]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, ……, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 else if (i &amp;&amp; lead) ret += dfs(pos + 1, i, ……, 0, i == res &amp;&amp; limit); else if (根据题意而定的判断) ret += dfs(……, ……, 0, i == res &amp;&amp; limit); } if (!limit &amp;&amp; !lead) dp[pos][pre][st]……[……] = ret; //当前状态方案数记录 return ret; } ll part(ll x)//把数按位拆分 { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, ……, ……, 1, 1); //进入记搜 } int main() { cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; return 0; } 题单solution 0x00 Digit link 0x01 HDU2089 不要62 link 0x02 数位小孩 link 0x03 AT4540 Digit Sum link 0x04 SAC#1 - 萌数 link 0x05 [ZJOI2010]数字计数 link 0x06 [AHOI2009] 同类分布 link 0x07 P4317 花神的数论题 link","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"2022牛客寒假算法基础集训营5","slug":"nowcoder/2022winter/round5","date":"2022-03-16T15:30:50.000Z","updated":"2022-03-24T06:42:24.884Z","comments":true,"path":"/post/nowcoder/2022winter/round5.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round5.html","excerpt":"","text":"2022牛客寒假算法基础集训营5 补一下打的最烂的一场 A 疫苗小孩 (二分) 题意： 给定长为 n 的01串，0表示可以打疫苗，最多可以打三针，每两针相差k天时可以贡献w，每多相差x天或者少相差x天，贡献都会减少为 w-q*x，问最大贡献是多少 思路： 可以发现1针和0针的贡献都为0，所以直接考虑2针及以上的情况枚举第二针所在的位置pos，二分找到离 pos+k 和 pos-k 最近的两个点计算最大贡献即可 使用 lower_bound 函数， 复杂度 #define int ll int a[maxn]; void solve() { int n; cin &gt;&gt; n; int cnt = 0; rep(i, 1, n + 1) { char t; cin &gt;&gt; t; if(t == '0') a[++cnt] = i; } int k, w, q; cin &gt;&gt; k &gt;&gt; w &gt;&gt; q; int ans = 0; rep(i, 2, cnt + 1) { // first &gt;= int pos1 = lower_bound(a + 1, a + cnt + 1, a[i] - k) - a; int pos2 = lower_bound(a + 1, a + cnt + 1, a[i] + k) - a; int mn1 = min(abs(a[i] - k - a[pos1]), abs(a[i] - k - a[max(1ll, pos1 - 1)])); int mn2 = min(abs(a[i] + k - a[pos2]), abs(a[i] + k - a[max(1ll, pos2 - 1)])); int tmp1 = max(0ll, w - q * mn1), tmp2 = max(0ll, w - q * mn2); if(i == cnt) tmp2 = 0; ans = max(ans, tmp1 + tmp2); } cout &lt;&lt; ans; } *C 战旗小孩 (二进制枚举) 题意： n, k, s 表示游戏局数，可以获得额外机会的次数和起始分数，随后一行 n 个数 pi 为每一局结束后的一个特定分数，如果该局结束后分数大于等于该特定分数，就高兴一次，pi 顺序不能改变。接下来 n 行为每局结束后分数的变化delta和如果是用额外机会分数的变化delta。可以变换 n 局游戏的顺序，问最多能高兴几次。 0= &lt; k &lt; n &lt;= 20 思路： 由于 n 很小，采用二进制枚举，1的个数为使用额外机会的次数，处理一下每局可能获得的最大值，每次选择最大值计算即可。 __builtin_popcount(n) 表示 n 内二进制位为1的个数 int n, k, s; int p[maxn], v[maxn], w[maxn]; int h[maxn]; int cal(int x) { rep(i, 0, n) { if((x &gt;&gt; i) &amp; 1) h[i + 1] = w[i + 1]; else h[i + 1] = v[i + 1]; } sort(h + 1, h + n + 1, greater&lt;int&gt;() ); int tmp = s; int ret = 0; rep(i, 1, n + 1) { tmp += h[i]; if(tmp &gt;= p[i]) ret++; } return ret; } void solve() { cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; int ans = 0; rep(i, 1, n + 1) cin &gt;&gt; p[i]; rep(i, 1, n + 1) { int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; v[i] = max(a, b); w[i] = max({v[i], c, d}); } int mx = 1 &lt;&lt; n; rep(i, 0, mx) { if (__builtin_popcount(i) == k) ans = max(ans, cal(i)); } cout &lt;&lt; ans; } D 数位小孩 (数位dp) 题意： 给定区间，统计区间中有多少个数同时满足：每相邻两个数位和为素数，其中至少一个数位为1，且没有前导0 思路： 套数位dp板子即可 int a[20], len; ll l, r; bool prime[25]; ll dp[20][20]; ll dfs(int pos, int pre, bool one, int lead, int limit) //记搜 { if (pos &gt; len) if (one) return 1; else return 0; //剪枝 if ((dp[pos][pre] != -1 &amp;&amp; (!limit) &amp;&amp; (!lead) &amp;&amp; one)) return dp[pos][pre]; //记录当前值 ll ret = 0; //暂时记录当前方案数 int res = limit ? a[len - pos + 1] : 9; //res当前位能取到的最大值 for (int i = 0; i &lt;= res; i++) { bool nextone = one; if (i == 1 || pre == 1) nextone = 1; //有前导0并且当前位也是前导0 if ((!i) &amp;&amp; lead) ret += dfs(pos + 1, 0, 0, 1, i == res &amp;&amp; limit); //有前导0但当前位不是前导0，当前位就是最高位 if (i &amp;&amp; lead) ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); // else else { if (!prime[i + pre]) continue; ret += dfs(pos + 1, i, nextone, 0, i == res &amp;&amp; limit); } } if (!limit &amp;&amp; !lead &amp;&amp; one) dp[pos][pre] = ret; //当前状态方案数记录 return ret; } //把数按位拆分 ll part(ll x) { len = 0; while (x) a[++len] = x % 10, x /= 10; memset(dp, -1, sizeof dp); //初始化-1（因为有可能某些情况下的方案数是0） return dfs(1, 0, 0, 1, 1); //进入记搜 } void pr(int x) { prime[x] = 1; } void init() { pr(2), pr(3), pr(5), pr(7), pr(11), pr(13), pr(17), pr(19); } int main() { init(); cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; part(r) - part(max(0ll, l - 1)) &lt;&lt; '\\n'; } G 163小孩 排列组合 int ans = C(13, 2) * 2 + C(13, 3) * 3 + C(13, 2) + C(13, 3) * 6 + C(13, 4) * 4 + C(13, 3) + C(13, 4) * C(4, 2) + C(13, 5) * 5 + C(13, 6); I 兔崽小孩 (前缀和/二分) 题意： n条说说，q次询问，每条说说有固定的发送时间t，每次询问k, p; k表示入睡时间，p表示要求的总睡眠时间，如果最后总睡眠时间小于p则输出NO， 否则YES 思路： 对时间差值排序，维护前缀和，对每次询问二分查找到大于k的下标，利用前缀和数组区间求和进行计算即可。 int t[maxn]; int a[maxn], pre[maxn]; void solve() { int n, q; cin &gt;&gt; n &gt;&gt; q; int len = 0; rep(i, 0, n) { cin &gt;&gt; t[i]; if (i) a[++len] = t[i] - t[i - 1]; } sort(a + 1, a + len + 1, greater&lt;int&gt;()); pre[1] = a[1]; rep(i, 2, len + 1) { pre[i] = pre[i - 1] + a[i]; } rep(i, 0, q) { int k, p; cin &gt;&gt; k &gt;&gt; p; int idx = lower_bound(a + 1, a + 1 + len, k, greater&lt;int&gt;()) - a; int tmp = pre[idx - 1] - (idx - 1) * k; tmp &gt;= p ? puts(\"Yes\") : puts(\"No\"); } } J 三国小孩沙比题，略了","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"https://maskros.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"}]},{"title":"Codeforce Edu 124 & Round 777 Problem D","slug":"codeforces/cf Edu 124 & 777 D","date":"2022-03-13T13:20:00.000Z","updated":"2022-03-14T15:04:58.363Z","comments":true,"path":"/post/codeforces/cf Edu 124 & 777 D.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20124%20&%20777%20D.html","excerpt":"","text":"Codeforce Edu 124 &amp; Round 777 Problem DEdu 124 D Nearest_Excluded_Points (BFS) 题意： 给定 个点的坐标，对于每个点，打印哈密顿距离最近且不包含在该 个点中的点的坐标。 思路： 从外往里bfs。如果一个点没被围死，那么总有一个相邻的点为答案，被围死了则外围的点也有答案。 首先，我们可以为所有与至少一个不属于这个集合的点相邻的点找到答案。这些点的距离显然是1（这是我们能得到的最小的答案）。在下一次迭代中，我们可以为所有与找到答案的点相邻的点设定答案（因为它们没有不属于集合的邻居，所以它们的距离至少是2）。哪一个点并不重要，所以如果点i与答案为1的点j相邻，我们可以将点i的答案设置为点j的答案。就代码而言，这可以通过广度优先搜索（BFS）来完成。换句话说，我们为距离为1的点设置答案，然后将这些答案按距离增加的顺序推给所有相邻的点，直到我们找到所有答案。 int n; int dx[] = {0, 0, -1, 1}; int dy[] = {-1, 1, 0, 0}; void solve() { cin &gt;&gt; n; vector&lt;pii&gt; v; rep(i, 0, n) { int x, y; cin &gt;&gt; x &gt;&gt; y; v.pb({x, y}); } set&lt;pii&gt; st(v.begin(), v.end()); map&lt;pii, pii&gt; ans; queue&lt;pii&gt; q; for(auto [x, y] : v) { rep(i, 0, 4) { int nx = x + dx[i], ny = y + dy[i]; if(st.count({nx, ny})) continue; ans[{x, y}] = {nx, ny}; q.push({x, y}); break; } } while(!q.empty()) { auto it = q.front(); int x = it.fst, y = it.sec; q.pop(); rep(i, 0, 4) { int nx = x + dx[i], ny = y + dy[i]; if(!st.count({nx, ny}) || ans.count({nx, ny})) continue; ans[{nx, ny}] = ans[{x, y}]; q.push({nx, ny}); } } for(auto [x, y] : v) { auto it = ans[{x, y}]; cout &lt;&lt; it.fst &lt;&lt; \" \" &lt;&lt; it.sec &lt;&lt; '\\n'; } } cf 777 D Madoka_and_the_Best_School_in_Russia 题意： 给定 , , 判断是否至少有两种方法可以把 任意拆成 (1 ~ n)个数，使得拆出来的每个数都可以整除 ，但不能整除 (n &gt;= 2) ，能则输出YES，否则输出NO 思路： 分类讨论： ① 如果 x 不能整除 d*d ，则铁定为NO 对 x 不断除 d，共分解成 div 个 d (div &gt;= 2) 和剩余的因子 x ② 如果 x 不为质数，则至少有两种分解方式，一定能凑出两种情况，为YES ③ 如果 x 为质数，且 d 被唯一分解为 x * x，当且仅当 div = 3 时，为NO ④ 如果 x 为质数，d 不为质数且 div &gt; 2，为YES ⑤ 其余情况为NO int prime(int x) { for (int i = 2; i &lt;= sqrt(x); i++) { if(x % i == 0) return i; } return -1; } void solve() { int x, d; cin &gt;&gt; x &gt;&gt; d; int dd = d * d; if(x % dd != 0) { puts(\"NO\"); return; } int div = 0; while(x % d == 0) x /= d, div++; if(prime(x) != -1) { puts(\"YES\"); return; } if(prime(d) != -1 &amp;&amp; d == prime(d) * prime(d)) { if(x == prime(d) &amp;&amp; div == 3) { puts(\"NO\"); return; } } if(div &gt; 2 &amp;&amp; prime(d) != -1) { puts(\"YES\"); return; } puts(\"NO\"); }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"bfs","slug":"bfs","permalink":"https://maskros.top/tags/bfs/"},{"name":"讨论","slug":"讨论","permalink":"https://maskros.top/tags/%E8%AE%A8%E8%AE%BA/"}]},{"title":"CSP202109-2 非零段划分","slug":"probs/CSP非零段划分","date":"2022-03-01T14:30:50.000Z","updated":"2022-03-01T15:41:17.264Z","comments":true,"path":"/post/probs/CSP非零段划分.html","link":"","permalink":"https://maskros.top/post/probs/CSP%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86.html","excerpt":"","text":"CSP 202109-2 非零段划分 (差分) link 赛时没想明白，写了个暴力70分，一直惦记着这个题，故在此重做 题面A1,A2,⋯,An 是一个由 n 个自然数（非负整数）组成的数组。我们称其中 Ai,⋯,Aj 是一个非零段，当且仅当以下条件同时满足： 1≤i≤j≤n； 对于任意的整数 k，若 i≤k≤j，则 Ak&gt;0； i=1 或 Ai−1=0； j=n 或 Aj+1=0。 下面展示了几个简单的例子： A=[3,1,2,0,0,2,0,4,5,0,2] 中的 4 个非零段依次为 [3,1,2]、[2]、[4,5] 和 [2]； A=[2,3,1,4,5] 仅有 1 个非零段； A=[0,0,0] 则不含非零段（即非零段个数为 0）。 现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，可取 p=1，即不对 A 做任何修改。 规定： 全部的测试数据满足 n≤5e5，且数组 A 中的每一个数均不超过 1e4 题解非零段可以理解为孤立的岛屿，不同的岛屿之间用 0 分隔开。选择一个正整数 p ，将所有小于 p 的数都变为 0 ，可以理解为海平面上涨到 p 的位置，p 以下的部分都被淹没，求孤立岛屿数最大是多少。可以先考虑 p = 10001 的情况：所有数字都被海水淹没了，显然只有 0 00 个岛屿。然后海平面逐渐下降，观察岛屿数量的变化。可以看出：每当一个凸峰出现，岛屿数就多了一个；而每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连接在了一起，岛屿数减少一个。凸峰点和凹谷点的判断需要注意平面（如 1 2 2 1 ）的存在：若连续一段数字相同，可以把他们合并成一个点（1 2 1），这样对答案不会产生影响，可以使用 std::unique() 函数来去掉相邻重复元素。 🐴vector&lt;int&gt; v; int high[100005], low[100005], cnt[100005]; void solve(){ int n; cin &gt;&gt; n; v.pb(0); rep(i, 0, n) { int t; cin &gt;&gt; t; if(i &amp;&amp; t != v[v.size() - 1] || i == 0) v.pb(t); } v.pb(0); rep(i, 1, v.size() - 1) { if(v[i] &gt; v[i - 1] &amp;&amp; v[i] &gt; v[i + 1]) high[v[i]]++; if(v[i] &lt; v[i - 1] &amp;&amp; v[i] &lt; v[i + 1]) low[v[i]]++; } cnt[100001] = 0; int ans = 0; red(i, 100001, 0) { cnt[i] = cnt[i + 1] + high[i] - low[i]; ans = max(ans, cnt[i]); } cout &lt;&lt; ans &lt;&lt; '\\n'; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"差分","slug":"差分","permalink":"https://maskros.top/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"Codeforces Round 773 (Div.2)","slug":"codeforces/cf 773","date":"2022-02-23T14:30:00.000Z","updated":"2022-02-23T14:45:35.740Z","comments":true,"path":"/post/codeforces/cf 773.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20773.html","excerpt":"Codeforces Round 773 (Div.2)","text":"Codeforces Round #773 (Div.2) rk 293 AB各自白给了一发，但是上大分，嘻嘻 A_Hard_Way 水题，一开始没读懂题直接猜答案猜错了WA1，急了大火 void solve() { int x1, y1, x2, y2, x3, y3; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3; double ans = 0; if (y1 == y2) ans = (y3 &lt; y2) ? abs(x2 - x1) : 0; eif(y2 == y3) ans = (y1 &lt; y3) ? abs(x3 - x2) : 0; eif(y1 == y3) ans = (y2 &lt; y3) ? abs(x3 - x1) : 0; printf(\"%.9f\\n\", ans); } B_Power_Walking 水题，忘记 map.clear()了，白wa1发，纯丢人 map&lt;int, int&gt; mp; void solve() { mp.clear(); int n; cin &gt;&gt; n; rep(i, 1, n + 1) { int t; cin &gt;&gt; t; mp[t]++; } int mx = mp.size(); rep(i, 1, n + 1) cout &lt;&lt; max(i, mx) &lt;&lt; ' '; en; } C_Great_Sequence 题意： 给定长为 的数组 ，给定 ，你可以向数组中添加一些数，使得数组中的数两两一组，并且满足 ，询问至少添加多少个数。 思路： 暴力贪心即可，满足的直接扬了，用 multiset 维护一下，:) multiset&lt;ll&gt; s; void solve() { s.clear(); int n, x; cin &gt;&gt; n &gt;&gt; x; int t; rep(i, 0, n) {cin &gt;&gt; t; s.insert(t);} multiset&lt;ll&gt;::iterator it; int ans = 0; for (it = s.begin(); it != s.end(); it++) { ll tmp = (*it) * x; if(s.find(tmp) != s.end()) { s.erase(s.find(tmp)); }else ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } D_Repetitions_Decoding (构造) 题意： 给定一个数组，你可以对它进行操作：在某一位置连续插入两个相同数字。最终使得该数组按顺序变成 对重复序列 ​ 。(tandem repeats: 串联重复序列，如：1 2 3 1 2 3 | 4 7 5 4 7 5 | 6 6 ) 最终指定格式分别打印：操作数、操作内容、、最终序列的组成结构。如果不能构造输出 -1. 思路： 由于题干说只要构造成功就可以，不追求最小操作数，所以我们直接贪心即可。 首先由于每次操作插入的都是两个相同数字，故如果原序列中某个数只有奇数个，是不能构成 ​ 对重复序列的，特判一下； 构造时使用 vector 维护，双指针 , 扫描序列。从头开始，在序列中找到下一个与 一样的数的位置，标记为 (right_begin)，随后同时向右扫描，如果 = ，则跳过，如果不等，则在下标为 的位置插入 。当左侧序列指针 扫描到右侧序列起点处 时 ，则构成了一对重复序列，记录一下答案后，使 = 继续向后扫描即可。 写的时候由于对下标的混淆结果卡了一会，最后过的时候居然div2全场只过了200人，开心嗨了 :) vector&lt;int&gt; v; vector&lt;pair&lt;int,int&gt; &gt; op; vector&lt;int&gt; ans; map&lt;int, int&gt; mp; map&lt;int, int&gt;::iterator it; vector&lt;int&gt;::iterator pos; void debug() { en; for(auto x : v) de(x); en; en; } void solve() { mp.clear(); v.clear(); op.clear(); ans.clear(); int n; cin &gt;&gt; n; rep(i, 0, n) { int t; cin &gt;&gt; t; v.pb(t); mp[t]++; } bool flag = 1; for(it = mp.begin(); it != mp.end(); it++) { if(it-&gt;sec &amp; 1) { flag = 0; break;} } if(!flag) {cout &lt;&lt; -1 &lt;&lt; '\\n'; return;} else { int bg = 0, rbg, r; bool is = false; rep(i, 0, v.size()) { r++; if(!is) { pos = find(v.begin() + i + 1, v.end(), v[i]); bg = i; rbg = pos - v.begin(); r = rbg; is = true; } else { if(i == rbg) { i = r - 1; ans.pb(r - bg); is = false; continue; } if(r &gt;= v.size()) { v.pb(v[i]); v.pb(v[i]); op.pb(mpr(r + 1 - 1, v[i])); continue; } if(v[i] != v[r]) { v.insert(v.begin() + r, v[i]); v.insert(v.begin() + r, v[i]); op.pb(mpr(r + 1 - 1, v[i])); } } } } if(op.empty()) cout &lt;&lt; 0 &lt;&lt; '\\n'; else { cout &lt;&lt; op.size() &lt;&lt; '\\n'; for (auto x : op) cout &lt;&lt; x.fst &lt;&lt; \" \" &lt;&lt; x.sec &lt;&lt; \" \"; en; } if(ans.empty()) cout &lt;&lt; 1 &lt;&lt; '\\n' &lt;&lt; v.size() &lt;&lt; '\\n'; else { cout &lt;&lt; ans.size() &lt;&lt; '\\n'; for(auto x : ans) cout &lt;&lt; x &lt;&lt; ' '; en; } } 这场因为div1, div2同时进行分了波流，偷了个上分机会，变色！","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"LCA板子","slug":"algorithm/learn/LCA","date":"2022-02-08T16:00:00.000Z","updated":"2022-02-10T13:51:45.351Z","comments":true,"path":"/post/algorithm/learn/LCA.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/LCA.html","excerpt":"Lowest Common Ancestor","text":"LCALowest Common Ancestor 最近公共祖先 定义一般指图论中有向无环图DAG或树中的最近公共祖先，两个节点的LCA在两点间的路径上 四种求解板子 在线算法：问一次回答一次 离线算法：问完了一次性回答 0x01 树剖 在线 树链剖分求解LCA的过程就是轻重链的跳转，跟树剖求任意两点间的距离一样的操作，只不过不用线段树去维护dis了 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int sz[N], dep[N], fa[N], son[N], top[N]; int n, m; inline int read() { int f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } void add(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void dfs1(int rt, int f) { dep[rt] = dep[f] + 1; sz[rt] = 1, fa[rt] = f; for(int i = head[rt]; i; i = nex[i]) { if(to[i] == f) continue; dfs1(to[i], rt); if(!son[rt] || sz[to[i]] &gt; sz[son[rt]]) son[rt] = to[i]; sz[rt] += sz[to[i]]; } } void dfs2(int rt, int t) { top[rt] = t; if(!son[rt]) return ; dfs2(son[rt], t); for(int i = head[rt]; i; i = nex[i]) { if(to[i] == fa[rt] || to[i] == son[rt]) continue; dfs2(to[i], to[i]); } } int solve(int x, int y) { while(top[x] != top[y]) { if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = fa[top[x]]; } return dep[x] &lt; dep[y] ? x : y; } int main() { n = read(), m = read(); int rt = read(); int x, y; for(int i = 1; i &lt; n; i++) { x = read(), y = read(); add(x, y); add(y, x); } dfs1(rt, 0); dfs2(rt, rt); for(int i = 1; i &lt;= m; i++) { x = read(), y = read(); printf(\"%d\\n\", solve(x, y)); } return 0; } 0x02 Tarjan 离线 后序DFS+并查集 本质就是利用了dfs的节点顺序，当我们正在递归两个节点的最近公共祖先时，显然这两个点是属于其子树的节点，那么当我们第一次遍历完两个需要求解的两个点时，其最近的尚未被完全遍历完子节点的节点就是他们两个的最近公共祖先 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 5e5 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int visit[N], fa[N], n, m; int qhead[N], qto[N &lt;&lt; 1], qnex[N &lt;&lt; 1], qcnt = 1, qid[N &lt;&lt; 1], ans[N]; inline int read() { int f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } void add_edge(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void add_query(int x, int y, int w) { qto[qcnt] = y; qnex[qcnt] = qhead[x]; qid[qcnt] = w; qhead[x] = qcnt++; } int find(int rt) { return rt == fa[rt] ? rt : fa[rt] = find(fa[rt]); } void tarjan(int rt, int f) { for(int i = head[rt]; i; i = nex[i]) { if(to[i] == f) continue; tarjan(to[i], rt); fa[to[i]] = rt; } visit[rt] = 1; for(int i = qhead[rt]; i; i = qnex[i]) { if(!visit[qto[i]]) continue; ans[qid[i]] = find(qto[i]); } } int main() { // freopen(\"in.txt\", \"r\", stdin); n = read(), m = read(); int rt = read(); for(int i = 1; i &lt; n; i++) { int x = read(), y = read(); add_edge(x, y); add_edge(y, x); } for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 1; i &lt;= m; i++) { int x = read(), y = read(); add_query(x, y, i); add_query(y, x, i); } tarjan(rt, 0); for(int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0; } 0x03 ST表+RMQ 在线 先序DFS+ST RMQ(Range Mini/Maximum Query) 区间最值查询 利用dfs的遍历，在遍历两个点的时候，一定会在中间返回到其最近公共祖先，这个时候的公共祖先也就是这两个点的遍历中的最小值 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; inline ll read() { ll f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } const int N = 5e5 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int id[N], tot, last; int st[N &lt;&lt; 2][30]; void add(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void dfs(int rt, int fa) { id[rt] = last = ++tot; st[tot][0] = rt; for(int i = head[rt]; i; i = nex[i]) { if(to[i] == fa) continue; dfs(to[i], rt); st[++tot][0] = rt; } } int MIN(int a, int b) { return id[a] &lt; id[b] ? a : b; } int main() { // freopen(\"in.txt\", \"r\", stdin); int n = read(), m = read(), rt = read(); for(int i = 1; i &lt; n; i++) { int x = read(), y = read(); add(x, y); add(y, x); } dfs(rt, 0); int k = log(last) / log(2); for(int j = 1; j &lt;= k; j++) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= last; i++) st[i][j] = MIN(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for(int i = 1; i &lt;= m; i++) { int x = read(), y = read(); x = id[x], y = id[y]; if(x &gt; y) swap(x, y); int k = log(y - x + 1) / log(2); printf(\"%d\\n\", MIN(st[x][k], st[y - (1 &lt;&lt; k) + 1][k])); } return 0; } 0x04 倍增 类似于快速幂，通过二进制数的组合来达到 级别的优化，但是需要注意其中进制的枚举大小顺序 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; inline ll read() { ll f = 1, x = 0; char c = getchar(); while(c &gt; '9' || c &lt; '0') { if(c == '-') f = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return f * x; } const int N = 5e5 + 10; int head[N], to[N &lt;&lt; 1], nex[N &lt;&lt; 1], cnt = 1; int fa[N][21], dep[N], n, m; void add(int x, int y) { to[cnt] = y; nex[cnt] = head[x]; head[x] = cnt++; } void dfs(int rt, int f) { dep[rt] = dep[f] + 1; fa[rt][0] = f; for(int i = 1; 1 &lt;&lt; i &lt;= dep[rt]; i++)//进制由小到大递推 fa[rt][i] = fa[fa[rt][i - 1]][i - 1]; for(int i = head[rt]; i; i = nex[i]) { if(to[i] == f) continue; dfs(to[i], rt); } } int LCA(int x, int y) { if(dep[x] &lt; dep[y]) swap(x, y); for(int i = 20; i &gt;= 0; i--)//进制由大到小开始组合， if(dep[fa[x][i]] &gt;= dep[y]) x = fa[x][i]; if(x == y) return x;//注意特判 for(int i = 20; i &gt;= 0; i--)//进制从小到大开始组合， if(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0];//这一步尤其考虑，为什么x, y不知LCA,而其父节点就一定是LCA， } int main() { // freopen(\"in.txt\", \"r\", stdin); int n = read(), m = read(), rt = read(); for(int i = 1; i &lt; n; i++) { int x = read(), y = read(); add(x, y); add(y, x); } dfs(rt, 0); for(int i = 1; i &lt;= m; i++) { int x = read(), y = read(); printf(\"%d\\n\", LCA(x, y)); } return 0; }","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"LCA","slug":"LCA","permalink":"https://maskros.top/tags/LCA/"}]},{"title":"2022牛客寒假算法基础集训营4","slug":"nowcoder/2022winter/round4","date":"2022-02-08T13:30:50.000Z","updated":"2022-03-02T13:46:31.541Z","comments":true,"path":"/post/nowcoder/2022winter/round4.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round4.html","excerpt":"","text":"2022牛客寒假算法基础集训营4 AC 11 / 12 A R (二分/前缀和) 题意： 给定长为 的字符串 , 给定 , 求字符串中含 ‘R’ 个数大于等于 且不含字符 ‘P’ 的子串个数 思路： 前缀和储存 R 和 P 的个数，枚举左端点，二分查找符合条件的最近右端点长度和最远右端点，作差即为贡献值。 int n, k; char s[maxn]; int R[maxn], P[maxn]; bool checkR(int l, int r) { int cnt_R = R[r] - R[l - 1]; if(cnt_R &gt;= k) return 1; else return 0; } bool checkP(int l, int r) { int cnt_P = P[r] - P[l - 1]; if(cnt_P == 0) return 1; else return 0; } void solve() { cin &gt;&gt; n &gt;&gt; k; R[0] = 0, P[0] = 0; rep(i, 1, n + 1) { cin &gt;&gt; s[i]; R[i] = R[i - 1], P[i] = P[i - 1]; if(s[i] == 'R') R[i]++; eif(s[i] == 'P') P[i]++; } ll ans = 0; rep(i, 1, n + 1) { int l = i, r = n; int rmx = 0, lmn = 0; while(l &lt;= r) { int mid = (l + r) / 2; if(checkP(i, mid)) { rmx = mid; l = mid + 1; } else r = mid - 1; } if(rmx == 0) continue; l = i, r = rmx; while(l &lt;= r) { int mid = (l + r) / 2; if(checkR(i, mid)) { lmn = mid; r = mid - 1; } else l = mid + 1; } if(lmn == 0) continue; int len = rmx - lmn + 1; ans += len; } cout &lt;&lt; ans &lt;&lt; '\\n'; } *B 进制 (线段树) 题意： 长度为 的字符串 (only include ‘0’ ~ ‘9’)，有 次以下两种操作： 输入 1 x y, 修改第 个字符为 ，即 输出 2 x y, 代表查询区间 [, ]，该区间子串能表示的某进制的最小值 (二进制到十进制之间)，对 1e9 + 7 取模 思路： 区间最大数字为 ​ 则对应 ​ 进制即为所求，用线段树维护区间最大值，同时维护在 2 ~ 10 进制下每个区间的值。 一个区间的值 = 左区间的值 * pow(进制, 右区间长度) * 右区间的值 int n, q; int s[maxn]; ll qpow(ll a, ll b) { ll res = 1; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; } return res; } struct SegTree { int l, r; ll a[15]; int m; }tree[maxn &lt;&lt; 2]; void build(int u, int l, int r) { if(l == r) { tree[u].l = tree[u].r = l; int tmp = s[l]; tree[u].m = tmp; rep(i, max(2, tmp + 1), 11) { tree[u].a[i] = tmp; } } else { int mid = l + r &gt;&gt; 1; build(u * 2, l, mid); build(u * 2 + 1, mid + 1, r); tree[u].m = max(tree[u * 2].m, tree[u * 2 + 1].m); rep(i, max(2, tree[u].m + 1), 11) { tree[u].a[i] = (tree[u * 2].a[i] * qpow(i, r - mid) % mod + tree[u * 2 + 1].a[i]) % mod; } } } void update(int u, int l, int r, int x, int y) { if(l == r) { tree[u].m = y; rep(i, max(2, y + 1), 11) { tree[u].a[i] = y; } } else { int mid = l + r &gt;&gt; 1; if(x &lt;= mid) update(u * 2, l, mid, x, y); else update(u * 2 + 1, mid + 1, r, x, y); tree[u].m = max(tree[u * 2].m, tree[u * 2 + 1].m); rep(i, max(2, tree[u].m + 1), 11) { tree[u].a[i] = (tree[u * 2].a[i] * qpow(i, r - mid) % mod + tree[u * 2 + 1].a[i]) % mod; } } } int querymax(int u, int l, int r, int x, int y) { if(x &lt;= l &amp;&amp; r &lt;= y) return tree[u].m; int mid = l + r &gt;&gt; 1; if(y &lt;= mid) return querymax(u * 2, l, mid, x, y); eif(x &gt; mid) return querymax(u * 2 + 1, mid + 1, r, x, y); else return max(querymax(u * 2, l, mid, x, y), querymax(u * 2 + 1, mid + 1, r, x, y)); } ll query(int u, int l, int r, int x, int y, int z) { if(x &lt;= l &amp;&amp; r &lt;= y) return tree[u].a[z]; int mid = l + r &gt;&gt; 1; if(y &lt;= mid) return query(u * 2, l, mid, x, y, z); eif(x &gt; mid) return query(u * 2 + 1, mid + 1, r, x, y, z); else return (query(u * 2, l, mid, x, mid, z) * qpow(z, y - mid) % mod + query(u * 2 + 1, mid + 1, r, mid + 1, y, z)) % mod; } void solve() { cin &gt;&gt; n &gt;&gt; q; rep(i, 1, n + 1) { char t; cin &gt;&gt; t; s[i] = t - '0'; } build(1, 1, n); rep(i, 0, q) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if(op == 1) update(1, 1, n, x, y); else { int z = querymax(1, 1, n, x, y); cout &lt;&lt; query(1, 1, n, x, y, z + 1) &lt;&lt; '\\n'; } } } C 蓝彗星 (差分) 题意： 输入 , 表示彗星的数量和每个彗星的持续时间，输出一个长 的只有 ‘B’ 和 ‘R’ 组成的字符串，表示彗星颜色，B为蓝色R为红色。 输入 个整数 ，表示每颗彗星的开始时刻，求能看到蓝彗星且看不到红彗星的总秒数。 1 &lt;= &lt;= 1e5 思路： 维护两个差分数组表示蓝彗星和红彗星的持续时间，按时间顺序开始遍历，分别计算两个数组的前缀和来看当前时间是否符合条件，符合则计数。 #define N 100005 char s[N]; int a[N], red[2 * N], blue[2 * N]; void solve(){ int n, t; cin &gt;&gt; n &gt;&gt; t; rep(i, 1, n + 1) { cin &gt;&gt; s[i]; } rep(i, 1, n + 1) { cin &gt;&gt; a[i]; if(s[i] == 'B') blue[a[i]]++, blue[a[i] + t]--; else red[a[i]]++, red[a[i] + t]--; } int ans = 0; int redcnt = 0, bluecnt = 0; rep(i, 1, 2 * N) { redcnt += red[i]; bluecnt += blue[i]; if(bluecnt &amp;&amp; !redcnt) ans++; } cout &lt;&lt; ans &lt;&lt; '\\n'; } D 雪色光晕 (二维几何) 计算点到线段的最短距离，套板子 //square of a double inline double sqr(double x){return x*x;} int sgn(double x){ if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1; } struct Point{ double x,y; Point(){} Point(double _x,double _y){ x = _x; y = _y; } bool operator==(Point b) const { return sgn(x - b.x) == 0 &amp;&amp; sgn(y - b.y) == 0; } bool operator&lt;(Point b) const { return sgn(x - b.x) == 0 ? sgn(y - b.y) &lt; 0 : x &lt; b.x; } Point operator-(const Point&amp; b) const { return Point(x - b.x, y - b.y); } //叉积 double operator^(const Point&amp; b) const { return x * b.y - y * b.x; } //点积 double operator*(const Point&amp; b) const { return x * b.x + y * b.y; } //返回长度 double len() { return hypot(x, y); //库函数 } //返回长度的平方 double len2() { return x * x + y * y; } //返回两点的距离 double distance(Point p) { return hypot(x - p.x, y - p.y); } }; struct Line{ Point s,e; Line(){} Line(Point _s,Point _e){ s = _s; e = _e; } //求线段长度 double length() { return s.distance(e); } //点到直线的距离 double dispointtoline(Point p) { return fabs((p - s) ^ (e - s)) / length(); } //点到线段的距离 double dispointtoseg(Point p) { if (sgn((p - s) * (e - s)) &lt; 0 || sgn((p - e) * (s - e)) &lt; 0) return min(p.distance(s), p.distance(e)); return dispointtoline(p); } }; void solve() { int n; double x0,y0,x,y; cin&gt;&gt;n&gt;&gt;x0&gt;&gt;y0&gt;&gt;x&gt;&gt;y; Point p0=Point(x,y),p=Point(x0,y0); double dis=p0.distance(p); double xx,yy; rep(i,0,n){ cin&gt;&gt;xx&gt;&gt;yy; Point p1=Point(x0+xx,y0+yy); Line l1=Line(p,p1); dis=min(l1.dispointtoseg(p0),dis); x0+=xx; y0+=yy; p=Point(x0,y0); } printf(\"%.8lf\",dis); } G 子序列权值乘积 (快速幂/欧拉降幂) 题意： 小红定义一个数组的权值为该数组的最大值乘以最小值。例如数组 [4,1,3] 的权值是 41=4。小红拿到了一个数组。她想知道，这个数组的所有 *非空子序列 的权值的乘积是多少？由于该数过大，请对 1e9+7 取模。 子序列的定理：对于一个数组，删除其中某些数之后（也可以不删）得到的数组。子序列中的数的相对顺序必须和原数组中的顺序相同 exp: 数组 [1,3,2] 的非空子序列有 [1] [3] [2] [1,3] [1,2] [3,2] [1,3,2] 共7个。 思路： 先排序，随后遍历数组，从当前位置与后面所有序列组成的序列的最小值都是他，与前面所有序列组成的序列的最大值都是他，用快速幂计算贡献即可，注意指数部分取模要采用欧拉降幂，即 % mod - 1 计算贡献：qpow(a[i], qpow(2, n - i, mod - 1), mod) % mod * qpow(a[i], qpow(2, i - 1, mod - 1), mod); int n, a[maxn]; ll qpow(ll a, ll b, ll _mod) { ll ans = 1; while (b) { if (b &amp; 1) ans = ans * a % _mod; a = a * a % _mod; b &gt;&gt;= 1; } return ans; } void solve() { cin &gt;&gt; n; rep(i, 1, n + 1) { cin &gt;&gt; a[i]; } sort(a + 1, a + n + 1); ll ans = 1; rep(i, 1, n + 1) { ans = ans * qpow(a[i], qpow(2, n - i, mod - 1), mod) % mod * qpow(a[i], qpow(2, i - 1, mod - 1), mod) % mod; } cout &lt;&lt; ans &lt;&lt; '\\n'; } I 爆炸的符卡洋洋洒洒 (dp) 题意： 小红正在研究如何把符卡组合出尽可能大威力的组合魔法。 小红共有 ​ 种符卡可以选择，每种符卡最多只能选择一次，每个符卡的魔力消耗为 ​，威力为 ​。如果将多个符卡进行组合，则可以发动一个组合魔法。组合魔法的魔力消耗为选择的符卡的魔力消耗的总和，其威力为选择的符卡的威力的总和。小红必须保证最终符卡的魔力消耗总和为 ​​ 的倍数。小红想知道，自己能发动的组合魔法最大的威力是多少？, &lt; 1e3; , &lt; 1e9 思路： 01背包，dp[i][j] 表示为前 i 张卡魔力消耗模 k 为 j 的符卡威力的最大值。 int a[1005], b[1005]; ll dp[1005][1005]; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 1, n + 1) { cin &gt;&gt; a[i] &gt;&gt; b[i]; a[i] %= k; } rep(i, 1, n + 1) { dp[i][a[i]] = b[i]; rep(j, 0, k) { dp[i][j] = max(dp[i - 1][j], dp[i][j]); if(dp[i - 1][(j - a[i] + k) % k]) dp[i][j] = max(dp[i][j], dp[i - 1][(j - a[i] + k) % k] + b[i]); } } if(dp[n][0]) cout &lt;&lt; dp[n][0]; else cout &lt;&lt; -1; } J 区间合数的最小公倍数 (数学) 题意： 求区间 中所有合数的最小公倍数对 1e9 + 7 取模, , &lt; 3e5 思路： 预处理所有的素数，根据唯一分解定理可知所有的合数可以分解成素数的幂的乘积，求最小公倍数 lcm 只需要维护一个map，对每个素因子取最高次幂即可，快速幂计算最小公倍数。 ll qpow(int a, int b) { ll ans = 1; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) ans = ans * a % mod; a = a * a % mod; } return ans; } vector&lt;int&gt; prime; bool notprime[maxn]; void getprime() { notprime[1] = 1; rep(i, 2, maxn) { if(!notprime[i]) { prime.pb(i); for(int j = i * i; j &lt;= maxn; j += i) notprime[j] = 1; } } } map&lt;int, int&gt; mp; void solve() { int l, r; cin &gt;&gt; l &gt;&gt; r; ll ans = 1; getprime(); rep(i, l, r + 1) { if(!notprime[i]) continue; int tmp = i; for(auto x : prime) { int cnt = 0; while(tmp % x == 0) { tmp /= x; cnt++; } mp[x] = max(mp[x], cnt); if(tmp == 1) break; } } for(auto &amp;it : mp) { ans = ans * qpow(it.fst, it.sec) % mod; } if(ans == 1) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; ans &lt;&lt; '\\n'; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"线段树","slug":"线段树","permalink":"https://maskros.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"欧拉降幂","slug":"欧拉降幂","permalink":"https://maskros.top/tags/%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/"}]},{"title":"Codeforces Round 770 (Div.2)","slug":"codeforces/cf 770","date":"2022-02-08T10:30:00.000Z","updated":"2022-02-15T11:14:34.482Z","comments":true,"path":"/post/codeforces/cf 770.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20770.html","excerpt":"Codeforces Round 770 (Div.2)","text":"Codeforces Round #770 (Div.2) 被交互题干碎，hack真好玩 A_Reverse_and_Concatenate 水题 void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; string s, ss; cin &gt;&gt; s; ss = s; reverse(s.begin(), s.end()); if (ss == s || k == 0) cout &lt;&lt; 1 &lt;&lt; \"\\n\"; else cout &lt;&lt; 2 &lt;&lt; \"\\n\"; } B_Fortune_Telling (xor) 题意： 给定一个 数组，可以对一个非负整数 遍历数组 (从 1 到 n) 做如下操作: 或者 。 Alice 从 开始，Bob 从 开始，已知输入数据一定合法，询问 Alice 和 Bob 谁能遍历数组后得到 思路： 重要性质： 和 的奇偶性不会改变 根据题意， 和 的奇偶性固然不同，遍历判断奇偶性即可。 void solve() { ll n, x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; x = x &amp; 1 ? 1 : 0; rep (i, 0, n){ int t; cin &gt;&gt; t; x = (x + t) &amp; 1 ? 1 : 0; } if ((x &amp; 1) == (y &amp; 1)) puts(\"Alice\"); else puts(\"Bob\"); } C_OKEA (构造) 题意： 给定 , ，构造这样一个从 到 的矩阵，要求每行的相邻 个数的和要被 整除，不能构造输出 NO，否则输出 YES 和构造方案。 思路：嗯构造，注意一下为NO的条件为 (n * k) % (2 * k) != 0 &amp;&amp; k != 1 即可 void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; if((n * k) % (2 * k) &amp;&amp; k != 1) { puts(\"NO\"); return ;} puts(\"YES\"); rep(i, 1, n + 1){ rep(j, 0, k){ cout &lt;&lt; i + j * n &lt;&lt; \" \"; } en; } } D_Finding_Zero 题意： 交互题, 待补 这场因为交互题卡的人还挺多，结果去hack了别人的A，hack的挺爽，上了一波小分","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"牛客2022年除夕AK场- E 春联(博弈)","slug":"probs/春联sg","date":"2022-02-04T15:30:50.000Z","updated":"2022-02-15T10:12:21.826Z","comments":true,"path":"/post/probs/春联sg.html","link":"","permalink":"https://maskros.top/post/probs/%E6%98%A5%E8%81%94sg.html","excerpt":"","text":"牛客2022年除夕AK场- E 春联(博弈) link 题面小红和紫准备玩一个游戏。她们拿到了一个只包含小写字母的字符串 。两人轮流将一个小写字母添加到一个新串 的结尾，必须保证t时刻都是 的一个子序列。谁先无法操作则输掉游戏。 初始是一个空串。小红先手添加，假设两人都足够聪明，请问谁最终能获得胜利？ 子序列 Def‘：若一个字符串 删除部分字符（也可以不删）后得到字符串 ，那么称 是 的子序列。 如果小红获得胜利，则输出 “kou”，否则输出 “yukari” 题解首先，最后一个字母是必胜位置，那么与最后一个字母相同的位置到最后一个字母之间都是必败区间，因为在这中间选，那么接下来对手至需要选最后一个字母即可获胜。 那么，就会形成 , 代表必败区间， 代表必胜区间 那么考虑由必胜作为第一个点，那么小红只需要先手在第一个位置，那么就会将对手逼入必败 不完整的必败区间作为开头，小红也可以选择第一个必胜点，转为情况1 只有当完整的必败区间（找到了与之后第一个必败区间相同的字母）作为开头，那么这时候小红只能在必败区间选取，则无法取胜 🐴void solve(){ string s; cin&gt;&gt;s; int i,j=s.length()-1; for(i=j-1;i&gt;=0;i--){ if(s[i]==s[j])j=i-1,i=j; } if(j==-1) puts(\"yukari\"); else puts(\"kou\"); } 如果要求每次添加的时候t都是s的子串，解法是后缀自动机next指针dag图上求sg函数 &gt;~&lt;","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"博弈","slug":"博弈","permalink":"https://maskros.top/tags/%E5%8D%9A%E5%BC%88/"}]},{"title":"2022牛客寒假算法基础集训营3","slug":"nowcoder/2022winter/round3","date":"2022-02-03T13:30:50.000Z","updated":"2022-02-24T06:41:19.480Z","comments":true,"path":"/post/nowcoder/2022winter/round3.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round3.html","excerpt":"","text":"2022牛客寒假算法基础集训营3 AC 7 / 12 越打越菜 B 智乃买瓜 (背包) 题意： 智乃来到水果摊前买瓜，水果摊上贩卖着 个不同的西瓜，第 个西瓜的重量为 。智乃对于每个瓜都可以选择买一个整瓜或者把瓜劈开买半个瓜，半个瓜的重量为 。保证所有瓜的重量都是一个正偶数。如果他想要购买西瓜的重量和分别为 时，有多少种购买西瓜的方案，答案对1e9+7取模 题解： 分组背包，每个瓜有三种决策：买一个/半个/不买， 表示前 个瓜，重量为 的方案数，故可列出转移方程： // dp[1005][2005] int dp[1005][2005]; int w[1005]; void solve() { int N, M; cin &gt;&gt; N &gt;&gt; M; rep(i, 1, N + 1) cin &gt;&gt; w[i]; rep(i, 1, N + 1) { dp[i][w[i]]++; dp[i][w[i] / 2]++; rep(j, 1, M + 1) { dp[i][j] += dp[i - 1][j]; if(j - w[i] &gt;= 0) dp[i][j] = (dp[i - 1][j - w[i]] + dp[i][j]) % mod; if(j - w[i] / 2 &gt;= 0) dp[i][j] = (dp[i - 1][j - w[i]/2] + dp[i][j]) % mod; } } rep(i, 1, M + 1) { cout &lt;&lt; dp[N][i] &lt;&lt; ' '; } } // dp[2005] another version int dp[2005]; int w[1005]; void solve() { int N, M; cin &gt;&gt; N &gt;&gt; M; rep(i, 1, N + 1) cin &gt;&gt; w[i]; rep(i, 1, N + 1) { red(j, M + 1, 1) { if(j - w[i] &gt;= 0) dp[j] = (dp[j - w[i]] + dp[j]) % mod; if(j - w[i] / 2 &gt;= 0) dp[j] = (dp[j - w[i] / 2] + dp[j]) % mod; } dp[w[i]]++; dp[w[i] / 2]++; } rep(i, 1, M + 1) { cout &lt;&lt; dp[i] &lt;&lt; ' '; } } *C 智乃买瓜 v2 (dp) 题意： B题的反转，给定质量从 到 的买瓜方案数，让你还原西瓜的个数和质量。 思路： 首先容易知道 的个数是确定的。不放倒着考虑，在B题中dp[i, j]的方案数是怎么得到的，这里就怎么减去。思路就是在把一个个dp方案数变为 ​ 的过程中不断将使用的重量放到答案vector中。从前往后遍历dp数组，如果一个位置的值不为0，说明这些剩下的这个重量i对应的方案数只能由 i*2 这个西瓜/2来提供。此时就把一个i*2放入ans，然后更新后面的dp数组部分 TIPS: i==j 时就是处理 dp[i]，剩下的方案数由dp[i]个i*2的瓜提供，因此dp[0]要设置为1，即每次都要减1。 int dp[2005]; vector&lt;int&gt; w; void solve() { int M; cin &gt;&gt; M; rep(i, 1, M + 1) cin &gt;&gt; dp[i]; dp[0] = 1; // important rep(i, 1, M + 1) { while(dp[i]) { w.pb(2 * i); rep(j, i, M + 1) { dp[j] = (dp[j] - dp[j - i] + mod) % mod; if(j - 2 * i &gt;= 0) dp[j] = (dp[j] - dp[j - i * 2] + mod) % mod; } } } cout &lt;&lt; w.size() &lt;&lt; \"\\n\"; for (auto v : w) cout &lt;&lt; v &lt;&lt; ' '; } D 智乃的01串打乱 水题 void solve() { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; rep(i, 1, s.size()){ if(s[i] != s[0]) { swap(s[0], s[i]); break;} } cout &lt;&lt; s; } E 智乃的数字积木 ezv 贪心暴力即可 int n, m, k; char s[100005]; int a[100005]; ll cal() { ll ret = s[0] - '0'; rep(i, 1, n) { ret = (ret * 10 + s[i] - '0') % mod; } return ret; } void op() { int idx = 0; rep(i, 1, n) { if (a[i] != a[idx]) { sort(s + idx, s + i, greater&lt;char&gt;() ); idx = i; } } sort(s + idx, s + n, greater&lt;char&gt;() ); cout &lt;&lt; cal() &lt;&lt; '\\n'; } void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s; a[0] = 0; rep(i, 0, n) cin &gt;&gt; a[i]; op(); rep(i, 0, k) { int x, y; cin &gt;&gt; x &gt;&gt; y; rep(i, 0, n) { if(a[i] == x) a[i] = y; } op(); } } G 智乃的树旋转 ezv 简单的树的性质 int fa[1005]; void solve() { int n; cin &gt;&gt; n; rep(i, 1, n + 1) fa[i] = i; int x1, x2; rep(i, 1, n + 1) { cin &gt;&gt; x1 &gt;&gt; x2; if (x1) fa[x1] = i; if (x2) fa[x2] = i; } int ans = 0; rep(i, 1, n + 1) { cin &gt;&gt; x1 &gt;&gt; x2; if (x1 &amp;&amp; fa[i] == x1) ans = x1; if (x2 &amp;&amp; fa[i] == x2) ans = x2; } if(ans) cout &lt;&lt; 1 &lt;&lt; '\\n' &lt;&lt; ans; else cout &lt;&lt; 0; } I 智乃的密码 (二分/前缀和) 题意： 密码是仅包含大小写英文字母、数字、特殊符号的字符串；密码的长度不少于 个字符，并且不多于 个字符。密码中应该至少包括①大写英文字母、②小写英文字母、③数字、④特殊符号这四类字符中的三种。 现在智乃有一个长度大小为 的字符串 ，她想知道 ​ 串中有多少个子串是一个符合条件的密码，请你帮助智乃统计符合条件的密码数目 思路： 前缀和处理字符串，遍历枚举左端点，二分找符合条件最近距离的右端点，计算贡献值。 int n, l, r; char s[100005]; int pre[100005][5]; bool check(int ll, int rr) { int checksum = min(pre[rr][0] - pre[ll - 1][0], 1) + min(pre[rr][1] - pre[ll - 1][1], 1) + min(pre[rr][2] - pre[ll - 1][2], 1) + min(pre[rr][3] - pre[ll - 1][3], 1); if(checksum &gt;= 3) return 1; return 0; } void solve() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; rep(i, 1, n + 1) cin &gt;&gt; s[i]; pre[0][0] = pre[0][1] = pre[0][2] = pre[0][3] = 0; rep(i, 1, n + 1) { rep(j, 0, 4) pre[i][j] = pre[i - 1][j]; if(s[i] &lt;= '9' &amp;&amp; s[i] &gt;= '0') pre[i][0]++; eif(s[i] &lt;= 'Z' &amp;&amp; s[i] &gt;= 'A') pre[i][1]++; eif(s[i] &lt;= 'z' &amp;&amp; s[i] &gt;= 'a') pre[i][2]++; else pre[i][3]++; } ll ans = 0; rep(i, 1, n + 1) { if(i + l - 1 &gt; n) break; int mnpos = 0; int L = l - 1, R = min(r - 1, n - i); while(L &lt;= R) { int mid = (L + R) / 2; if(check(i, i + mid)) { R = mid - 1; mnpos = min(r - 1, n - i) - mid + 1; }else L = mid + 1; } ans += mnpos; } cout &lt;&lt; ans &lt;&lt; '\\n'; } J 智乃的C语言模除方程 (分类讨论) 题意： 模除是一种不具交换性的二元运算。模除（又称模数、取模操作、取模运算等，英语： 或 。得到的是一个数除以另一个数的余数，给定两个正整数：被除数 和除数 ，得到的是使用欧几里德除法时 的余数。而当 和 出现负数时，通常的定义就不适用了，c/c++语言中，当被除数 或者 出现负数时，运算的过程中首先将 和 作为非负整数进行运算，然后得出结果时符号与被除数 保持一致。举个例子，比如 而 。 现在智乃有一个模除方程： ， 其中 为未知数, 为给定常数, 可为区间 内的任意整数，运算遵循c/c++中模除运算的运算法则。 显然这个方程的解并不为一，所以智乃现在给你划定了一个整数答案区间 ，询问答案区间 内有多少符合条件的整数 能使得等式 ​ 成立。 思路：分类讨论 #include &lt;bits/stdc++.h&gt; using namespace std; int P, l, r, L, R; typedef long long ll; ll ans; ll calc(ll a, ll b, ll c, ll d) { //计算符合条件的区间长 if (b &lt; c || d &lt; a) return 0ll; ll r = min(b, d), l = max(a, c); return r - l + 1; } ll query(ll u) { //[0,u]中符合条件的个数 // u/p份 每份所在总区间为[0,P-1] // u%p 余数为[1,u%p] 0%p=0 总区间[0,p] if (u &gt;= 0) return 1ll * (u / P) * calc(0, P - 1, l, r) + 1ll * calc(0, u % P, l, r); else return 1ll * abs(u) / P * calc(1 - P, 0, l, r) + 1ll * calc(u % P, 0, l, r); } int main() { cin &gt;&gt; P &gt;&gt; l &gt;&gt; r &gt;&gt; L &gt;&gt; R; P = abs(P); if (L &gt;= 0 &amp;&amp; R &gt;= 0) ans = query(R) - query(L - 1); else if (L &lt;= 0 &amp;&amp; R &gt;= 0) ans = query(R) + query(L) - query(0); else ans = query(L) - query(R + 1); cout &lt;&lt; ans &lt;&lt; endl; return 0; } L 智乃的数据库 (模拟) 题意： 模拟SQL语句: SELECT COUNT(*) FROM Table GROUP BY ...; 思路： 模拟即可，注意细心不要写错 int N, M; map&lt;string, int&gt; mp; vector&lt;int&gt; order; struct node { int data[maxn]; } a[maxn]; bool cmp(node x, node y){ rep(i, 0, order.size()) { int idx = order[i]; if(x.data[idx] == y.data[idx]) continue; else return x.data[idx] &lt; y.data[idx]; } return x.data[0] &lt; y.data[0]; } void solve() { cin &gt;&gt; N &gt;&gt; M; string s; rep(i, 0, M) { cin &gt;&gt; s; mp[s] = i;} rep(i, 0, N) { rep(j, 0, M) { cin &gt;&gt; a[i].data[j]; } } rep(i, 0, 7) cin &gt;&gt; s; int bg = 0; rep(i, 0, s.size()) { if(s[i] == ',' || s[i] == ';') { string key = s.substr(bg, i - bg); bg = i + 1; order.pb(mp[key]); } } sort(a, a + N, cmp); int cnt = 1; vector&lt;int&gt; ret; rep(i, 1, N) { rep(j, 0, order.size()) { int idx = order[j]; if(a[i].data[idx] != a[i - 1].data[idx]) { ret.pb(cnt); cnt = 0; break; } } cnt++; } ret.pb(cnt); cout &lt;&lt; ret.size() &lt;&lt; '\\n'; for (auto x : ret) cout &lt;&lt; x &lt;&lt; ' '; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"}]},{"title":"Codeforces Round 769 (Div.2)","slug":"codeforces/cf 769","date":"2022-02-02T10:30:00.000Z","updated":"2022-02-14T11:50:34.731Z","comments":true,"path":"/post/codeforces/cf 769.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20769.html","excerpt":"Codeforces Round 769 (Div.2)","text":"Codeforces Round #769 (Div.2) virtual participant A_ABC 水题 void solve() { int t; cin&gt;&gt;t; string s; cin&gt;&gt;s; if(t&gt;=3){puts(\"NO\");} else{ if(t==1) puts(\"YES\"); eif(t==2&amp;&amp;s[0]==s[1]) puts(\"NO\"); else puts(\"YES\"); } } B_Fun_with_Even_Subarrays (构造/xor) 题意： 从 ~ 代表 个连续柱子的高度，现在需要构造一个排列，构建的成本为相邻柱子异或的最大值，即 ，现在要使成本最小。 思路： 无论如何异或的最大值都由最高位决定，注意把他和低位的全1数错开即可 void solve() { int n; cin&gt;&gt;n; int mx; rep(i,1,20){ int p=pow(2,i); if(p==n-1) {mx=p; break;} eif(p&gt;n-1) {mx=pow(2,i-1); break;} } rep(i,1,mx) cout&lt;&lt;i&lt;&lt;\" \"; cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;mx&lt;&lt;\" \"; rep(i,mx+1,n) cout&lt;&lt;i&lt;&lt;\" \"; en; } C_Strange_Test (or) 题意： 给定 和 (a&lt;b)，可以做任意次操作： ​ 询问至少需要多少次操作才能使 ? 思路： 由于or操作的性质， 一定大于 和 ，故或操作最多执行一次。所以只需判断是先 自加再 or 还是先 自加再 or 即可。 // 只可能先a++再or，或者先b++再or void solve() { int a, b; cin &gt;&gt; a &gt;&gt; b; int x = a, y = b; int ans1 = 1, ans2 = 1; while((x|y) != y &amp;&amp; x &lt;= y) x++, ans1++; if(x == y) ans1--; while((a|b) != b) b++, ans2++; cout &lt;&lt; min(ans1, ans2) &lt;&lt; \"\\n\"; } D_New_Year_Concert (ST表/二分) 题意： 个学校从 到 编号，第 个班级准备了时长为 的节目，对于前 个节目，如果存在 , () 且 ，观众就会感觉无聊，为了避免这种情况，你可以修改任意节目的时长为任意正整数。 规定 为前 个节目需要修改的最小次数，打印 思路： 注意到，a个数的GCD一定不小于a+1个数的GCD，因此其具有单调性（满足二分条件）。且每次操作的那个数可以替换为任意值，那么就可以取一个大素数。且f值具有承袭性。那么考虑这样一个做法： 遍历1到n，设当前为i，lst为上一次进行操作的位置+1。如果当前a[i] = 1，必然要进行更改；否则基于上面提到的n个数GCD的性质，二分找[lst, i]这段区间是否存在某个字区间[x, i]满足。如果有的话则让 ，同时 更新为 ；如果没有则让 即可，二分check使用ST表查询区间GCD。 #include&lt;bits/stdc++.h&gt; using namespace std; int a[200009], st[200009][30]; int gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b); } int query(int l, int r) { int k = log2(r - l + 1); return gcd(st[l][k], st[r-(1&lt;&lt;k)+1][k]); } int main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); st[i][0] = a[i]; } for(int j = 1; j &lt;= 20; j++) { for(int i = 1; i &lt;= n; i++) { if(i + (1 &lt;&lt; j) - 1 &gt; n) continue; st[i][j] = gcd(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]); } } int pos = 1, ans = 0; for(int i = 1; i &lt;= n; i++) { int l = pos, r = i; while(l &lt; r) { int mid = (l + r) / 2; if(query(mid, i) &gt;= i - mid + 1) r = mid; else l = mid + 1; } if(query(l, i) == i - l + 1) { ans++; pos = i + 1; } printf(\"%d \", ans); } cout &lt;&lt; endl; return 0; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"ST表","slug":"ST表","permalink":"https://maskros.top/tags/ST%E8%A1%A8/"}]},{"title":"记念二〇二一","slug":"life/Summary_2021","date":"2022-02-01T15:50:00.000Z","updated":"2022-02-01T16:07:08.837Z","comments":true,"path":"/post/life/Summary_2021.html","link":"","permalink":"https://maskros.top/post/life/Summary_2021.html","excerpt":"","text":"记念二〇二一 以下 Q&amp;A： Q：为什么是“记念”？ A：这个词对于我来说最早出自高中学过的一篇课文，鲁迅的《记念刘和珍君》，关于这一篇为啥我记得比较清楚，这里按下不表。当时就在想为什么是“记念”而非“纪念”，然后查了查，我觉得最靠谱的理由就是他写这篇文章的时候文白混杂、简繁混用才写的“记念”。什么诸如细细品味在《线代汉语词典》中词性和用法的微微差异，我觉得这种瞎JB猜的都是扯淡。但是说回正题，我在这里为什么要用”记念“呢，就是因为想用了。 Q：为什么大年初一才发年终总结，而不是1月1号？ A：这个有很多原因。我还是更倾向于1月1号代表新的一年，日历也得换本新的，虽然👴🏻不用台历。那天晚上想写来着又因为感觉有些作业没处理，比较忙，就没写。实际情况是当天晚上摆了，啥正事没干，过了那天又觉得写有没啥意思，就拖下来了。总结：摆了，没来得及写。 OK，接下来进入正题。 本文贯彻总-分-总的行文结构，以下叙事按时间轴进行，无图（其实图挺多的要放图也行但是懒得放），最后来个总结，over. （以下为目录，如果你是PC的话右边儿👉🏻也有、排版部分借鉴了coin哥哥🥰的风格） 一月 一些新鲜事 生日 考试周 二月 MCM[1] 春晚 三月 四月 蓝莲花 Take On me The Dawn 1丶惊喜 五月 败走银川 摇滚之夜 六月 山东大学“六月的风” Livehouse 欧洲杯 考试月 七月 体验生活 NBA Final 训练 八月 东京奥运 👩’s Birthday CR7 九月 Web框架编程 国赛 藏书票 十月 👋，旧手机 Vlog👶🏻横空出世 十一月 EDG 海超[2] 败走上海 十二月 CCSP 软件工程 总结 迷茫 轮廓 展望 一月 近年的一月都如此般经典，不过今年新鲜一点 一些新鲜事来自bilibili年终报告：吟游大司人可能是你今年最喜欢的UP主，你一共看了TA的视频 718 次，这或许证明了我对金轮的爱，但是也侧面证明了把很多时间浪费到了短视频上。 来自👩[1]：不同以往的是，我在2020年底因为诸多因素收获了一个👩，所以给朴素的一月增添了许多活力。 [1]👩: 指👩 生日 2021/1/10 每年一趟的生日如期而至，有了👩的我在👩的带领下出去恰饭，由于有👩之前我一向是不咋离校的，一是因为没啥人和我出去，自己出去也没啥意思；二是出去要么就经典石老人，这个我不好评价；所以不得不评价出去恰饭的感觉还挺嗨的。 考试周一如既往的考试周，今年我换了策略，在熟练运用markdown技术后我心血来潮用markdown结合课件开始猛整复习资料，结论是吊用没有。有些cv的东西你cv了也没啥印象，打印了之后排版大量的空余也让我懒得翻页，所以不出意外的考寄了，让疫情给高分后重新带给我的信心又瓦了[2]。 [2] 瓦了：指无了 二月 今年的寒假比往年的寒假充实一点、、 MCM[1] [1] MCM: The Mathematical Contest in Modeling，指美国大学生数学建模竞赛，又名水赛 往年的寒假对于我来说确实是纯纯的假期，但是总有人利用这段时间偷偷学习。正如山东省实验中学校长，党委书记韩相河在开学典礼上的重要讲话：“不怕同学是学霸，就怕学霸放书架[2] ”，我深感赞同。但是今年心血来潮，决定碰碰运气，于是开始进行建模速成[3]。赛前，我做好了充分的时间规划，假装自己是个高手。 最终赛时在两位👴的带领下按照计划，完成了由(&gt;60%)Google翻译构成的、图文并茂的《论真菌》[4]，通篇看起来极为唬人。当晚按时上交，直接倒头就睡，寒假学习之旅告一段落，实际上学了也没啥用。 [2] 书架：通”暑假“，韩相河校长精通山东某地口音，故其讲话声调抑扬顿挫 [3] 建模速成：指观看Blibili《美赛速成》等培训视频(&lt;=2)；一方面配置SumatraPDF+WinEdt的LaTex论文环境、学习LaTex语法；一方面知乎研读往年O奖论文(&lt;=3)，并深感震撼于笔者出色的排版、绘图和美工技术；一方面观看动画片《喜羊羊与灰太狼之筐出胜利》，太精彩了属于是 [4] 《论真菌》：赛时笔者队伍所选的A题为真菌相关的建模，论文具体标题为《XXXX模型：XXXXXX》，文采藻饰，臭词乱拽，看起来很JB高级实则都是屁话 春晚春晚小品就是个寄，不予评价。 三月 开学，再见👩，动物园之旅，第一次感受海底捞 海底捞确实服务比较嗨，但是那个生日歌尬也是尬 四月 一些演出 蓝莲花Bass康复训练的曲目，没啥难度，全是loop😅，但是好久没上过台了，还是起到了丶热身的作用 Take On me 大艺团合唱团最后的谢幕，只能说有点遗憾吧，几首阿卡到最后也没过一次bass solo 6人的阿卡贝拉，排练了很久的一首快歌，从一开始的进度缓慢、产生的一些争执、再到最终演出时舞台的一些设施原因，整个过程并没有那么顺利，但是也是一次美好的经历，演出的效果也还不错 《Take On Me》 The Dawn仍记得小时候听过亡灵序曲的钢琴版，当时深感震撼，如今复刻了一下也可以说是一种致敬 1丶惊喜Meritorious Winner，一个普通的早上醒来，闲的没事干查了查MCM结果，直接从床上坐了起来 只能说是参赛即退役，但没想到这竟是今年所有竞赛的绝唱😅 五月 至今仍在后悔，悔于自己的废物，但后悔又有什么用呢？ 败走银川 众所周知，ACPC[1]银川站就是个笑话[2]。在2021年之前，银川的牌子是公认含金量最低，也是最好拿牌的赛站，但是👴在这里打铁了 ”金川银川，不如👴的铁川。“ 2021/5/14 青岛的晚上大雨滂沱，我匆匆从打印店打好最后的板子，登上了离开的出租车，与指环王，杰宝[3]踏上了离开的旅程。 由于一大早的飞机，所以我们在机场附近找个了私❤️人❤️影❤️院❤️勉强度过一夜，在那里第一次邂逅了情趣礼盒，三个血气方刚的年轻人表示十分的好奇。然后就是一顿瞎JB吹水，这毕竟是我们带学生涯的第一场现场赛，确实比较激动。 2021/5/15 飞机起飞，降落。 终于来到了一个新的城市，一出机门就能看到冒着红光的枸杞宣传板，城市文化了属于是。 随后就坐上了前往石嘴山(即宁理所在城市)的面包车，一路上的景色并不能算得上是什么景色，听说还有什么沙湖游的安排，比较激动，但是后面给取消了😅，现在搜了一下居然是AAAAA级景区，🐴的，亏了。 中午去学校报道，有两个个小改改[4]带着我们简单参观了一下，不得不说，确实挺大，学校就像在一个小岛上一样，周围被不知道是湖还是河的东西围起来，比较空旷加上风还挺大，所以感觉穿的还有点少，挺冷。后来领了个礼袋，里面除了参赛服就是一盒包装还算可以的枸杞，想了想我也用不上这玩意，正好带回家去。临走的时候看见有广播站的在那里拿着个麦克采访，心血来潮和个楞b一样就上去了，说了几句尬话加了个宁理之声广播站的vx润了。 下午热身赛，四道题全给A了，结果判题机炸了，一直不给判，榜也卡着，然后待了一会就润了，想着回去溜达溜达吃顿好的🤡。 晚上🔒棒子骨，恰羊蝎子，有点辣但属实嗨🤡，随后采购了点本地特产，提了一大兜子回了宾馆，静待第二天的正赛。 2021/5/16 早上满怀ak的斗志去了，坐下凳子，发现昨天热身赛榜上“中国海洋大学 没有显卡能打ACM吗 rk7[5]”，有点激动，随后悄么声地把页面关掉，静静等待比赛开始。 比赛过程不想说了，大量的无用思考，全场最签到的一道题三个人九牛二虎之力读了无数遍都读清楚题意WA[6]32也没过，然后有道题卡了行末空格白WA了6，最后时间走完，都没来得及看字典树的简单题，铁了。 我们达成了了几乎很难达成的银川打铁的成就，灰头土脸地逃回了青岛。 除了自己菜，没什么好说的、距今已260天，警钟长鸣。 [1] ACPC：指ACM-ICPC亚洲区域赛，ACM-ACPC为本场开幕式上发言人的逆天口语表达 [2] 笑话：主办方宁夏理工学院乃我国西部枢纽，如何看待 2021 年 ICPC 银川赛区主办方宁夏理工学院获得一金一银？，有三人三机（比赛中应三人一机），更有沈阳站撤硕过题（如何评价宁夏理工学院TS1队参加ICPC沈阳站，并在上厕所后做出了H题？）, 不好评价 [3] 指环王、杰宝：指两名队友，指环王网名脂环，小名我爹，杰宝取自于真名的尾字 [4] 小改改：值小姐姐 [5] 没有显卡能打ACM吗 rk7：前者指鄙队队名，后者指排名即rank [6] WA：指Wrong Answer，对题目的错误提交，后跟数字表示错误提交的次数 摇滚之夜月末，乐队参加了我校吉他社的摇滚之夜，也算是为下个月的各大演出做了提前的一次彩排，效果不错，在这里不多赘述。 六月 演出月、考试月、欧洲杯 山东大学“六月的风” 2021/06/06 应邀参加山带（青岛）“六月的风”毕业歌会，整了个蓝莲花和 It’s my life，坐了五十分钟地铁终于到了山带，虽然在更偏远的郊区但是不得不说建的真是气派，宿舍条件也比我校好（基本没有比我住的地方烂的），里面整了个三层小商圈，卖的东西应有尽有属实看的眼馋。 这次歌会在一块小足球场举行，草皮也是真好，也可能是新建的但是确实好，比得上省体的那个足球公园刚建好的时候那草皮质量，那些设备确实弄的也挺高级，还有两块投屏，和网上直播显示的画面是同步的。下面也的场地也布置的挺好的，只能说是见了世面，毕竟咱也没来过这种露天的演出😅 演出开始。因为接设备需要时间，所以👴即兴发表了一段演讲，大有两校情谊长存之意，实属全是屁话。但是这段宣言全被直播出去了，实属被当场逮捕，现在搜一下录像看还是觉得很尬😅，演完了领了点饭钱润了。 演出效果还行，就是导播不大懂乐队可能，看别人演加州旅馆吉他solo的时候一直给节奏镜头😅😅😅 Livehouse 2021/06/12 DMC 本来想的是个So Downtown[1]一样的带Livehouse，去了才发现是个小酒吧，但是那个音箱确实蛮好的，现场来了很多很好的朋友，气氛也挺嗨的，感受到了大合唱环节，在台上会进入一种忘我的境界，我很享受。在这个账号上我们发布了当天的录像，再体味一遍还是不错的，这算是今年乐队正式演出的完美谢幕吧。(下半年因为大家的时间赶不到一起去，所以暂时停排) [1] So Downtown：青岛某知名Livehouse 欧洲杯葡萄牙的比赛一场不落的看完，确实场面不太好看，踢德国那场也确实被干碎了，淘汰也是情理之中，没想到的是死亡之组法德葡八强全寄了😅 考试月经历了上次考试的惨痛教训，这次我又恢复了手写提纲的方法，修习了三大数学(即离散数学、线性代数、概率统计)的我最后从结果来看整体差强人意，就是课有点多，有几门摆烂了，复习的很少或者是没复习，果然寄了😅，但是整体而言较于上学期还是有了一定的进步 七月 一些生活碎片 体验生活回家了一阵后在青岛体验生活，如题，不详述。 NBA Final伴随cp3和Suns一路走来，打到总决赛已经非常惊喜，虽然最后不敌，虽然有一些裁判和球员的其他原因，但是还是比较满足的，毕竟不可能有这么一帆风顺的旅程，失败永远是人生的主旋律，重头再来吧。 训练在找到稳定的生活节奏前，按时打了Nowcoder多校的训练赛还有HDU的多校联赛，中间打了两三场百度⭐⭐，最后止步复赛。虽然每次都是一个受到打击的过程，但是这也帮助我更有效的认知自己的水平，但是回头来看，做题不补题相当于白打😅 八月 一些锐评 东京奥运虽然奥运会确实是那种让大家都能乐呵起来的大会，带🔥互相聊聊也是没啥毛病的，但是诸如朋友圈、微博等等社交平台上某些啥都不懂就在那乱评头论足蹭热度的我的评价是纯属啥b、、 👩’s Birthday 2021/08/14 准备了挺久的👩生日如期而至，我只能说我准备的礼物确实是纯纯的别出心裁。 CR7老特拉福德的宠儿重新回到了梦剧场，主队从JUV换到了MNU，虽然热血沸腾，但下半年的曼联似乎是纯纯的🤡。 九月 开学啦、、 Web框架编程让我知道了不少高分低能神人的存在，确实不能理解😅😅，不会又不学就开始当乞丐我真笑嘻了😅 国赛建模国赛，狗都不打。本就不想参加但还是打扰了三天的作息😅😅 藏书票修了一门叫做 大学美术鉴赏 的通识课，里面有一项作业是每周手画一张藏书票，我觉得还蛮有意思的，花上三个小时静心完成一幅作品确实已经很久没干过了，让我找回了小学初中的那种感觉。 十月 旧的不去，新的不来 👋，旧手机 2021/10/10 打了场CCPC网络赛，打完发现旧手机寄了。 这里谈一下我的旧手机，它是高考结束后来到的我的身边。仅仅7天，一次出门在外，追赶公交车的时候，眼见着我就要到公交车门前，发生了以下的默剧： ​ “！！！”（师傅开门，让我上车！） ​ “…” (手指地面) ​ “？？！！” （开门啊？我要上车啊！） ​ “…” ​ “…！” （发现手机倒扣在地上） ​ “！！！” (woc！正面碎烂了！) ​ “…” （公交车驶向远方） 大致的过程就是手机干碎了，公交车也跑了，达成双赢。由于手机是刚买的，问了一下修个屏要五伯，修两三次就够我再买一个了，于是我决定节俭下去不修，这就导致了一些和我共事的人见到我的手机都要啧啧称奇，这一用就是两年。 终于，在这天下午，我发现它的屏幕解锁后，只需要五秒，就会逐渐变黄，再过五秒，整个屏幕就变成了一些明暗交织的条带，如同天上的银河。 于是，我告别了它。 Vlog👶🏻横空出世换了录像设备的我如题，剪了一个还不错的Vlog并且深深陶醉其中。 十一月 憧憬就是用来打破的 EDG 2021/10/07 EDG 3-2 战胜了DK，夺得了s11的冠军。 带着👩去操场感受线下观赛的热血，第一把赢了已经出乎意料，现场气氛来到了高潮，但是二三局的失利又让我有些失去信心，结果EDG居然没让淀粉失望，最终翻盘夺冠。 从s5开始当淀粉[1]，六年了，终于爽了一把，晚上刷了半天新闻才睡，纯嗨。 [1] 淀粉：指EDG的粉丝，EDG又被戏称“中国电竞”，故粉丝群体被称为淀粉即“电粉” 海超[2] [2] 海超：海超，全称“中国海洋大学足球超级联赛” 继刚打一场就胎死腹中的新生杯完成的帽子戏法给予我信心之后，我加入了院队，迎来了海超联赛。 作为从信院租借到管院的球员第一场面对旧主被干了个7-0😅，有点无力又深深忏悔于自己的失误。 紧接着在冷风吹着的小雨中迎来了第二场面对法学院的比赛，这场我改变了一些打法，想通过减少带球来增加一脚出球和无球跑动来扰乱对手的后防线，效果还是有一些的。最终4-2有惊无险，没有收获进球但是有一脚助攻，不过也是浪费了三次近在咫尺的良机，前两次是没有把握准第二点，中场前的一脚抽射也是因为左脚没有站稳导致力道不足，比较遗憾，但是那种享受比赛的过程还是令我热血澎湃，没想到的是在雨里懂了俩小时回去居然没有感冒，彳亍。 败走上海 2021/11/28 ICPC亚洲区预赛上海站，线上赛，就在信院打，最终打铁，没什么好说的，能力不足就是能力不足。 准备了很久的字符串没有派上用场，最终被两道DP[3]卡了，事实证明，做出这两道DP也没有什么用，毕竟上海站已经卷到了五题铜牌，还是需要努力，希望下次不留遗憾吧。 [3] DP：Dynamic Programming，动态规划，一种算法 十二月 急 CCSP参加了CCSP的分赛，最后10分钟过了B题30分，最后拿了个华东赛区rk71铜首[1]，校排第5。 虽然结果确实令我血压升高，这种铜首的事也能轮到我头上😅，但是整体而言对结果已经较为满意，毕竟卡了这么久，没啥毛病，继续努力吧。 [1] 铜首：指铜牌第一名，rk70银但rk71铜 软件工程 永远不要和废物组队。 这门课就像他的名字一样，平时是要进行小组分工完成一个项目作为评分指标，我们的项目是完成对图片的20种目标检测。 鄙组由5名成员组成，实则由两名成员组成，我和阿昊，他来完成模型的训练，我来完成GUI界面，说来也惭愧，我这部分的分工明显简单于他，他为这个项目确实付出了最多。 因为我最熟悉C++，于是就想把用pytorch训练的模型移植到通过 libtorch+opencv+msvc+qt 来实现GUI的编写，结果配了好几天的环境，发现模型部分功能的实现libtorch是不支持的，只能卷土重来。时间流逝，当我重新配好pyqt的环境开始动手编写时，距离考试周已经时日不多。 剩下几位b用没有，一边说着不会，“我也知道，我要是会我肯定干点什么”之类的屁话，一遍p也不学，开始了自己的期末复习。 这令我十分烦躁，我是不是不复习啊，我他吗是不是就是纯雷锋非得做好事啊，最后项目我们俩干了半天，到头来最后一个个的都比我们分高或者和我们一样，凭什么呢，他们配吗？于是就剩一天的时候，我们甩了脸，让他们学着干一些事情，比如配置服务器这种简单的事情。虽然心里想着他们肯定干不完，但是至少也得出点力，于是把任务布置了下去，还抱有一丝念想。结果是：——在一整天的时间，有人配了一个小时没配明白就放弃了，有的人根本没怎么看。 在这个过程中，要么是像巨婴一样问低级问题，要么就是开摆，连搜都懒得搜。不想再做评价了。 最后项目的结果是：我俩完成了分内的工作，但是项目的完成度比目标来说只达成了60%，勉强及格罢。 引用 Eric Steven Raymond 在《提问的智慧》中的话结尾： 我们只是毫无歉意地鄙视那些提问前不愿思考、不做功课的人。这种人就像时间黑洞一样，只知道索取，不愿意付出，他们在浪费我们时间，而这些时间我们本可用于其他更有趣的问题或更值得回答的人身上。我们将这种人叫做 loser。 总结 非常简略的总结 迷茫迷茫于自己的未来，迷茫于自己的当下，迷茫于自己的选择，迷茫于对错。 轮廓我似乎渐渐摸清了不远的未来的轮廓，对自己轮廓的描绘也越来越清晰，跟不同人之间的轮廓的区分。 展望克制，规律的作息，扎实地前进。 很荣幸你能够忍受着我抽象的文字、像怨妇一样的抱怨、和一些难听的诋毁看到这里，谢谢你我的朋友，2022新年快乐。","categories":[{"name":"LIFE","slug":"LIFE","permalink":"https://maskros.top/categories/LIFE/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://maskros.top/tags/Life/"}]},{"title":"Educational Codeforces Round 122 (Div.2)","slug":"codeforces/cf Edu 122","date":"2022-01-31T10:00:00.000Z","updated":"2022-02-15T10:05:03.753Z","comments":true,"path":"/post/codeforces/cf Edu 122.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20122.html","excerpt":"Educational Codeforces Round 122 (Div.2)","text":"Educational Codeforces Round 122 (Rated for Div. 2) vp A_Div_7 签 void solve() { int n; cin &gt;&gt; n; if(n % 7 == 0) cout &lt;&lt; n &lt;&lt; '\\n'; else{ if(n &gt;= 990) cout &lt;&lt; 994 &lt;&lt; '\\n'; else { n -= n%10; while(n % 7 != 0) n++; cout &lt;&lt; n &lt;&lt; '\\n'; } } } B_Minority 签 void solve() { string s; cin &gt;&gt; s; int one = 0, zero = 0, ans = 0; rep(i, 0, s.size()){ if(s[i] == '0') zero ++; else one ++; ans = (one == zero)? ans : min(one, zero); } cout &lt;&lt; ans &lt;&lt; '\\n'; } C_Kill_ the_Monster 枚举k的分配种类即可 ceil(double x) ：double 类型向上取整 void solve() { double hc, dc, hm, dm, k, w, a; cin &gt;&gt; hc &gt;&gt; dc &gt;&gt; hm &gt;&gt; dm &gt;&gt; k &gt;&gt; w &gt;&gt; a; rep(i, 0, k+1){ double hhc = 1.0 * i * a + hc; double ddc = 1.0 * (k - i) * w + dc; if(ceil(hm / ddc) &lt;= ceil(hhc / dm)){ cout &lt;&lt; \"YES\\n\"; return ; } } cout &lt;&lt; \"NO\\n\"; } D_Make_Them_Equal (dp) 题意： 给定一个长为 的数组 ，初值全为 ，你可以做这样的操作：选择 和 (x&gt;0) ，然后使 如果操作后 ，你将得到 的奖金，你需要在 次操作内使得奖金最大化，输出奖金的最大值。规定 , 思路： 从 到 的次数是固定的，根据 的范围，我们可以打表预处理每个数的操作次数，然后考虑01背包，dp[i][j]表示前 i 个耗费为 j 的最大奖金，但是开1e6肯定会T，观察打表结果发现最大值为 12，这样可以优化一下dp的范围。 int b[1005], c[1005]; int pre[1005]; // 1 -&gt; 1000 打表 max = 12 void init() { pre[1] = 0; rep(i, 1, 1001) { rep(j, 1, i + 1) { int tmp = i + i / j; if(tmp &lt;= 1000) pre[tmp] = pre[tmp] ? min(pre[tmp], pre[i] + 1) : pre[i] + 1; } } } int dp[12005]; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 1, n + 1) cin &gt;&gt; b[i], b[i] = pre[b[i]]; rep(i, 1, n + 1) cin &gt;&gt; c[i]; int ans = 0; if(k &gt;= 12 * n) { rep(i, 1, n + 1) ans += c[i]; }else { rep(i, 0, 12 * n) dp[i] = 0; rep (i, 1, n + 1) { red(j, k + 1, 0){ if(j - b[i] &gt;= 0) dp[j] = max(dp[j], dp[j - b[i]] + c[i]); else break; } } ans = dp[k]; } cout &lt;&lt; ans &lt;&lt; \"\\n\"; }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"}]},{"title":"2022牛客寒假算法基础集训营2","slug":"nowcoder/2022winter/round2","date":"2022-01-30T13:30:50.000Z","updated":"2022-02-24T06:40:23.350Z","comments":true,"path":"/post/nowcoder/2022winter/round2.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round2.html","excerpt":"","text":"2022牛客寒假算法基础集训营2 AC 6 / 12 我是纯废物 *A 小沙的炉石(二分/结论) 题意： 小沙当前的手上有n张法术进攻牌，每张牌都会消耗一点法力，造成一点基础伤害，有m张法术回复牌，不需要消耗法力值，每次可以恢复一点法力。小沙一开始有一点法力，法力没有上限。法术进攻牌的伤害值=当前出的是第几张牌。k次询问，每次询问一个血量x，问能否做到伤害刚好等于血量值，即刚好斩杀。 题解：二分是朴素写法，结论也很好证明，证明如下： 首先我们要证明一个点，对于使用攻击牌是一个定值的话，我们的攻击范围是一个区间上的任意的伤害值：当我们的攻击牌使用次数为a，蓝量使用牌为b时，对于a&lt;=b+1，我们的最小攻击一定为攻，回复，攻，回复…..直到用完所以攻击后补全回复。可得等差数列，求和可得 。在最小攻击的基础上，我们可以将任意一个攻击牌的位置和他后面的回复牌的位置交换，使得伤害+1。最后可得最大伤害为：回复，回复…..攻，攻，攻…..最大，可得等差数列 ,求和可得 void solve() { ll n, m, k, x, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; n = min(n, m + 1); for (int i = 0; i &lt; k; i++) { cin &gt;&gt; x; q = sqrt(x); if (q &gt; n) q = n; if (x &lt;= q * (2 * m + q + 1) / 2) puts(\"YES\"); else puts(\"NO\"); } } C 小沙的杀球 水题 void solve() { ll x,a,b; cin&gt;&gt;x&gt;&gt;a&gt;&gt;b; int ans=0; string s; cin&gt;&gt;s; int len=s.length(); rep(i,0,len){ if(s[i]=='0') x+=b; else{ if(x&gt;=a) {x-=a; ans++;} else x+=b; } } cout&lt;&lt;ans; } *E 小沙的长路 (图论/欧拉图) 题意： ​ 阶竞赛图(可以自定义每条边的方向)，每条边只能走一次，询问最长路径的最小值和最大值 题解： 最长路的最小值：。如果图上有环，那么我们肯定能尽可能多的走环，这样的话我一定会比我不走环更长，所以我们构造的图要尽可能的没环。在没环的情况下，我们只会经过每个点各一次，所以总长度是 最长路的最大值： 为奇数： ; 为偶数： 。我们考虑尽可能的将每一条路都走遍，我们可以理解为对一个完全图进行删边，我们需要删尽可能少的边，从而使他能够从头走到尾，也就是构造出一个欧拉回路。又由欧拉回路的定义可知，我们需要将每个点的出入度控制为偶数即可组成欧拉回路，所以奇偶特判即可。 (TIPS: 删去 即为使原图仅有两个奇度顶点构成欧拉图) void solve() { ll n; cin&gt;&gt;n; ll mx,mn; mn=n-1; if(n&amp;1) { mx=(n-1)*n/2; }else{ mx=n*(n-1)/2-(n-2)/2; } cout&lt;&lt;mn&lt;&lt;\" \"&lt;&lt;mx; } F 小沙的算数 (模拟/桶/逆元) 题意：给定仅有+和×的算式，q次询问，每次将第x个算数变为y，问每次修改后原式的值为多少？答案对1e9+7取模 题解：由于运算有优先级，每个+分开各个区间，提前将区间内的信息整合到数组里保存，然后进行计算即可，需要用逆元处理除法 int a[maxn], pos[maxn]; ll res[maxn]; ll quickpow(ll a, ll b) { ll ans = 1; ll res = a % mod; while (b) { if (b &amp; 1) ans = ans * res % mod; b &gt;&gt;= 1; res = res * res % mod; } return ans % mod; } ll inv(ll x) { return quickpow(x, mod - 2); } void solve(){ int n, q; cin &gt;&gt; n &gt;&gt; q; char c; int tmppos = 1; rep(i, 1, n) { cin &gt;&gt; c; if (i == n - 1) { if (c == '+') { pos[i] = tmppos; pos[i + 1] = tmppos + 1; } else { pos[i] = tmppos; pos[i + 1] = tmppos; } } else { if (c == '+') { pos[i] = tmppos; tmppos++; } else { pos[i] = tmppos; } } } ll ans = 0; ll tmp = 1; tmppos = 1; rep(i, 1, n + 1) { cin &gt;&gt; a[i]; if (pos[i] == tmppos) { tmp = (tmp * (a[i] % mod)) % mod; } else { ans = (ans + tmp) % mod; res[tmppos] = tmp; tmp = a[i] % mod; tmppos++; } } if (tmppos == pos[n]) { ans = (ans + tmp) % mod; res[tmppos] = tmp; } int x, y; rep(i, 0, q) { cin &gt;&gt; x &gt;&gt; y; tmppos = pos[x]; ans = (ans - res[tmppos] + mod) % mod; res[tmppos] = (res[tmppos] * inv(a[x] * 1ll) % mod * y) % mod; ans = (ans + res[tmppos]) % mod; a[x] = y; cout &lt;&lt; ans &lt;&lt; endl; } } H 小沙的数数 (位运算) 题意： 有一个a数组，我们已知他的长度为n，a[+]的和为m，请问如果我们想要a[⊕]的值最大，数组a在满足a[+]=m时有多少种情况？我们定义a[+]指a1+a2….ana_1+a_2….a_na1+a2….an的值；a[⊕]指a1a_1a1⊕a2a_2a2⊕a3a_3a3….an….a_n….an的值，a数组全部为非负整数 题解： 由于在二进制拆位最后同位情况下如果存在不止一个一，那么异或之后的贡献一定小于我们的费用，所以我们要保证对于每一位的个数要么是0，要么是1，这样的话才能保证a=a[+]，随后我们发现对于每一位来说，他们均不相互干扰，那么他们可能产生的情况便都是n种，所以我们只需要求二进制下m有多少个1，随后求n^x次方即可 int foo(ll x) { //计算二进制有多少个1 int count = 0; while (x) { count++; x = x &amp; (x - 1); } return count; } ll quickpow(ll a, ll b) { ll ans = 1; ll res = a % mod; while (b) { if (b &amp; 1) ans = ans * res % mod; b &gt;&gt;= 1; res = res * res % mod; } return ans % mod; } void solve() { ll n,m; cin&gt;&gt;n&gt;&gt;m; int base=foo(m); ll ans = 0; if(base==1) cout&lt;&lt;n%mod; else cout&lt;&lt;quickpow(n,base)%mod; } I 小沙的构造 构造题，贪心构造即可 string all=\"\\\"!\\'*+-.08:=^_WTYUIOAHXVM|\"; //25 string db=\"&lt;&gt;\\\\/[]{}()\"; //10 char s[maxn]; void solve() { int n,m; cin&gt;&gt;n&gt;&gt;m; if(m==36 || n&lt;m) {cout&lt;&lt;-1; return;} int have=0; int dbpos=0,allpos=0; bool add=true; rep(i,0,n/2){ if(have&lt;m){ if(dbpos&lt;10 &amp;&amp; have+2&lt;m){ s[i]=db[dbpos]; dbpos++; s[n-1-i]=db[dbpos]; dbpos++; have+=2; }else{ s[i]=all[allpos]; s[n-1-i]=all[allpos]; have++; if(have&lt;m) allpos++; } }else{ s[i]=all[allpos]; s[n-1-i]=all[allpos]; add=false; } } if(n&amp;1){ s[n/2]=all[allpos]; if(add) have++; } if(have&lt;m) {cout&lt;&lt;-1; return;} rep(i,0,n) cout&lt;&lt;s[i]; } K 小沙的步伐 水题 void solve() { string s; cin&gt;&gt;s; int len=s.length(); int a[15]; mem(a,0); rep(i,0,len){ if(s[i]=='5'){ continue; }else{ a[5]++; int tmp=int(s[i]-'0'); a[tmp]++; } } rep(i,1,10){ cout&lt;&lt;a[i]&lt;&lt;\" \"; } } 待补…","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"图论","slug":"图论","permalink":"https://maskros.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"逆元","slug":"逆元","permalink":"https://maskros.top/tags/%E9%80%86%E5%85%83/"}]},{"title":"Codeforces Round 768 (Div.2)","slug":"codeforces/cf 768","date":"2022-01-29T10:30:00.000Z","updated":"2022-01-29T13:27:03.905Z","comments":true,"path":"/post/codeforces/cf 768.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20768.html","excerpt":"Codeforces Round 768 (Div.2)","text":"Codeforces Round #768 (Div.2) 康复训练第二场cf A_Min_Max_Swap 水题，模拟 int a[200],b[200]; void solve() { int n; cin&gt;&gt;n; rep(i,0,n) cin&gt;&gt;a[i]; rep(i,0,n) cin&gt;&gt;b[i]; rep(i,0,n){ if(a[i]&lt;b[i]) swap(a[i],b[i]); } sort(a,a+n); sort(b,b+n); cout&lt;&lt;a[n-1]*b[n-1]&lt;&lt;endl; } B_Fun_with_Even_Subarrays 题意： 给一个序列，规定操作：选择起点为l将长为k的序列用它相邻的下一个长为k的序列覆盖，问最少经过多少次操作才能使序列中所有数相同？ 思路： 同样粗略地模拟一下，从序列尾部向前反推即可 int a[maxn]; void solve() { int n; cin&gt;&gt;n; rep(i,0,n){ cin&gt;&gt;a[i]; } if(n==1) cout&lt;&lt;0&lt;&lt;endl; else{ int sd=a[n-1]; int len=1; int ans=0; red(i,n-1,0){ if(a[i]==sd){ len++; } else{ ans++; i=i-len+1; len*=2; } } cout&lt;&lt;ans&lt;&lt;endl; } } C_And_Matching 题意： 给定 , , 要求将 构造出 对 ，满足 ​ 规定 是 2 的幂， 思路： 一开始因为读题漏掉了规定条件导致一时没法做，一定要仔细读题。 可以找到规律：序列首尾依次做AND操作一定为0，不妨将 与 相与，因为 必定所有位都为1，所以与值为 。然后再首尾依次相与，原本理应与 相与的数使它与0相与即可。特别的，当 时，特殊考虑一种组合方法即可。 void solve() { ll n,k; cin&gt;&gt;n&gt;&gt;k; if(n==4&amp;&amp;k==3) cout&lt;&lt;-1&lt;&lt;endl; eif(n-1==k){ cout&lt;&lt;n-2&lt;&lt;\" \"&lt;&lt;n-1&lt;&lt;endl; cout&lt;&lt;1&lt;&lt;\" \"&lt;&lt;n-3&lt;&lt;endl; cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;2&lt;&lt;endl; rep(i,3,n/2){ if (i == n - 2 || i == n - 1 || i == n - 3 || n - i - 1 == n - 1 || n - i - 1 == n - 2 || n - i - 1 == n - 3) continue; else cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;n-i-1&lt;&lt;endl; } } else{ cout&lt;&lt;k&lt;&lt;\" \"&lt;&lt;n-1&lt;&lt;endl; rep(i,1,n/2){ if(k!=i &amp;&amp; k!=n-i-1){ cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;n-i-1&lt;&lt;endl; }else{ if(k==i){ cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;n-i-1&lt;&lt;endl; }else{ cout&lt;&lt;0&lt;&lt;\" \"&lt;&lt;i&lt;&lt;endl; } } } } } D_Range_and_Partition 题意： 给定一个长为 的序列 ，找到一系列区间 (x&lt;=y)，将序列 分为 个子序列，要求每个序列中在区间 的数严格大于在区间外的数，要求最小化 规定 k&lt;=n&lt;=2e5 思路： 由题可知， 段中每一段在区间的数的数量至少比不在区间内的数的数量多1, 并且只要整个数组满足整个条件那么一定存在将数组分成k段仍然满足的方法。判断条件：设整个数组中在区间内的数的数量为 num，不在区间内的为n-num。只要num-(n-num)&gt;=k即满足条件。于是我们枚举区间的左边界，二分求解满足条件的最小右边界即可。 :::tip 当发现 、最小化差值对象、数据范围为2e5时，我们首先考虑： （1）尺取法(双指针) （2）结论题 （3）枚举一端，另一端 log/O(1) 复杂度 ::: #define maxn 200005 using namespace std; int n,k,a[maxn]; int vis[maxn]; void solve() { cin&gt;&gt;n&gt;&gt;k; mem(vis,0); rep(i,1,n+1){ cin&gt;&gt;a[i]; vis[a[i]]++; //计数 } rep(i,1,n+1) vis[i]+=vis[i-1]; //前缀和统计区间计数 int x=1,y=n; rep(i,1,n+1){ //枚举区间左边界 int l=i, r=n; int num=vis[r]-vis[l-1]; if(num-(n-num)&lt;k) break; // 不存在以i为左边界的合法区间 while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; num=vis[mid]-vis[i-1]; //区间范围内的数 if(num-(n-num)&gt;=k) r=mid-1; else l=mid+1; } if(l-i&lt;y-x){ x=i; y=l;} } cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl; for(int l=1,r=1; l&lt;=n; l=r+1,r=l,k--){ if(k==1){ cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;n&lt;&lt;endl; break; }else{ int cnt1=0, cnt2=0; while(1){ if(a[r]&gt;=x &amp;&amp; a[r]&lt;=y) cnt1++; else cnt2++; if(cnt1&lt;=cnt2) r++; else break; } cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; } } } 反思：一场不如一场，寄","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"2022牛客寒假算法基础集训营1","slug":"nowcoder/2022winter/round1","date":"2022-01-25T15:30:50.000Z","updated":"2022-01-26T04:46:37.746Z","comments":true,"path":"/post/nowcoder/2022winter/round1.html","link":"","permalink":"https://maskros.top/post/nowcoder/2022winter/round1.html","excerpt":"","text":"2022牛客寒假算法基础集训营1 AC 9 / 12 *A 九小时九个人九扇门 (dp (0/1背包)) 题意：n 个人，每个人有一个数字 a[i]，可以随意组合，组合起来为数字的加和。一共1~9号门 ，如果组合后的数字根等于门的序号，即可打开。问分别有多少种人物组合可以打开对应的门。数字根：将该数字各数位上的数字相加得到一个新的数，直到得到的数字小于10为止。 有用的结论：一个数的数字根等于这个数对9取模的结果(得0时数字根为9) 思路： 经典0/1背包变形的DP问题，dp[i][j]表示考虑了前 i 个数，选择了一些数字使得求和对9取模得 j的方案数，转移类似0/1背包的转移 // 数字根 = 本身 mod 9 int a[maxn]; int dp[maxn][15]; void solve(){ int n; cin&gt;&gt;n; int t; rep(i,1,n+1){ cin&gt;&gt;t; a[i]=t%9; } dp[1][a[1]]=1; rep(i,2,n+1){ rep(j,0,9){ int k=(j+a[i])%9; dp[i][k]=(dp[i-1][k]%mod+dp[i-1][j]%mod)%mod; } dp[i][a[i]]++; } rep(i,1,10){ if(i==9) cout&lt;&lt;dp[n][0]; else cout&lt;&lt;dp[n][i]&lt;&lt;\" \"; } } C Baby’s first attempt on CPU 题意：计组学过的流水线CPU，解决先写后读相关问题需要中间插入空语句，共n个语句，每个语句三个数字表示和前1/2/3条语句是否存在先写后读相关，总共需要插入多少空语句 题解：水题，当时为了时间乱jb写的，无参考价值；维护三个dis表示和前1/2/3条语句的间隔条数，分类判断即可。 void solve() { int x1,x2,x3; int n; scanf(\"%d\", &amp;n); int ans=0; int dis1=0,dis2=1,dis3=2; rep(i,0,n){ scanf(\"%d%d%d\",&amp;x1,&amp;x2,&amp;x3); if(x1==1) {ans+=3; dis2=4; dis3=5;} eif(x2==1) { if(dis2&gt;=3){dis3=dis2+1; dis2=dis1+1; dis1=0; } else { ans+=(3-dis2); dis2=4-dis2; dis3=3; } }eif(x3==1){ if(dis3&gt;=3) {dis3=dis2+1; dis2=dis1+1; dis1=0;} else{ ans+=(3-dis3); dis2=4-dis3; dis3=4; } }else{ dis3=dis2+1; dis2=dis1+1; dis1=0; } } cout&lt;&lt;ans&lt;&lt;endl; } D 牛牛做数论 (欧拉函数) 题意： 定义对于正整数 , ，给定一个整数 ，分别求 使得 分别取最大值和最小值 题解： ① 根据欧拉函数的性质，我们知道如果 为质数，则 ，此时 ​ 即取最大值； ② 欧拉函数可以根据质因数分解求得： , 回看 ，发现可以约掉 ，故可知是由质数依次相乘一定是最小值: ，故可筛出质数后遍历质数表即可。 const int MAXN = 10000; int prime[MAXN + 1]; void getPrime() { memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= MAXN; i++) { if (!prime[i]) prime[++prime[0]] = i; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++) { prime[prime[j] * i] = 1; if (i % prime[j] == 0) break; } } } bool isPrime(int num) { if (num == 2 || num == 3) { return true; } if (num % 6 != 1 &amp;&amp; num % 6 != 5) { return false; } for (int i = 5; i * i &lt;= num; i += 6) { if (num % i == 0 || num % (i + 2) == 0) { return false; } } return true; } void solve() { int n; cin&gt;&gt;n; if(n==1) {cout&lt;&lt;-1&lt;&lt;endl; return;} int mx,mn=2; red(i,n+1,2){ if(isPrime(i)) {mx=i; break;} } ll tmp=1; rep(i,1,1000){ tmp*=prime[i]; if(tmp&lt;=n) mn=tmp; else break; } cout&lt;&lt;mn&lt;&lt;\" \"&lt;&lt;mx&lt;&lt;endl; } E 炸鸡块君的高中回忆 水题 void solve() { int m,n; cin&gt;&gt;n&gt;&gt;m; if(m==1){ if(n==1) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; return; } int ans; n-=m; int tmp=n%(m-1); ans=n/(m-1)*2; if(tmp!=0) ans+=3; else ans++; cout&lt;&lt;ans&lt;&lt;endl; } F 中位数切分 结论题：如果中位数大于 ，则该列中的大于 的数的个数一定超过一半，划分段数直接等于 大于m的个数 - 小于m的个数，随便推推就知道了。 void solve() { int n,m; scanf(\"%d%d\",&amp;n, &amp;m); int bg=0,sm=0; int t; rep(i,0,n){ scanf(\"%d\", &amp;t); if(t&gt;=m) bg++; else sm++; } if(bg&lt;=n/2) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;bg-sm&lt;&lt;endl; } H 牛牛看云 题意：给出一个序列 , 计算 ，数据范围 n&lt;1e6, 0&lt;=ai&lt;=1000 题解：注意到 n&lt;=1e6 且 a[i]&lt;=1000，知道a[i]范围很小，所以极限数据下会有大量重复值出现，故可以用 cnt[i] 表示 i 出现的次数，枚举(i,j)对(共1e6种)：不同情况直接相乘，特殊处理相同情况 vector&lt;int&gt; v[maxn]; void solve() { int n; cin &gt;&gt; n; ll ans = 0; rep(i, 0, n) { int x; cin &gt;&gt; x; v[x].pb(i); } rep(i, 0, 1001) { rep(j, i, 1001) { ll x = v[i].size(); ll y = v[j].size(); if (i == j) { ans += x * (x + 1) / 2 * abs(i + j - 1000); } else ans += x * y * abs(i + j - 1000); } } cout &lt;&lt; ans &lt;&lt; endl; } *I B站与各唱各的 (概率/逆元) 题意：n个人唱m句，每个人对每一句都可以选择唱或不唱，n个人、m句之间互相独立，如果某一句没人唱或者所有人都唱了则失败，否则成功，求唱成功句子数量的期望值。对1e9+7取模。 题解：​ 由于句子间相互独立，则最终期望为一句话的期望乘 ；每个人唱第每句的唯一策略就是以 的概率决定唱与不唱，所以失败的概率就为 （都唱+都不唱） 当 时，上式取最小值，故失败的概率为 , 故易知成功的概率 注意求逆元, 推式子输出逆元的题比较常见。 ll quickpow(ll a, ll b) { ll ans = 1; ll res = a%mod; while (b) { if (b &amp; 1) ans = ans * res%mod; b &gt;&gt;= 1; res = res * res%mod; } return ans%mod; } void solve() { int n,m; cin&gt;&gt;n&gt;&gt;m; ll a = (quickpow(2,n-1)-1+mod)%mod; a=a*m%mod; ll b = quickpow(2,n-1); ll ans = a*quickpow(b,mod-2)%mod; cout&lt;&lt;ans&lt;&lt;endl; } J 小朋友做游戏 水题 int a[maxn],b[maxn]; int ans = 0; int posa,posb; void goA(){ ans+=a[posa]; posa++; } void goB(){ ans+=b[posb]; posb++; } void solve() { int A,B,n; cin&gt;&gt;A&gt;&gt;B&gt;&gt;n; rep(i,0,A) cin&gt;&gt;a[i]; rep(i,0,B) cin&gt;&gt;b[i]; sort(a,a+A,greater&lt;int&gt;() ); sort(b,b+B,greater&lt;int&gt;() ); ans = 0; if(n&gt;2*A) cout&lt;&lt;-1&lt;&lt;endl; else{ posa=0,posb=0; if(n&amp;1){ rep(i,0,(n+1)/2) ans+=a[i]; posa=(n+1)/2; }else{ rep(i,0,n/2) ans+=a[i]; posa=n/2; } bool AA=true,BB=true; if(posa==A) AA=false; if(posb==B) BB=false; rep(j,posa,n){ if(AA&amp;&amp;BB){ if (a[posa] &gt;= b[posb]) { goA(); }else goB(); if(posa==A) AA=false; if(posb==B) BB=false; }eif(AA){ goA(); }eif(BB) goB(); } cout&lt;&lt;ans&lt;&lt;endl; } } *K 冒险公社(dp) 待补 unsolved L 牛牛学走路 水题 void solve() { int n; cin&gt;&gt;n; char c; double mx=0; double tmp; int x=0,y=0; rep(i,0,n){ cin&gt;&gt;c; if(c=='L') x-=1; eif(c=='R') x+=1; eif(c=='U') y+=1; else y-=1; tmp=sqrt(fabs(x*x)+fabs(y*y)); mx=max(mx,tmp); } printf(\"%.7lf\\n\",mx); }","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"euler","slug":"euler","permalink":"https://maskros.top/tags/euler/"},{"name":"逆元","slug":"逆元","permalink":"https://maskros.top/tags/%E9%80%86%E5%85%83/"}]},{"title":"Codeforces Round 767 (Div.2)","slug":"codeforces/cf 767","date":"2022-01-23T05:15:00.000Z","updated":"2022-01-24T04:25:29.824Z","comments":true,"path":"/post/codeforces/cf 767.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20767.html","excerpt":"Codeforces Round 767 (Div.2)","text":"Codeforces Round #767 (Div.2) 荒废了期末考试月的康复训练第一场 A_Download More RAM 水题，排序即可 pair&lt;int,int> pr[105]; bool cmp(pair&lt;int,int> a, pair&lt;int,int> b)&#123; return a.fst&lt;b.fst; &#125; void solve() &#123; int n,k; cin>>n>>k; rep(i,0,n)&#123; cin>>pr[i].fst; &#125; rep(i, 0, n) &#123; cin >> pr[i].sec; &#125; sort(pr,pr+n,cmp); ll tmp=k; rep(i,0,n)&#123; if(tmp>=pr[i].fst) tmp+=pr[i].sec; else break; &#125; cout&lt;&lt;tmp&lt;&lt;endl; &#125; int main() &#123; int T; cin >> T; while (T--) &#123; solve(); &#125; &#125; B_GCD Arrays 题意： 对一个 [l,r] 区间里的数，最多操作k次，每次取两个数，将他们的乘积替代其中一个数放入序列中，问能不能使序列的GCD不为1，能即YES，不能即NO 思路： 粗略的想了一下，乘积之后肯定包含两个原数作为因子，没啥区别，考虑连续区间、奇偶性后，猜测结论：每次操作使奇数*偶数=偶数，将乘积代替奇数，至多k次操作能否使得序列全变为偶数(GCD=2)，注意特判 写的比较仓促，所以比较丑，可以简化= = void solve() &#123; int l,r,k; cin>>l>>r>>k; int ou=0,ji=0; if((r-l+1)&amp;1)&#123; if(l&amp;1)&#123; ji++; &#125;else ou++; ji+=(r-l)>>1; ou+=(r-l)>>1; &#125;else&#123; ou=(r-l+1)>>1; ji=ou; &#125; if(ou==0)&#123; if(l!=1) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125;else&#123; if(ji&lt;=k) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125; &#125; int main() &#123; int T; cin >> T; while (T--) &#123; solve(); &#125; &#125; C_Meximum ArrayMex：一个序列中不存在的最小的非负整数 题意： 给你一个长为n的序列a，每次从a数组的首地址开始选取一段，求mex后将值存入b，随后在a中删去该段。问最终求得的字典序最大的b序列是什么样子的 思路： 模拟（队友用主席树艹过了xD）一个map&lt;int,int&gt; m表示a[i]出现的次数，每次求最大mex的时候即利用该map，删除序列即对map进行操作即可；set&lt;int&gt; S表示从序列开始所有小于mex的数，如果 S.size()&lt;=mex，继续拓展序列的长度就不是最优解，故该位置即作为选取序列的结尾 卡了很久，刚开始想了个n2模拟，结果T了，比较傻逼，后来优化一下就过了 int a[maxn]; map&lt;int, int> m; int check(int start) &#123; rep(i, start, maxn) &#123; if (m[i] == 0) &#123; return i; &#125; &#125; return 0; &#125; vector&lt;int> b; set&lt;int> S; void solve() &#123; int n; cin >> n; int mex = 0; m.clear(); b.clear(); rep(i, 0, n) &#123; cin >> a[i]; m[a[i]]++; if (m[mex] > 0) &#123; mex = check(mex); &#125; &#125; S.clear(); rep(i, 0, n) &#123; if (a[i] &lt; mex) S.insert(a[i]); m[a[i]]--; if (S.size() >= mex) &#123; b.pb(mex); mex = check(0); S.clear(); &#125; &#125; cout &lt;&lt; b.size() &lt;&lt; endl; rep(i, 0, b.size()) cout &lt;&lt; b[i] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; int main() &#123; IOS; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; D_Peculiar Movie Preferences 题意： 给你一堆长&lt;=3的字符串，问能不能通过删掉任意个数的字符串，剩下的字符串按顺序拼接起来为回文串 思路： 沙比题，回文串首尾必定一样，所以如果可以的话最多找两个串即可组成回文串，总长度&lt;=6。首先特判单个串，如果单个回文即为YES；再者分别考虑 2+2/3+3, 2+3/3+2 的情况，特别是后面那一种，这里通过map优化，对字符串做reverse处理，针对不同情况判断即可 TuT map&lt;string,int> mp1,mp2; void solve() &#123; int n; cin >> n; bool can = 0; string s,ss; mp1.clear(); mp2.clear(); rep(i, 0, n) &#123; cin >> s; if(!can)&#123; ss = s; reverse(ss.begin(), ss.end()); if (s.size() == 1) can = 1; eif(s[0] == s[s.size() - 1]) can = 1; else&#123; if(mp1[ss]==1 || mp2[ss]==1) can=1; eif(s.size()==3)&#123; ss.erase(ss.end()-1, ss.end()); if (mp1[ss]) can = 1; &#125; mp1[s]=1; if(s.size()==3)&#123; s.erase(s.end()-1, s.end()); mp2[s]=1; &#125; &#125; &#125; &#125; if (can) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; int main() &#123; int T; IOS; cin >> T; while (T--) &#123; solve(); &#125; &#125; E_Grid Xor 暂时鸽了，出去运动完回来补 构造题 反思：好久不打确实手生+脑残，寒假再接再厉✊","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"利用WeRoBot框架进行微信公众号开发","slug":"note/WeRoBot","date":"2021-12-27T17:24:28.000Z","updated":"2022-01-22T17:29:00.674Z","comments":true,"path":"/post/note/WeRoBot.html","link":"","permalink":"https://maskros.top/post/note/WeRoBot.html","excerpt":"WeRoBot","text":"利用WeRoBot框架进行微信公众号开发 寄网小实验，实现起来不难，记录一下以备不时之需，包括一些对Token的理解 准备微信公众号、云服务器、Xftp&amp;Xshell (Replaceable)、WeRoBot 1.13.1 总体流程step1 : 注册微信公众号 step2 : 通过验证Token将公众号与服务器绑定 step3 : 在服务器代码里加入公众号实现的功能 关于WeRoBot WeRoBot官方文档: link WeRoBot 是一个基于Python的微信机器人框架，采用MIT协议发布。可以将微信服务器发来的消息进行解析和转换，使用 Session 记录用户状态，包括开发自定义菜单等功能，对初学者来讲使用起来也比较简单。WeRoBot 可以作为独立服务运行，也可以集成在其他 Web 框架中一同运行。以下简单举例： 0x01 Hello World# 给收到的每一条信息回复 Hello World import werobot robot = werobot.WeRoBot(token='tokenhere') @robot.handler def hello(message): return 'Hello World!' # 让服务器监听在 0.0.0.0:80 robot.config['HOST'] = '0.0.0.0' robot.config['PORT'] = 80 robot.run() 0x02 消息处理 WeRoBot 会解析微信服务器发来的消息， 并将消息转换成成 Message 或者是 Event 。 Message 表示用户发来的消息，如文本消息、图片消息； Event 则表示用户触发的事件， 如关注事件、扫描二维码事件。 在消息解析、转换完成后， WeRoBot 会将消息转交给 Handler 进行处理，并将 Handler 的返回值返回给微信服务器 @robot.handler #robot 会将所有接收到的消息转交给这个 Handler 来处理 @robot.text # @robot.text 修饰的 Handler 只处理文本消息 @robot.image # @robot.image 修饰的 Handler 只处理图片消息 @robot.subscribe # 用户关注后执行该操作 0x03 demo 实验课原味🐴, 简单完成了消息处理，调了个接口，调了个狗屁不通文本生成器， 糙的一，留做纪念 import werobot import requests import json import gpbtwzbuilder as gp robot = werobot.WeRoBot(token='qwertyuiopasdfghjkl') # 是否菜单模式 isMenu = 1 # 功能模式序号 funCode = 0 # 合法操作 codelist = ['1','2','3'] def menu(): return \"欢迎使用本公众号！\\n 本公众号共有两个模式：菜单模式和功能模式 \\n \" + \"功能选择模式：\\n menu - 查看菜单 \\n 1 - 查询城市的天气状况 \\n 2 - 自言自语模式\\n 3 - 狗屁不通文章生成器\\n\" + \"功能模式：\\n 0 - 退出功能模式返回菜单\" def check(fcode): global codelist global isMenu if fcode in codelist: isMenu = 0 if fcode == '1': return \"输入城市名查询天气\" elif fcode == '2': return \"自言自语！\" elif fcode == '3': return \"输入'文章主题&amp;字数(&lt;=600)'开始狗屁不通\" else: return \"Wrong Operation. Input 'menu' to know more!😅\" @robot.subscribe def subscribe(message): return menu() # @robot.text 修饰的 Handler 只处理文本消息 @robot.text def echo(message, session): global isMenu global funCode if 'first' not in session: isMenu = 1 session['first'] = True msgtext = message.content if isMenu == 1: if \"menu\" in msgtext or \"Menu\" in msgtext: return menu() else: funCode = msgtext return check(funCode) else: if msgtext == '0' or \"menu\" in msgtext or \"Menu\" in msgtext: isMenu = 1 return \"退出成功！\" + menu() if funCode == '1': addr = msgtext url = 'http://wthrcdn.etouch.cn/weather_mini?city=' + addr response = requests.get(url=url) result = json.loads(response.text) #解析json data = result[\"data\"][\"forecast\"][0][\"date\"] high = result[\"data\"][\"forecast\"][0][\"high\"] fengli = result[\"data\"][\"forecast\"][0][\"fengli\"] low = result[\"data\"][\"forecast\"][0][\"low\"] fengxiang = result[\"data\"][\"forecast\"][0][\"fengxiang\"] tian = result[\"data\"][\"forecast\"][0][\"type\"] return \"时间：\" + data + \"\\n最好气温：\" + high + \"\\n最低气温：\" + low + \"\\n风向：\" + fengxiang + \"\\n天气：\" + tian elif funCode == '2': return msgtext elif funCode == '3': ret = msgtext.partition('&amp;') xx = ret[0] for x in xx: tmp = str() maxlength = int(ret[2]) if maxlength > 600: return \"字数超了😅，看不懂中国话是8😅\" while (len(tmp) &lt; maxlength): 分支 = gp.random.randint(0, 100) if 分支 &lt; 5: tmp += gp.另起一段() elif 分支 &lt; 20: tmp += gp.来点名人名言() else: tmp += next(gp.下一句废话) tmp = tmp.replace(\"x\", xx) return tmp # @robot.image 修饰的 Handler 只处理图片消息 @robot.image def img(message): return message.img # 让服务器监听在 0.0.0.0:80 robot.config['HOST'] = '0.0.0.0' robot.config['PORT'] = 80 robot.run() 关于Token 有一篇很好的文章 : link，以下内容部分借鉴 Token：身份认证中代指令牌 Token验证过程Step1 : 用户通过用户名和密码发送请求。 Step2 : 服务器端程序验证。 Step3 : 服务器端程序返回一个带签名的token 给客户端。 Step4 : 客户端储存token,并且每次访问API都携带Token到服务器端的。 Step5 : 服务端验证token，校验成功则返回请求数据，校验失败则返回错误码。 Token的优势 无状态，可扩展 在客户端存储的Token无状态、可扩展(能够创建与其它程序共享权限的程序)。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。tokens自己携带了用户的验证信息。 安全性：防止CSRF 请求中发送token而非发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 ps：token是有时效的，一段时间之后用户需要重新验证。 多平台跨域 这里引入CORS(跨域资源共享)的概念：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 以上只是关于Token的粗略描述，关于其他身份认证机制挖坑待填😅 附：一些Linux命令 使用 nohup 命令使程序在服务器保持后台运行 sudo nohup python .&#x2F;webserver.py &amp; 杀掉 nohup 进程 ps -aux | grep python kill -9 pid End.","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"},{"name":"WeRoBot","slug":"WeRoBot","permalink":"https://maskros.top/tags/WeRoBot/"}]},{"title":"Notes on Kurose's Computer Networking：A TOP-DOWN APPROACH","slug":"note/ComputerNetwork_Note","date":"2021-12-10T05:44:28.000Z","updated":"2021-12-25T07:11:55.191Z","comments":true,"path":"/post/note/ComputerNetwork_Note.html","link":"","permalink":"https://maskros.top/post/note/ComputerNetwork_Note.html","excerpt":"A brief summary about the Computer Networking","text":"Notes on Kurose’s Computer NetworkingA TOP-DOWN APPROACH Thanks to 我爹的博客，让我偷了不少😋 Chapter 1 Computer Networks and the Internet1.1 What is the Internet? 因特网：世界范围的计算机网络 Nuts-and-Bolts Description 计算设备称为 主机(host) / 端系统(end system) 端系统通过 通信链路(communication link) 和 分组交换机(packet switch) 连接到一起；不同链路传输速率不同，发送端将数据分段后每段加上首部所形成的信息包称为 分组(packet) 端系统通过 因特网服务提供商(ISP, Internet Service Provider) 接入因特网 端系统、分组交换机和其他部件需要运行一系列协议(protocol) 。因特网的主要协议：TCP/IP (Transmission Control Protocol, 传输控制协议 / Internet Protocol, 网际协议) Service 分布式应用程序：因特网应用中涉及多个相互交换数据的端系统的应用程序 与因特网相连的端系统提供了一个 套接字接口(Socket interface)，规定在一个端系统上的程序请求因特网基础设施向另一个端系统上的目的地程序交付数据的方式 Protocol Def: 定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作 不同的协议用于不同的通信任务 1.2 The Network Edge 主机分类：客户(Client) / 服务器(Server) Access Networks 接入网：将主机物理连接到其边缘路由器(Edge router)的网络 家庭接入：数字用户线(DSL)、电缆因特网接入、光纤到户(FTTH)、拨号、卫星 企业/家庭接入：以太网(Ethernet)、WIFI 广域无线接入：3G、LTE Physical Media 双绞铜线、同轴电缆、光纤、陆地/卫星无线电信道 1.3 The Network Core 通过网络链路和交换机移动数据有两种基本方法：电路交换 和 分组交换 1.3.1 Packet Switching 分组交换 : 端系统彼此交换报文(message)，源端将报文划分成较小的数据块，称为分组；在源和目的地之间每个分组经过通信链路和 分组交换机 (packet switch)传送，两类交换机分别为 路由器(router) 和 链路层交换机(link-layer switch) Store-and-Forward Transmission 存储转发传输：交换机在开始向输出链路传输分组之前需要接收到整个分组 exp: 通过 $N$ 条速率均为 $R$ 的链路组成的路径 (即在源和目的地之间有 $N-1$ 台路由器) 所用 端到端时延为 $d=N \\dfrac{L}{R}$ Queuing Delays and Packet Loss 排队时延和分组丢失：分组交换机具有一个输出缓存(output buffer) 即输出队列，除存储转发时延外分组还要承受输出缓存的排队时延(queuing delay)，如果一个分组到达后发现该缓存空间已满，则发生丢包(packet loss)，到达的分组或已经排队的分组之一将被丢弃 Forwarding Tables and Routing Protocols 转发表和路由选择协议：每台路由器有一个转发表(Forwarding Table)，用于将目的地址/目的地址的一部分映射成输出链路。路由选择协议(routing protocol)用于自动地设置转发表 1.3.2 Circuit Switching 电路交换：建立名副其实的连接，路径上的交换机维护连接状态，电路交换网络上的两主机通信时，网络在两主机间创建一条专用的端到端连接(end-to-end connection) Multiplexing 链路中的电路通过频分复用(FDM, Frequency-Division Multiplexing)或时分复用(TDM, Time-Division Multiplexing)来实现 FDM：链路的频谱由所有连接共享，在连接期间链路为每条连接专用一个频段，频段的宽度称为带宽(band-width) TDM：时间被划分为固定期间的帧，每个帧被划分为固定数量的时隙(slot)，在网络跨越链路创建连接时，在每个帧中为该联结制定一个时隙，由该连接单独使用 分组交换的性能优于电路交换的性能 1.4 Delay, Loss, and Throughput in Packet-Switched Networks 计算机网络的性能测度：时延、丢包、吞吐量 Delay Total nodal delay = 节点处理时延(nodal processing delay) + 排队时延(queuing delay) + 传输时延(transmission delay) + 传播时延(propagation delay) 传输时延：将所有分组的比特推向链路所需要的时间 $\\frac{L}{R}$ 传播时延：将比特从链路的起点到目的地传播所需要的时间 $\\frac{d}{s}$，传播速率 $s$ 取决于物理媒体(光纤/双铜绞线等) Throughput 瞬时吞吐量(instantaneous throughput)：接收到文件的瞬时速率 (bps) 平均吞吐量(average throughput)：文件大小/收到文件所有比特的时间 计算所得的平均速率 (bps) 1.5 Protocol Layers and Their Service Models 分层(Layer)的体系结构 每层通过自己的内部动作/依靠下一层提供的服务来提供服务 Protocol Stack 协议栈：各层的所有协议 因特网协议栈：应用层、运输层、网络层、链路层、物理层 ISO OSI参考模型：应用层、表示层、会话层、运输层、网络层、链路层、物理层 应用层 Application Layer 网络应用程序、应用层协议 HTTP/SMTP/FTP/DNS 协议数据单元(实体交换的数据单位)/信息分组：报文(message) 运输层 Transport Layer TCP/UDP 协议数据单元：报文段(segment) 进程间传输 网络层 Network Layer IP/路由选择协议 协议数据单元：数据报(datagram) 主机间传输 链路层 Link Layer 以太网/802.11(WiFi)/PPP 协议数据单元：帧(frame) 物理层 Physical Layer 控制比特的发送 Encapsulation 封装过程：应用层报文 -&gt; 运输层报文段 -&gt; 网络层数据报 -&gt; 链路层帧 每一层的分组：首部字段 + 有效载荷字段(payload field) ┌───────────┐┌─────────┐ ┌───────┐ ┌────┐ ┌────────┐ │Application││Transport│ │Network│ │Link│ │Physical│ └─────┬─────┘└────┬────┘ └───┬───┘ └─┬──┘ └───┬────┘ │ │ │ │ │ │Message &#x3D; M│ │ │ │ │──────────&gt;│ │ │ │ │ │ │ │ │ │ │Segment &#x3D; H_t + M│ │ │ │ │────────────────&gt;│ │ │ │ │ │ │ │ │ │ │Datagram &#x3D; H_n + H_t + M│ │ │ │ │───────────────────────&gt;│ │ │ │ │ │ │ │ │ │ │Frame &#x3D; H_l + H_n + H_t + M│ │ │ │ │──────────────────────────&gt;│ ┌─────┴─────┐┌────┴────┐ ┌───┴───┐ ┌─┴──┐ ┌───┴────┐ │Application││Transport│ │Network│ │Link│ │Physical│ └───────────┘└─────────┘ └───────┘ └────┘ └────────┘ Chapter 2 Application Layer 应用层 2.1 Principles of Network Applications主流体系结构：客户-服务器体系结构 (C/S, client-server)，对等体系结构 (P2P, peer-to-peer) C/S： 服务器S： 总是打开的主机 (always-on host) 固定的IP地址 (permanent IP address) 服务于客户的请求 客户C: 请求主机 客户间不进行通信 exp: 两个浏览器并不直接通信 动态IP地址 (dynamic IP address) P2P： 没有永远在线的服务器 任意主机对直接通信，对等方 自扩展性 (self-scalability) 新的对等方增加服务能力 exp: P2P文件共享 流量密集型 动态IP地址 Processes Communicating 进程(process) : 运行在主机上的程序 同一主机内的进程：进程间通信 不同主机内的进程：交换报文(Message) 客户进程：发起通信的进程 服务器进程：在会话开始时等待联系的进程 进程与计算机网络间的接口：套接字(socket)，软件接口，进程向/从其套接字发送/接收报文 Reliable Date Transfer Def: 确保应用程序的一端发送的数据正确、完全地交付给了该应用程序的另一端，称为可靠数据传输 2.2 The Web and HTTP Web的应用层协议是 超文本传输协议 (HTTP, HyperText Transfer Protocol) C/S 模式 HTTP客户端：Web浏览器 (Web browser) HTTP服务器端：Web服务器 (Web server) 定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式 支撑运输协议：TCP 客户发起TCP连接，服务器接受TCP连接 建立连接后浏览器和服务器进程就可以通过套接字接口访问TCP 无状态协议(stateless protocol)：HTTP服务器不保存关于客户的信息 HTTP Message Format Request Message 请求报文 第一行为请求行(request line)：方法字段、URL字段、HTTP版本字段 后继四行为首部行(header line) Response Message 响应报文 一个状态初始行(status linge) 六个首部行(header line) 实体体(entity body) Status Code 状态码 200 OK：请求成功，信息在返回的相应报文中 301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解 404 Not Found：被请求的文档不在服务器上 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本 User-Server Interaction: Cookies cookie的4个组件： HTTP响应报文中的一个cookie首部行 HTTP请求报文中的一个cookie首部行 保留在客户端的cookie文件，由用户的浏览器进行管理 保留在Web服务器的后端数据库 Web Caching Web缓存器(Web cache) 又称 代理服务器(proxy server) 代表初始Web服务器来满足HTTP请求的网络实体 浏览器建立到Web缓存器的TCP连接，客户端将所有HTTP请求首先发送到Web缓存器中的对象，Web缓存器检查本地是否存储该对象副本 有：Web缓存器向客户浏览器用HTTP响应报文返回该对象 无：打开一个与该对象的初始服务器的TCP连接，发送该对象的HTTP请求，收到请求后初始服务器向该Web缓存器发送HTTP响应 Web缓存器既是客户也是服务器 服务器：接收浏览器的请求发回响应 客户：向初始服务器发出请求并接收响应 减少了客户端请求的响应时间 减少了一个机构的接入链路到因特网的通信量 The Conditional GET 条件GET：为了保证Web缓存器的对象是最新的 请求报文中使用GET方法并且包含一个”If-Modified-Since”首部行 客户端：在HTTP请求中指定缓存副本的日期 服务器：如果缓存的副本是最新的，则响应不包含任何对象 ┌──────┐ ┌──────┐ │client│ │server│ └──┬───┘ └──┬───┘ │ │ │If-modified-since &lt;date&gt; │ │────────────────────────&gt;│ │ │ │HTTP&#x2F;1.0 304 Not Modified│ │&lt;────────────────────────│ │ │ │If-modified-since &lt;date&gt; │ │────────────────────────&gt;│ │ │ │ HTTP&#x2F;1.0 200 OK &lt;data&gt; │ │&lt;────────────────────────│ ┌──┴───┐ ┌──┴───┐ │client│ │server│ └──────┘ └──────┘ 2.3 Electronic Mail in the InternetComponents of Email 用户代理(User Agent)：邮件客户端 邮件服务器(Mail Server)： 邮箱(mailbox)：包含用户的传入信息 报文队列(message queue)：包含外发(待发)信息 简单邮件传输协议(SMTP, Simple Mail Transfer Protocol)： 向/在邮件服务器上传递/存储消息 C/S模式： 客户端：用户代理或邮件服务器 服务器：邮件服务器 与HTTP的比较： HTTP：拉协议(pull protocol)，用户使用HTTP协议从服务器拉取信息 SMTP：推协议(push protocol)，发送邮件服务器把文件推向接受邮件服务器 因特网邮件访问协议(IMAP, Internet Mail Access Protocol) 检索/删除/文件夹中存储的邮件服务器上的邮件 exp: Alice sends an email to Bob ┌──────────────────┐┌───────────────────┐┌─────────────────┐ ┌────────────────┐ │Alice&#39;s user agent││Alice&#39;s mail server││Bob&#39;s mail server│ │Bob&#39;s user agent│ └────────┬─────────┘└─────────┬─────────┘└────────┬────────┘ └───────┬────────┘ │ │ │ │ │ SMTP │ │ │ │───────────────────&gt;│ │ │ │ │ │ │ │ │ SMTP │ │ │ │──────────────────&gt;│ │ │ │ │ │ │ │ │mail access protocol (IMAP or POP)│ │ │ │─────────────────────────────────&gt;│ ┌────────┴─────────┐┌─────────┴─────────┐┌────────┴────────┐ ┌───────┴────────┐ │Alice&#39;s user agent││Alice&#39;s mail server││Bob&#39;s mail server│ │Bob&#39;s user agent│ └──────────────────┘└───────────────────┘└─────────────────┘ └────────────────┘ 2.4 DNS-The Internet’s Directory Service 域名系统(DNS, Domain Name System)：一个由分层的DNS服务器(DNS server)实现的分布式数据库；一个使得主机能够查询分布式数据库的应用层协议 Services 主机名到IP地址的转换 主机别名(host aliasing)，规范主机名(CNAME, canonical hostname) 邮件服务器别名(mail server aliasing) 负载分配(load distribution)：许多IP地址对应一个名称 How DNS Works 分布式、层次数据库 根DNS服务器，顶级域DNS服务器，权威DNS服务器 本地DNS服务器 递归查询(recursive query)，迭代查询(iterative query) DNS缓存(DNS caching) exp: a distributed, hierarchical database exp: iterative query (more commonly used) vs recursive query 2.6 Video Streaming and Content Distribution Networks 经HTTP的动态适应性流(DASH, Dynamic Adaptive Streaming over HTTP) 内容分发网(CDN, Content Distribution Network) 服务器： 将视频文件分为多个块，每个块以多种不同速率进行编码 不同速率的编码(encoding)存储在不同的文件中 文件被复制到多个CDN节点中 生成告示文件(maifest file)，为不同块提供URL 客户端： 定义估算服务器到客户的带宽 查阅告示文件，每次请求一个分块 决定何时/何种编码率/请求哪台服务器 Streaming stored video: playout buffering Summary: video streaming = encoding + DASH + playout buffering Chapter 3 Transport Layer 传输层 3.1 Introduction and Transport-Layer Services 运输层协议为不同主机上的应用进程之间提供了逻辑通信(logic communication) 发送方 通过套接字传递应用层的报文 确定报文段(segment)报头的值 创建报文段 将报文段传递给网络层 接收方 从网络层接收报文段 检查报头值 提取应用层的报文 通过套接字将报文传递给应用层 Transport vs Network layer services exp: 家庭间的邮件传递 主机：家庭 进程：孩子 应用层报文：信件 运输层协议：两个家庭中由 Ann 和 Bill 为孩子们收发信件 网络层协议：邮政服务 不提供的服务：延迟保证，带宽保证 3.2 Multiplexing and Demultiplexing 复用(multiplexing)：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息生成报文段，将报文段传递给网络层 分用(demultiplexing)：将运输层报文段的数据交付到正确的套接字 套接字有唯一标识符，而每个报文段通过源端口号字段(source port number field)，目的端口号字段(destination port number field)指示报文段所要交付到的套接字 下图展示了复用和分用的过程 3.3 UDP: Connectionless Transport 用户数据报协议 无连接的 UDP发送方和接收方之间没有握手协议 每个UDP数据报独立处理 尽力而为交付服务(best-effort delivery service) 报文段可能丢失 报文段可能不符合顺序 Why there is a UDP 无需建立连接 不需要握手(无RTT延迟) 无连接状态 报头尺寸小 没有拥塞控制 速度快 有面对拥堵时的机制 用例：DNS, SNMP, HTTP/3(在应用层增加所需可靠性以及拥堵控制) UDP Segment Structure ------------ 32bit ------------ ┌───────────────┬───────────────┐ | source port # | dest port # | ├───────────────┼───────────────┤ | length | checksum | ├───────────────┴───────────────┤ | | | application data (payload) | | | └───────────────────────────────┘ 检验和(checksum): 提供差错检测功能，发送方的UDP对报文段中所有16bit字的和进行反码运算得到 3.4 Principles of Reliable Data Transfer 可靠数据传输协议(rdt协议, reliable data transfer protocol)：为TCP的可靠性保证做准备 Building a Reliable Data Transfer Protocol 假设： 单向的数据传输(发送方到接收方) 在不可靠的信道中进行双向控制信息(即ACK)流动 逐步改进rdt协议(提供有限状态机(Finite-State Machine, FSM) )： rdt1.0：信道完全可靠 rdt2.0：信道具有比特差错，使用ACK(肯定确认, positive acknowledgment) /NAK(否定确认, negative acknowledgment)，基于这样重传机制的可靠数据传输协议称为自动重传请求(ARQ, Automatic Repeat reQuest)协议 rdt2.1：如果ACK/NAK被破坏，使用序号(sequence number)来处理重复的信息 rdt2.2：只使用ACK rdt3.0：信道具有比特差错和丢包，使用倒计数定时器(countdown timer)，rdt3.0又称比特交替协议 Stop-and-Wait (starting from rdt2.0) 停等协议：发送方发送一个数据包，然后等待接收方的回应 发送方必须等待发送的数据包到达，或者直到超时，在某些情况下会导致发送方长时间处于空闲状态等待确认 Pipelining successor of Stop-and-Wait 流水线：发送方允许多个发送中的、尚未被ACK的数据包 Go-Back-N(GBN) 发送方： 最多可以有序号范围为N个的、连续传输但未ACK的数据包的窗口，N被称为窗口长度(window size) 累计确认(commulative ACK(n)) 表明接收方以正确收到序号为n的以前且包括n在内的所有数据包 向前移动窗口使起点位于 n+1 对发送时间最早但未被确认的数据包进行计时 超时事件(timeout(n))：重传n号和所有序号更高的数据包 接收方： 仅发送最高序号的ACK 在收到失序的数据包时 丢弃或缓存 重新发送按照顺序的最高序号的ACK Selective Repeat(SR) 发送方： 最多可以有序号范围为N个的、连续传输但未ACK的数据包的窗口 ACK(n)：标记n号数据包已收到，如果n是最小的未ACK的数据包，则窗口向前移动到下一个未ACK的数据包开始 timeout(n)：对未ACK的数据包单独重传 接收方 单独ACK(n) 收到失序的数据包时：缓存 收到有序的数据包时：交付(也交付缓冲的、符合顺序的数据包) 在Go-Back-N中使用的累计确认在TCP中也有使用 发送窗口和接收窗口的大小必须相等 3.5 TCP: Connection-Oriented Transport 传输控制协议 点对点(point-to-point)：一个发送方，一个接收方 可靠的，有序的字节流(byte-stream) 面向连接的(connection-oriented)：在数据交换前 握手(handshaking) 初始化发送方和服务器状态 累计确认(cumulative ACKs) 全双工服务(full-duplex service)：在同一连接中同时进行双向数据流 流水线：流量和拥堵控制 TCP Segment Structure UAPRSF：URG, ACK, PSH, RST, SYN, FIN 序列号(Sequence Number)：分段数据中第一个字节的字节流编号 确认号(Acknowledgement Number)：确认对方下一个字节的序列号，累计ACK RTT Estimation(via EWMA) and Timeout RTT: 连接的往返时间 SampleRTT: 报文段的样本RTT EstimateRTT: 估计往返时间 TimeoutInterval: 超时重传间隔 DevRTT: 偏差RTT EWMA: 指数加权移动平均 Exponential Weighted Moving Average EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT 取α = 0.125 TimeoutInterval = EstimatedRTT + 4·DevRTT DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT| 取β = 0.25 Fast Retransmit TCP快速重传：如果检测到3个冗余的ACK，则TCP执行快速重传，在该报文段的定时器过期之前重传丢失的报文段 Flow Control 流量控制： 接收方控制发送方，这样发送方就不会溢出接收方的缓冲区 接收窗口rwnd(receive window)：在TCP头的rwnd字段中，指示该接收方还有多少可用的缓存空间，或表示发送方将数据量限制在rwnd内 TCP Connection Management 三次握手(three-way handshake)建立连接 四次挥手(four-way handshake)结束连接 TCP状态(TCO state)的变迁，有限状态机(FSM) 3.6 Principles of Congestion Control 拥塞控制 拥塞(Congestion)： 太多的发送者以太快的速度发送太多的数据 表现：高延迟、丢包 与流量控制不同(一个发送方对于一个接收方来说速度太快) The Causes and the Costs of Congestion 吞吐量永远不会超过容量 延迟随着容量的增加而增加 丢失/转发/不必要的中端会降低有效吞吐量(throughput) 上游传输容量/缓冲区会因下游丢包而被浪费 Congestion Control 端到端拥塞控制(end-end approach)： 没有来自网络的明确反馈，从观察到的延迟、损失推断拥塞情况 网络辅助的拥塞控制： IP路由器在拥堵时向发送/接受主机提供直接反馈，可以显示拥堵程度或者明确设置发送速率 3.7 TCP Congestion ControlTCP的拥塞控制算法(CCA, congestion control algorithm)： 拥塞窗口cwnd(Congestion Window) 慢启动(slow-start)： cwnd的值以1个MSS开始，每当传输的报文段首次被确认就增加一个MSS，这一过程中每过一个RTT，发送速率就翻倍，指数增长 慢启动阈值ssthresh：如果存在一个由超时指示的丢包(即拥塞)，TCP发送方将 cwnd 设置为1并重新开始慢启动，将ssthresh设为 cwnd/2, 即当检测到拥塞时将其置位拥塞窗口值的一半。当到达或者超过ssthresh的值时，进入拥塞避免 拥塞避免(Congestion Avoidance) cwnd的值每个RTT只增加一个MSS，线性增长 由3个冗余ACK引起的丢包时, ssthresh = cwnd/2, cwnd = 1MSS, 进入快速恢复 快速恢复(Fast Recovery) 对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值就加一个MSS，当对丢失报文段的一个ACK到达时，TCP降低cwnd后进入拥塞避免状态 加性增、乘性减(AIMD, Additive-Increase, Multiplicative-Decrease) 拥塞控制方式 假定丢包由3个冗余ACK而不是超时指示：每个RTT内cwnd线性(加性)增加1MSS，然后出现3个冗余ACK事件时cwnd减半(乘性减) Chapter 4 The Network Layer: Data Plane网络层：数据平面 4.1 Overview of Network Layer 发送方： 将报文段封装成数据报(datagram)，传递给链路层 接收方： 从数据报中提取报文段，传递给传输层 两种重要功能： 转发(Forwarding)：将数据报从输入链路转移到适当的输出链路上，类比旅游中在每个路口做决定 路由(Routing)：确定数据报从原点到目的地的路线 Two Network Layer Planes Data Plane 数据平面 本地，每台路由器的功能 路由器内的数据报转发 硬件 Control Plane 控制平面 全网 沿着从原点到目的地的路径，在路由器之间进行数据报路由 传统路由算法：在路由器中实现 软件定义网络(SDN, Software-Defined Networking)：在远程服务器中实现 软件 Network layer’s “best effort” service model 尽力而为服务：不保证成功交付，及时/按顺序交付，最小带宽 4.2 What’s inside a Router? 输入端口(input port): 通过header的值进行转发表查询 转发方式： 基于目的地转发：只根据目的地的IP地址进行转发 通用转发：基于任何一组header值的转发，不仅仅是网络层的功能：转发(路由器，交换机)，丢弃(防火墙)，修改(NAT)，封装并转发到控制器(SDN) 最长前缀匹配(longest prefix matching rule)：通常使用三态内容可寻址存储器(TCAM, Tenary Content Address Memory)来查找 交换结构(switching fabric)： 将数据报从输入链路传输到适当的输出链路 交换率：数据报传输的速率，通常以多个输入/输出线路速率来衡量 三种主要类型：内存、总线、互联网 排队(queueing)： 输入排队： 输入端口的综合线路速率大于交换速率 需要缓冲：排队延迟和输入缓冲器溢出造成的损失 阻塞(HOL, Head-Of-the-Line)：排在前面的数据报阻断后面的数据报 输出排队： 交换率大于链路传输速率 需要缓冲：由于输出缓冲区溢出，造成排队延迟和损失 缓冲区管理： 丢弃策略：尾部丢弃，基于优先级的丢弃 标记：ECN，RED Packet Scheduling 先进先出(FIFO, First-In-First-Out) 优先权排队(priority queuing)： 到达时分类 从最高优先级到最低优先级 优先级内的FIFO 循环排队(RR, Round Robin queuing discipline) 到达时分类 通过类循环 依次从每个类中选出一个 加权公平排队(WFQ, Weight Fair Queuing) 广义的Round Robin 每个类别有权重 在每个循环中加权服务量 每个流量类别的最低带宽保证 4.3 The Internet Protocol(IP): IPv4, Addressing, IPv6, and More网际协议IP IPv4 vs IPv6 IPv4 32位地址编码 IPv6 128位地址编码 通过隧道(tunnel)时，IPv6数据报作为IPv4数据报的有效载荷实现共存 IP Addressing： IP地址：与每个主机/路由器接口(interface)相关的32位标识符 接口： 主机/路由器和物理链路之间的连接 接口的数量：路由器通常多个，主机通常一个或两个 有线以太网 无限802.11 点分十进制记法(dotted-decimal notation) 无类别域间路由选择(CIDR, Classless Interdomain Routing) 任意长度的子网地址x，即子网掩码(subnet mask) a.b.c.d/x How to get an IP ? 主机： 硬编码 动态主机配置协议(DHCP, Dynamic Host Configuration)： 主机在加入网络时动态地从DHCP服务器获取一个IP地址 DHCP服务器位于路由器中 地址的重复使用 即插即用协议(plug-and-play protocol) 返回的不仅仅是子网中分配的IP地址 第一跳路由器的地址 DNS服务器的名称和IP地址 子网掩码 子网(subnet) (即网络如何获得其IP地址的子网部分) 从其ISP获得 ISP (即一个ISP如何获得其地址块) 从ICANN Network Address Translation(NAT) 网络地址转换NAT 就外部世界而言，本地网络中的所有设备只共享一个IPv4地址 本地IP地址在3个专用IP地址(private network)范围内 优势 所有设备都有一个来自ISP的IP地址 改变本地地址不需要通知外部世界 改变ISP而不改变本地地址 本地设备不会被外界直接看到，保证安全 实现 (透明) 对发出的数据报： 将 (源IP地址，端口) 替换为 (NAT IP地址，新端口) 远程主机将以 (NAT IP地址，新端口) 作为目的地进行响应 NAT转换表(NAT translation table) 每个 (源IP地址，端口) &lt;-&gt; (NAT IP地址，端口) 对传入的数据报： 用NAT转换表进行反向转换 4.4 Generalized Forwarding and SDNGeneralized Forwarding 通用转发：一张流表(flow table)将基于目的地的转发表一般化 OpenFlow：一个匹配加动作转发抽象的标准 流表：匹配加动作转发表 匹配：入端口、IP源地址、IP目的地址 (允许通配符*) 动作：转发、丢弃、修改字段 Chapter 5 The Network Layer: Control Plane网络层：控制平面 5.1 Introduction构建网络控制平面的两种方法： 每路由器控制(per-router control)：(传统的，分布式) 每个路由器中都有单独的路由算法组件 路由器之间直接互动 逻辑集中式控制(logically centralized/ SDN control) 路由器之间不相互影响 路由算法在两种方法中都是一样的，区别只是如何实现 5.2 Routing Algorithms路由选择算法 Dijkstra’s link state algorithm 链路状态(Link State, LS) 属于集中式路由选择算法(centralized routing algorithm) 必须知道网络中每条链路的开销 Bellman Ford’s (BS) distance vector algorithm 距离向量(Distance Vector, DV) 属于分散式路由选择算法(decentralized routing algorithm) 每个节点维护到网络中所有其他结点的开销(距离)估计的向量 Dijkstra’s Link State Algorithm 集中式 所有节点都知道网络拓扑结构(图) 所有节点都有相同的信息 通过链路状态广播完成 计算从一个节点到所有其他节点的最小成本路径，为该节点生成转发表 迭代(iterative) 经过k次迭代，知道到k个目的地的最低成本路径 算法复杂性: $O(n^2)$ 每次迭代需要检查所有不在N中的节点 有 $O((n+m)logn )$ 的可能，有最小优先级的队列 信息复杂性: $O(n^2)$ 链路状态广播(link state broadcast)：每个路由器必须向所有其他路由器广播链接状态 有效的广播算法：$O(n)$ 个链路交叉点来传播来自一个源的广播消息 每个路由器的消息穿过 $O(n)$​​ 个链接 当链路成本取决于流量时可能出现振荡 Bellman Ford’s Distance Vector Algorithm 分散式(decentralized) 路由器最初只知道连接到邻居的成本 路由选择表(routing table) 迭代的(iterative) 每个节点的行动： 等待触发本地迭代的变化 本地链路成本变化 来自邻居的距离向量更新信息 重新计算本地距离向量 如果变化，发送新的本地距离向量给邻居 异步的(asynchronous) 每个节点的迭代速度可以不同 自我终止的(self stopping) 每个节点只在本地距离向量发生变化时通知其邻居 没有收到通知，不采取任何行动 好消息传得快(链接成本降低)，坏消息传的慢(链接成本增加)：无穷计数(count-to-infinity)问题 算法复杂性：$O(n+m)$ 信息复杂性：(网络直径为 $d$ 的节点) $O(d)$ : 状态信息的扩散 收敛的速度不同导致收敛的时间不同，可能有路由选择环路(routing loop) 和 无穷计数问题 (count-to-infinity) 5.3 Intra-AS Routing in the Internet: OSPF ISP, AS, 域在这里具有相同含义 Autonomous System(AS) 自治系统：将路由器组织进AS 域内路由协议： AS中的所有路由器必须运行相同的域内协议 不同AS种的路由器可以运行不同的域内协议 网关路由器(gateway router)： 域间路由协议： 在AS之间进行路由选择 网关路由器既执行域间路由，也执行域内路由 转发表(Forwarding table)是由域内和域间填充的协议(目的地在AS内: Intra-; 目的地在AS外: Intra- 和 Inter-) OSPF(Open Shortest Path First) 开放最短路优先 最常用的域内路由协议 经典的Dijkstra链路状态算法 每个路由器向AS内所有其他路由器广播选择信息(直接通过IP而非TCP/UDP) 可能有多个指标：带宽、延迟 所有OSPF消息都经过认证以防止恶意入侵 5.4 Routing Among the ISPs: BGP 边界网关协议 (Broder Gateway Protocol, BGP) 既涉及决策，也涉及性能 自治系统间的路由选择协议 (inter- AS routing protocol) BGP为每个AS提供了一种方法来： 从邻近的AS获得可达性信息(eBGP) 将可达性信息传播给AS内的所有路由器(iBGP) BGP会话 两个BGP路由器通过TCP连接交换BGP信息 路径通告：前缀(prefix, CIDR化目标网络) + 属性(BGP attribute) 两个重要的属性： AS-PATH：通告已经通过的AS列表 NEXT-HOP(下一跳)：通往下一跳AS的内部AS路由器 基于策略的路由选择： 是否接受一个路径通告，exp: 永远不通过X的路由 是否发布路径通告，exp: 流量永远不会路由到X Hot Potato Routing 热土豆路由选择：选择域内成本最低的本地网关，不用担心域间成本，即尽可能快地将数据送出 Route-Selection Algorithm 路由器选择算法：当有一条以上的路由可用时 策略决定 最短的AS-PATH 最近的NEXT-HOP路由器(hot potato) 额外标准 5.5 The SDN Control Plane 软件定义网络(Software Defined Networking, SDN) Why a logically centralized control plane? 更容易管理 基于表的转发 (OpenFlow API) 允许对路由器进行编程 集中式编程更容易：集中计算表并分发 开放的实现 促进创新 Chapter 6 The Link Layer and LANs链路层和局域网 6.1 Introduction to the Link Layer 发送方： 将网络层的数据报封装成帧(Frame) 接收方 从帧中提取数据报，传递给网络层 链路层信道： 广播信道：有线局域网、卫星网、HFC 点对点通信链路：点对点协议(PPP, Point-to-Point Protocol) The Services Provided by the Link Layer 成帧(framing) 链路接入(link access)：媒体访问控制(MAC, Media Access Control)协议规定了帧在链路上的传输规则 可靠交付(Reliable delivery)：无差错地经链路层移动每个网络层数据报 差错检测和纠正(Error detection and correction) Where Is the Link Layer Implemented? 网络适配器(network adapter)，也称网卡(Network Interface Card , NIC) 6.2 Error-Detection and -Correction Techniques 奇偶校验(Parity Checks) 前向纠错(Forward Error Correction, FEC)：接收方检测和纠正差错的能力 检验和(Checksumming) 循环冗余检测(CRC, Cyclic Redundancy Check) 多项式编码(polynomial code) 生成多项式(generator) 6.3 Multiple Access Links and Protocols 多路访问链路和协议 信道划分协议(Channel Partitioning Protocols)： TDM（时分多路复用） FDM（频分多路复用） CDMA (码分多址, Code Divison Multiple Access) 随机接入协议(Random Access Protocols) Slotted ALOHA（时隙ALOHA） ALOHA CSMA（载波侦听多路访问） CSMA/CD（具有碰撞检测的载波侦听多路访问） 轮流协议(Taking-Turns Protocols) 轮询协议(polling protocol) 令牌传递协议(token-passing protocol) DOCSIS：用于电缆因特网接入的链路层协议 6.4 Switched Local Area NetworksLink-Layer Addressing and ARP MAC Addresses(物理地址) 长度6字节，2^48个可能的MAC地址 MAC广播地址(broadcast address)：FF-FF-FF-FF-FF-FF ARP(地址解析协议, Address Resolution Protocol) 在IP地址和MAC地址间进行转换 Ethernet Frame Link-Layer Switches 链路层交换机： 交换机表(switch table)：(MAC地址，通向该MAC地址的交换机接口，时间) 自学习(self-learning) 即插即用设备(plug-and-play device) Switches vs Routers 交换机是第二层的分组交换机，路由器是第三层的分组交换机 交换机即插即用，但对于广播风暴(broadcast storms)没有保护措施 路由器和连接到他们的主机需要人为配置IP地址，路由器对第二层的广播风暴提供了防火墙保护(firewall protections) 交换机，路由器和主机中的数据包处理 Virtual Local Area Networks (VLANs) 虚拟局域网的作用：流量隔离(traffic isolation)，管理用户(managing users) Chapter 7 Wireless and Mobile Networks无线网络和移动网络 7.1 Introduction 无线主机(wireless host)：主机本身可能移动也可能不移动 无线链路(wireless communication link)：主机通过无线线路连接到一个基站或者另一台无线主机 基站(base station)：exp: 蜂窝塔(cell tower)，802.11无线LAN中的接入点(access point) 7.2 Wireless Links and Network Characteristicswire link vs wireless link 路径损耗(path loss)：信号强度递减 来自其他源的干扰 多径传播(multipath propagation)：电磁波的一部分受反射在发送方和接收方间走了不同长度的路径 Signal-to-Noise Ratio(SNR) 信噪比(SNR)：所受到的信号和噪声强度的相对测量 比特差错率(BER)：接收方收到的有错传输的比特的概率 给定调制方案，SNR越高BER越低 给定SNR，就要较高比特传输率的调制技术将具有较高的BER 物理层调制技术的动态选择能用于适配对信道条件的调制技术 7.3 WiFi: 802.11 Wireless LANsThe 802.11 Architecture 速率适应(Rate Adaptation)，功率管理(Power Management) 基本构建模块：基本服务集(Basic Service Set, BSS) BSS：一个/多个无线站点，一个接入点(Access Point, AP)的中央基站(base station) Channels and Association exp: 你携带移动设备进入WiFi丛林，找无线因特网接入，设在丛林中有5个AP，为获得因特网接入你的无线站点应加入其中一个子网故需与其中一个AP相关联(associate)，即建立一条虚拟线路 The 802.11 MAC Protocol 随机访问协议：带碰撞避免的CSMA(CSMA with collision avoidance)，CSMA/CA，类比以太网的CSMA/CD 处理隐藏终端：RTS(短请求发送，Reqeust to Send), CTS(允许发送，Clear to Send) The IEEE 802.11 Frame","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://maskros.top/tags/ComputerNetwork/"}]},{"title":"Trie专题训练","slug":"algorithm/exercise/trie_problem","date":"2021-11-27T04:20:00.000Z","updated":"2022-01-22T09:37:15.580Z","comments":true,"path":"/post/algorithm/exercise/trie_problem.html","link":"","permalink":"https://maskros.top/post/algorithm/exercise/trie_problem.html","excerpt":"Trie training","text":"Trie 专题训练0.0 0x01 统计难题 HDU 1251 link 题意：给了一堆字符串，统计以模式串作前缀出现的单词个数 trie入门题，存结点时统计一下过当前结点的单词个数即可 &#x2F;&#x2F;对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树 &#x2F;&#x2F;很多题都是要用到节点下标来表示某个字符串 const int maxn &#x3D; 2e6 + 5; &#x2F;&#x2F;如果是64MB可以开到2e6+5，尽量开大 int tree[maxn][30]; &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号 bool flagg[maxn]; &#x2F;&#x2F;表示以该节点结尾是一个单词 int tot; &#x2F;&#x2F;总节点数 int cnt[maxn]; void insert_(char* str) &#123; int len &#x3D; strlen(str); int root &#x3D; 0; for (int i &#x3D; 0; i &lt; len; i++) &#123; int id &#x3D; str[i] - &#39;a&#39;; if (!tree[root][id]) tree[root][id] &#x3D; ++tot; root &#x3D; tree[root][id]; cnt[root]++; &#125; flagg[root] &#x3D; true; &#125; bool find_(char* str) &#123; &#x2F;&#x2F;查询操作，按具体要求改动 int len &#x3D; strlen(str); int root &#x3D; 0; int ans; for (int i &#x3D; 0; i &lt; len; i++) &#123; int id &#x3D; str[i] - &#39;a&#39;; if (!tree[root][id]) return false; root &#x3D; tree[root][id]; &#x2F;&#x2F; if(!flagg[root] &amp;&amp; i&#x3D;&#x3D;len-1) return false; &#x2F;&#x2F;判断是否两个单词完全匹配 &#125; ans &#x3D; cnt[root]; cout&lt;&lt;ans&lt;&lt;endl; return true; &#125; void init() &#123; &#x2F;&#x2F;最后清空，节省时间 for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123; flagg[i] &#x3D; false; for (int j &#x3D; 0; j &lt; 10; j++) tree[i][j] &#x3D; 0; &#125; memset(cnt,0,sizeof(cnt)); tot &#x3D; 0; &#x2F;&#x2F;RE有可能是这里的问题 &#125; void solve() &#123; char str[15]; init(); while(gets(str)&amp;&amp;str[0]!&#x3D;&#39;\\0&#39;)&#123; insert_(str); &#125; while(gets(str)&amp;&amp;str[0]!&#x3D;EOF)&#123; bool t &#x3D; find_(str); if(!t) cout&lt;&lt;0&lt;&lt;endl; &#125; &#125; 0x02 Remember the Word LA 3942 link 题意： 给出一个由S个不同单词组成的字典和一个长字符串，把这个字符串分解成若干个单词的连接(可重复使用)，有多少种方法。ex: 有四个单词：a, b, cd, ab；则abcd有两种分解方法：a+b+cd 和 ab+cd 思路： dp + Trie 计数问题考虑dp： 考虑状态：dp[i] 为以i开始的后缀的方案数 考虑转移：因为单词长度不大于100，我们可以直接暴力向后看当前单词是否存在，所以可以用Trie或者字符串哈希完成 令dp(i)表示从字符i开始的字符串，dp(i)=sum{dp(i+len(x))}, x是s[i…L]的前缀。然后把所有可分解成的单词构造成一颗Trie树，再让母串在上面跑，dp[0]即是方案总数。 #include &lt;bits&#x2F;stdc++.h&gt; #define maxn 300005 #define mod 20071027 char P[maxn]; #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt;&#x3D; y; i--) using namespace std; int dp[maxn]; &#x2F;&#x2F;dp[i] 为以i开始的后缀的方案数 int tree[maxn][30]; &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号 bool flagg[maxn]; &#x2F;&#x2F;表示以该节点结尾是一个单词 int tot; &#x2F;&#x2F;总节点数 int m; &#x2F;&#x2F;主串长度 void insert_(char* str) &#123; int len &#x3D; strlen(str); int root &#x3D; 0; for (int i &#x3D; 0; i &lt; len; i++) &#123; int id &#x3D; str[i] - &#39;a&#39;; if (!tree[root][id]) tree[root][id] &#x3D; ++tot; root &#x3D; tree[root][id]; &#125; flagg[root] &#x3D; true; &#125; void find_(int id) &#123; &#x2F;&#x2F;查询操作，按具体要求改动 int root &#x3D; 0; for (int i &#x3D; id; i &lt;&#x3D; m; i++) &#123; int k &#x3D; P[i] - &#39;a&#39;; if (!tree[root][k]) break; root &#x3D; tree[root][k]; if (flagg[root]) dp[id] &#x3D; (dp[id] + dp[i + 1]) % mod; &#125; &#125; void init() &#123; for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123; flagg[i] &#x3D; false; for (int j &#x3D; 0; j &lt; 30; j++) tree[i][j] &#x3D; 0; &#125; memset(dp, 0, sizeof(dp)); tot &#x3D; 0; &#125; char c[105]; int main() &#123; long long times &#x3D; 0; init(); while (scanf(&quot;%s&quot;, P)!&#x3D;EOF) &#123; times++; int S; cin &gt;&gt; S; &#x2F;&#x2F; init(); rep(i, 0, S) &#123; scanf(&quot;%s&quot;, c); insert_(c); &#125; m &#x3D; strlen(P); dp[m] &#x3D; 1; red(i, m, 0) &#123; find_(i); &#125; cout &lt;&lt; &quot;Case &quot; &lt;&lt; times &lt;&lt; &quot;: &quot; &lt;&lt; dp[0] &lt;&lt; endl; init(); &#125; &#125; 0x03 “strcmp()” Anyone? link 题意： 输入n个字符串，两两调用一次strcmp()，问字符比较的总次数是多少？ex: strcmp(“than”, &quot;that&quot;)：cnt = 7 题解：两个字符串比较次数其实是 相同字符数*2 + (存在不同字符? 1 : 0)；然后建字典树，dfs一下即可。因为节点的个数比较多，所以用左孩子右兄弟的方法建立字典树。 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxnode &#x3D; 4000 * 1000 + 10; const int sigma_size &#x3D; 26; &#x2F;&#x2F; 字母表为全体小写字母的Trie struct Trie &#123; int head[maxnode]; &#x2F;&#x2F; head[i]为第i个结点的左儿子编号 int next[maxnode]; &#x2F;&#x2F; next[i]为第i个结点的右兄弟编号 char ch[maxnode]; &#x2F;&#x2F; ch[i]为第i个结点上的字符 int tot[maxnode]; &#x2F;&#x2F; tot[i]为第i个结点为根的子树包含的叶结点总数 int sz; &#x2F;&#x2F; 结点总数 long long ans; &#x2F;&#x2F; 答案 void clear() &#123; sz &#x3D; 1; tot[0] &#x3D; head[0] &#x3D; next[0] &#x3D; 0; &#125; &#x2F;&#x2F; 初始时只有一个根结点 &#x2F;&#x2F; 插入字符串s（包括最后的&#39;\\0&#39;），沿途更新tot void insert(const char* s) &#123; int u &#x3D; 0, v, n &#x3D; strlen(s); tot[0]++; for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123; &#x2F;&#x2F; 找字符a[i] bool found &#x3D; false; for (v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) if (ch[v] &#x3D;&#x3D; s[i]) &#123; &#x2F;&#x2F; 找到了 found &#x3D; true; break; &#125; if (!found) &#123; v &#x3D; sz++; &#x2F;&#x2F; 新建结点 tot[v] &#x3D; 0; ch[v] &#x3D; s[i]; next[v] &#x3D; head[u]; head[u] &#x3D; v; &#x2F;&#x2F; 插入到链表的首部 head[v] &#x3D; 0; &#125; u &#x3D; v; tot[u]++; &#125; &#125; &#x2F;&#x2F; 统计LCP&#x3D;u的所有单词两两的比较次数之和 void dfs(int depth, int u) &#123; if (head[u] &#x3D;&#x3D; 0) &#x2F;&#x2F; 叶结点 ans +&#x3D; tot[u] * (tot[u] - 1) * depth; else &#123; int sum &#x3D; 0; for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) sum +&#x3D; tot[v] * (tot[u] - tot[v]); &#x2F;&#x2F; 子树v中选一个串，其他子树中再选一个 ans +&#x3D; sum &#x2F; 2 * (2 * depth + 1); &#x2F;&#x2F; 除以2是每种选法统计了两次 for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) dfs(depth + 1, v); &#125; &#125; &#x2F;&#x2F; 统计 long long count() &#123; ans &#x3D; 0; dfs(0, 0); return ans; &#125; &#125;; const int maxl &#x3D; 1000 + 10; &#x2F;&#x2F; 每个单词最大长度 int n; char word[maxl]; Trie trie; int main() &#123; int kase &#x3D; 1; while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123; trie.clear(); for (int i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, word); trie.insert(word); &#125; printf(&quot;Case %d: %lld\\n&quot;, kase++, trie.count()); &#125; return 0; &#125;","categories":[{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"Trie","slug":"Trie","permalink":"https://maskros.top/tags/Trie/"},{"name":"dfs","slug":"dfs","permalink":"https://maskros.top/tags/dfs/"}]},{"title":"Trie","slug":"algorithm/learn/trie","date":"2021-11-27T03:55:50.000Z","updated":"2022-01-22T09:37:06.172Z","comments":true,"path":"/post/algorithm/learn/trie.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/trie.html","excerpt":"Trie","text":"Trie字典树/前缀树 什么是Trie 从根节点到每个单词结点的路径上所有字母连接成的字符串就是该结点对应的字符串 多叉树，最大分支数由字典的字符集含有的字符数决定 操作 插入字符串 insert 初始化 root = 0 , 遍历字符串, 对于其每一个字符, 计算其映射值 id 检查Trie[root][id] == 0 是否成立： 若成立, 则进行插入, Trie[root][id] = ++cnt 若不成立,说明该位置已经有该字符,直接找到下一个字符应插入的位置: root = trie[root][id]. 重复上述步骤,直到字符串完全插入Trie树. 匹配字符串 search 初始化root = 0,遍历字符串,对于其每一个字符,计算其映射值id 检查Trie[root][id] == 0是否成立： 若成立, 则说明Trie树当前路径不存在该字符,返回匹配失败 若不成立,则说明当前路径存在该字符,找到下一个字符的位置: root = trie[root][id] 重复上述步骤，若顺利匹配完整个字符串,则应该检查字符串结束的位置在Trie树中是否是结束标志，flag[root] == true成立,表明是结束标志,则返回匹配成功,否则返回匹配失败 模板 附：字符数组操作 char s1[maxn], s2[maxn]; strcpy(s1, s2); &#x2F;&#x2F;复制字符串 s2 到字符串 s1。 strcat(s1, s2); &#x2F;&#x2F;连接字符串 s2 到字符串 s1 的末尾。 strlen(s1); &#x2F;&#x2F;返回字符串 s1 的长度。 strcmp(s1, s2); &#x2F;&#x2F;如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 strchr(s1, ch); &#x2F;&#x2F;返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2); &#x2F;&#x2F;返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 模拟 对结构体Trie进行插入和查询操作 val[i] &gt; 0 表示这是一个单词结点 #define maxn 41000 #define sigmasize 26 &#x2F;&#x2F; 字符集的大小 ex: 全体小写字母：26 struct Trie&#123; int ch[maxn][sigmasize]; int val[maxn]; &#x2F;&#x2F; 结点i对应的附加信息，如每个字符串的权值, 如val[i]&gt;0 当且仅当结点i是单词结点 int sz; &#x2F;&#x2F; 结点总数 Trie() &#123; sz &#x3D; 1; memset(ch[0], 0, sizeof(ch[0]));&#125; &#x2F;&#x2F;初始只有一个根节点 int idx(char c) &#123; return c - &#39;a&#39;; &#125; &#x2F;&#x2F;字符c的编号 &#x2F;&#x2F; 插入字符串s, 附加信息为v。v必须非0, 0 代表“本结点不是单词结点” inline void insert(char *s, int v) &#123; int u &#x3D; 0, n &#x3D; strlen(s); for (int i &#x3D; 0; i &lt; n; i++) &#123; int c &#x3D; idx(s[i]); if (!ch[u][c]) &#123; &#x2F;&#x2F;结点不存在 memset(ch[sz], 0, sizeof(ch[sz])); val[sz] &#x3D; 0; &#x2F;&#x2F;中间节点的附加信息为0 ch[u][c] &#x3D; sz++; &#x2F;&#x2F;新建节点 &#125; u &#x3D; ch[u][c]; &#x2F;&#x2F;往下走 &#125; val[u] &#x3D; v; &#x2F;&#x2F;字符串的最后一个字符的附加信息为v &#125; &#x2F;&#x2F; 查找字符串s inline bool search(char *s) &#123; int u &#x3D; 0, n &#x3D; strlen(s); for (int i &#x3D; 0; i &lt; n; i++) &#123; int c &#x3D; idx(s[i]); if (ch[u][c] &#x3D;&#x3D; 0) return false; u &#x3D; ch[u][c]; &#125; if (val[u] &#x3D;&#x3D; 0) return false; return true; &#125; &#125;trie; 版本2 可以用 find(str) 判断字典树中是否有以 str 作前缀的单词 //对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树 //很多题都是要用到节点下标来表示某个字符串 const int maxn = 2e6 + 5; //如果是64MB可以开到2e6+5，尽量开大 int tree[maxn][30]; //tree[i][j]表示节点i的第j个儿子的节点编号 bool flagg[maxn]; //表示以该节点结尾是一个单词 int tot; //总节点数 void insert_(char* str) &#123; int len = strlen(str); int root = 0; for (int i = 0; i &lt; len; i++) &#123; int id = str[i] - 'a'; if (!tree[root][id]) tree[root][id] = ++tot; root = tree[root][id]; &#125; flagg[root] = true; &#125; bool find_(char* str)&#123; //查询操作，按具体要求改动 int len = strlen(str); int root = 0; for (int i = 0; i &lt; len; i++) &#123; int id = str[i] - 'a'; if (!tree[root][id]) return false; root = tree[root][id]; if(!flagg[root] &amp;&amp; i==len-1) return false; //判断是否两个单词完全匹配 &#125; return true; &#125; void init()&#123; for (int i = 0; i &lt;= tot; i++) &#123; flagg[i] = false; for (int j = 0; j &lt; 30; j++) tree[i][j] = 0; &#125; tot = 0; //RE有可能是这里的问题 &#125; 优化trie树 当结点比较多，sigma_size比较大的时候，采用左儿子-右兄弟建立trie struct Trie &#123; int head[maxn]; &#x2F;&#x2F; head[i]为第i个结点的左儿子编号 int next[maxn]; &#x2F;&#x2F; next[i]为第i个结点的右兄弟编号 char ch[maxn]; &#x2F;&#x2F; ch[i]为第i个结点上的字符 int sz; &#x2F;&#x2F; 结点总数 void clear() &#123; sz &#x3D; 1; tot[0] &#x3D; head[0] &#x3D; next[0] &#x3D; 0; &#125; void insert(const char* s) &#123; int u &#x3D; 0, v, n &#x3D; strlen(s); tot[0]++; for (int i &#x3D; 0; i &lt; n; i++) &#123; bool found &#x3D; false; for (v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v]) if (ch[v] &#x3D;&#x3D; s[i]) &#123; found &#x3D; true; break; &#125; if (!found) &#123; v &#x3D; sz++; tot[v] &#x3D; 0; ch[v] &#x3D; s[i]; next[v] &#x3D; head[u]; head[u] &#x3D; v; head[v] &#x3D; 0; &#125; u &#x3D; v; tot[u]++; &#125; &#125; &#125;; 题单solution 0x01 统计难题 HDU 1251 link 0x02 背单词 LA 3942 link 0x03 strcmp()函数 UVa 11732 link 假如再来一遍银川","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"Trie","slug":"Trie","permalink":"https://maskros.top/tags/Trie/"}]},{"title":"kmp专题训练","slug":"algorithm/exercise/kmp_problem","date":"2021-11-26T13:59:50.000Z","updated":"2021-11-27T04:15:38.843Z","comments":true,"path":"/post/algorithm/exercise/kmp_problem.html","link":"","permalink":"https://maskros.top/post/algorithm/exercise/kmp_problem.html","excerpt":"kmp training","text":"kmp/ekmp 专题训练 🐴糙人蠢凑合看 0x01 剪花布条 HDU-2087 link 纯纯kmp裸题，不可重叠计数 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; void kmp_pre(string p, int next[]) &#123; int i, j; j &#x3D; next[0] &#x3D; -1; i &#x3D; 0; while (i &lt; p.length()) &#123; while (-1 !&#x3D; j &amp;&amp; p[i] !&#x3D; p[j]) j &#x3D; next[j]; next[++i] &#x3D; ++j; &#125; &#125; int kmp_Count(string x, string y, int next[]) &#123; int i, j; int ans &#x3D; 0; kmp_pre(x, next); i &#x3D; j &#x3D; 0; while (i &lt; y.length()) &#123; while (-1 !&#x3D; j &amp;&amp; y[i] !&#x3D; x[j]) j &#x3D; next[j]; i++; j++; if (j &gt;&#x3D; x.length()) &#123; ans++; j &#x3D; 0; &#x2F;&#x2F;不可重叠计数 &#125; &#125; return ans; &#125; int main()&#123; string a,b; int nxt[1005]; while(1)&#123; cin&gt;&gt;a; if(a&#x3D;&#x3D;&quot;#&quot;) break; else&#123; cin&gt;&gt;b; memset(nxt,0,b.length()+1); int ans&#x3D;kmp_Count(b,a,nxt); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; &#125; 0x02 Secret HDU-6153 link 题意： 给两个串s1,s2，求s2所有的后缀子串的长度乘在主串s1中出现的次数之和 解法： 挨个枚举后缀是🐷b做法，我们可以先把字符串翻转，这样后缀变前缀，就来到了我们熟悉的kmp匹配环节 解法一：exkmp 翻转后发现这不就正好利用extend[]数组的定义直接求解，做一遍ekmp，遍历extend[]数组，对每个值做 (1+entend[i])*entend[i]&gt;&gt;1 处理，全部加和即为答案 解法二：kmp 利用对next[]数组的理解，暂时鸽了，因为想了很久没想明白 解法一： ekmp 猛wa之后给了我深刻的教训：数组开 longlong😅😅 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; const int mod &#x3D; 1000000007; #define ll long long #define maxn 1000005 #define rep(i,x,y) for(int i&#x3D;x;i&lt;y;i++) ll nxt[maxn], extend[maxn]; void ekmp_pre(string x, ll next[]) &#123; int m &#x3D; x.length(); next[0] &#x3D; m; int j &#x3D; 0; while (j + 1 &lt; m &amp;&amp; x[j] &#x3D;&#x3D; x[j + 1]) j++; next[1] &#x3D; j; int k &#x3D; 1; for (int i &#x3D; 2; i &lt; m; i++) &#123; int p &#x3D; next[k] + k - 1; int L &#x3D; next[i - k]; if (i + L &lt; p + 1) next[i] &#x3D; L; else &#123; j &#x3D; max(0, p - i + 1); while (i + j &lt; m &amp;&amp; x[i + j] &#x3D;&#x3D; x[j]) j++; next[i] &#x3D; j; k &#x3D; i; &#125; &#125; &#125; ll ekmp(string x, string y, ll next[], ll extend[]) &#123; ekmp_pre(x, next); int j &#x3D; 0; ll ret &#x3D; 0; int m &#x3D; x.length(), n &#x3D; y.length(); while (j &lt; n &amp;&amp; j &lt; m &amp;&amp; x[j] &#x3D;&#x3D; y[j]) j++; extend[0] &#x3D; j; int k &#x3D; 0; for (int i &#x3D; 1; i &lt; n; i++) &#123; int p &#x3D; extend[k] + k - 1; int L &#x3D; next[i - k]; if (i + L &lt; p + 1) extend[i] &#x3D; L; else &#123; j &#x3D; max(0, p - i + 1); while (i + j &lt; n &amp;&amp; j &lt; m &amp;&amp; y[i + j] &#x3D;&#x3D; x[j]) j++; extend[i] &#x3D; j; k &#x3D; i; &#125; &#125; rep(i, 0, n) &#123; ret &#x3D; (ret % mod + (((1 + extend[i])* extend[i])&gt;&gt;1) % mod) % mod; &#125; return ret; &#125; int main() &#123; int t; ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; reverse(s.begin(), s.end()); reverse(p.begin(), p.end()); memset(nxt, 0, p.length() + 1); memset(extend, 0, s.length() + 1); ll ans; ans&#x3D;ekmp(p, s, nxt, extend); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; 解法二：kmp &#x2F;&#x2F; 寄 0x03 Cow Patterns POJ-3167 link 牛题 题意： 模式串可以浮动的模式匹配问题 给出模式串的相对大小顺序，需要找出在主串中模式串的匹配次数和起始位置 样例： S: 5 6 2 10 10 7 3 2 9 P: 1 4 4 3 2 1 故 2 10 10 7 3 2 符合要求，输出为 1 3 解法： KMP+前缀和 统计比当前数小，和于当前数相等的，然后进行kmp &#x2F;&#x2F;POJ 3167 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; const int MAXN &#x3D; 100005; const int MAXM &#x3D; 25005; int a[MAXN]; &#x2F;&#x2F; 存放主串 int b[MAXM]; &#x2F;&#x2F; 存放模式串 int as[MAXN][30]; &#x2F;&#x2F; as[i][j] &#x3D; k表示0 - i位中有k个数字j int bs[MAXM][30]; &#x2F;&#x2F; bs[i][j] &#x3D; k表示0 - i位中有k个数字j int next[MAXM]; &#x2F;&#x2F; 存放模式串失配时的移动位数 vector&lt;int&gt; ans; &#x2F;&#x2F; 存放结果 int n, m, s; void Init() &#123; ans.clear(); memset(as, 0, sizeof(as)); memset(bs, 0, sizeof(bs)); as[1][a[1]] &#x3D; 1; bs[1][b[1]] &#x3D; 1; for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123; memcpy(as[i], as[i - 1], sizeof(as[0])); ++as[i][a[i]]; &#125; for (int i &#x3D; 2; i &lt;&#x3D; m; ++i) &#123; memcpy(bs[i], bs[i - 1], sizeof(bs[0])); ++bs[i][b[i]]; &#125; &#125; void GetNext() &#123; memset(next, 0, sizeof(next)); int i &#x3D; 1, j &#x3D; 0, k &#x3D; 0; next[1] &#x3D; 0; while (i &lt;&#x3D; m) &#123; int si &#x3D; 0, sj &#x3D; 0, ei &#x3D; 0, ej &#x3D; 0; for (k &#x3D; 1; k &lt; b[i]; ++k) si +&#x3D; bs[i][k] - bs[i - j][k]; ei &#x3D; bs[i][k] - bs[i - j][k]; for (k &#x3D; 1; k &lt; b[j]; ++k) sj +&#x3D; bs[j][k]; ej &#x3D; bs[j][k]; if (0 &#x3D;&#x3D; j || (si &#x3D;&#x3D; sj &amp;&amp; ei &#x3D;&#x3D; ej)) next[++i] &#x3D; ++j; else j &#x3D; next[j]; &#125; &#125; void Kmp() &#123; int i &#x3D; 1, j &#x3D; 1, k &#x3D; 1; while (i &lt;&#x3D; n) &#123; int si &#x3D; 0, sj &#x3D; 0, ei &#x3D; 0, ej &#x3D; 0; for (k &#x3D; 1; k &lt; a[i]; ++k) si +&#x3D; as[i][k] - as[i - j][k]; ei &#x3D; as[i][k] - as[i - j][k]; for (k &#x3D; 1; k &lt; b[j]; ++k) sj +&#x3D; bs[j][k]; ej &#x3D; bs[j][k]; if (0 &#x3D;&#x3D; j || (si &#x3D;&#x3D; sj &amp;&amp; ei &#x3D;&#x3D; ej)) ++i, ++j; else j &#x3D; next[j]; if (j &#x3D;&#x3D; m + 1) &#123; ans.push_back(i - m); j &#x3D; next[j]; &#125; &#125; &#125; int main() &#123; while (scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s) &#x3D;&#x3D; 3) &#123; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) scanf(&quot;%d&quot;, &amp;b[i]); Init(); GetNext(); Kmp(); size_t len &#x3D; ans.size(); printf(&quot;%d\\n&quot;, len); for (size_t i &#x3D; 0; i &lt; len; ++i) printf(&quot;%d\\n&quot;, ans[i]); &#125; return 0; &#125;","categories":[{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"kmp","slug":"kmp","permalink":"https://maskros.top/tags/kmp/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"2021CCPC广州站vp","slug":"xcpc/2021ccpc_guangzhou","date":"2021-11-24T16:42:00.000Z","updated":"2022-01-25T07:51:49.608Z","comments":true,"path":"/post/xcpc/2021ccpc_guangzhou.html","link":"","permalink":"https://maskros.top/post/xcpc/2021ccpc_guangzhou.html","excerpt":"2021CCPC桂林站vp","text":"2021CCPC广州站vp “如何解方程” C_Necklace 二分+贪心 读题比较关键 没改明白wa3 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n')#include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (ll i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 1000005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; ll M,N; ll pos[maxn]; bool check(ll x)&#123; ll last=0,tmp,end; end=N-pos[M-1]+pos[0]; rep(i,0,M)&#123; if(i==0)&#123; if(end&lt;=x) &#123;last=end; end=0; continue;&#125; else&#123; end-=x; last=x; continue;&#125; &#125;eif(i==M-1) tmp=end+pos[i]-pos[i-1]; else tmp=pos[i]-pos[i-1]; ll can=pos[i]-pos[i-1]-1; can=(can>0)?can:0; ll sub=(x-last>can)?can:(x-last); if(tmp>=sub) tmp-=sub; else tmp=0; if(tmp&lt;=x) last=tmp; else return 0; &#125; return 1; &#125; void solve() &#123; // N=read(); M=read(); cin>>N>>M; ll ans=1,tmp,last=1; rep(i,0,M)&#123; cin>>pos[i]; &#125; if(M==1) &#123;cout&lt;&lt;N; return;&#125; ll l=1,r=N; while(l&lt;=r)&#123; ll mid=(l+r)>>1; if(check(mid))&#123; ans=mid; r=mid-1; &#125;else&#123; l=mid+1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; int main() &#123; int T = 1; IOS; // cin >> T; while (T--) &#123; solve(); &#125; &#125; H_Three Intergers (数学) 题意：给a,b,c，求满足x%y=a, y%z=b, z%x=c 的任意一组x,y,z 思路：数学题，方程化简，根据条件直接造，起初忘记了模的性质导致解不出方程，看了题解恍然大悟 题解 #include &lt;bits/stdc++.h> using namespace std; typedef long long ll; int main() &#123; ios::sync_with_stdio(false); int T; cin >> T; while (T--) &#123; int a, b, c; cin >> a >> b >> c; if (a == b &amp;&amp; b == c) &#123; if (!a) &#123; cout &lt;&lt; \"YES\\n\"; cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; 1 &lt;&lt; \"\\n\"; &#125; else cout &lt;&lt; \"NO\\n\"; continue; &#125; ll x, y, z, k; if (b > a) &#123; k = max(0, (c - a) / b) + 1; x = k * b + a; y = b; z = (k * b + a) * 2 + c; &#125; else if (a > c) &#123; k = max(0, (b - c) / a) + 1; x = a; y = (k * a + c) * 2 + b; z = k * a + c; &#125; else if (c > b) &#123; k = max(0, (a - b) / c) + 1; x = (k * c + b) * 2 + a; y = k * c + b; z = c; &#125; else assert(false); cout &lt;&lt; \"YES\\n\"; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; \"\\n\"; assert(x % y == a &amp;&amp; y % z == b &amp;&amp; z % x == c); assert(x &lt;= 1e18); assert(y &lt;= 1e18); assert(z &lt;= 1e18); &#125; return 0; &#125; I_Pudding Store （打表） 手算了一下太麻烦，全排列打表找规律即可 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> #define mod 998244353 using namespace std; // 1 2 6 12 24 48 96 192 384 768 // int a[50]; // void init(int n)&#123; // rep(i,1,n+1) a[i]=i; // &#125; // void dfs()&#123; // rep(i,1,11)&#123; // ll cnt=0; // init(i); // bool t=true; // while(t)&#123; // bool can=false; // rep(j,1,i+1)&#123; // ll fuck=0; // rep(k,1,j+1)&#123; // fuck+=a[k]; // &#125; // fuck*=2; // if(fuck%j==0) can=true; // else &#123;can=false; break;&#125; // &#125; // if(can) cnt++; // t=next_permutation(a+1,a+i+1); // &#125; // cout&lt;&lt;cnt&lt;&lt;\" \"; // &#125; // &#125; ll qpow(ll a, ll b)&#123; ll ans=1; ll res=a; res%=mod; while(b)&#123;if(b&amp;1) ans=ans*res%mod; b>>=1; res=res*res%mod;&#125; return ans%mod; &#125; void solve() &#123; int n; cin>>n; if(n==1) cout&lt;&lt;1&lt;&lt;endl; eif(n==2) cout&lt;&lt;2&lt;&lt;endl; eif(n==3) cout&lt;&lt;6&lt;&lt;endl; else&#123; ll tmp=6; ll add=qpow(2,n-3); tmp=add%mod*tmp%mod; cout&lt;&lt;tmp&lt;&lt;endl; &#125; &#125; int main() &#123; int T = 1; IOS; // dfs(); cin >> T; while (T--) &#123; solve(); &#125; &#125; 总结：什么时候才能不粗心","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"打表","slug":"打表","permalink":"https://maskros.top/tags/%E6%89%93%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"贪心","slug":"贪心","permalink":"https://maskros.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"2021CCPC桂林站vp","slug":"xcpc/2021ccpc_guilin","date":"2021-11-23T16:03:00.000Z","updated":"2022-01-25T07:52:52.927Z","comments":true,"path":"/post/xcpc/2021ccpc_guilin.html","link":"","permalink":"https://maskros.top/post/xcpc/2021ccpc_guilin.html","excerpt":"2021CCPC桂林站vp","text":"2021CCPC桂林站vp ”祭奠擦肩而过的桂林两日游“ A_Hero Named Magnus 水题。为什么不ban猛犸？输出2n-1 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; ll x; cin>>x; ll ans; ans=x*2-1; cout&lt;&lt;ans&lt;&lt;endl; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; D_Assumption is All You Need 构造题 题意：给你两个序列A，B，对A可执行操作：若 iAj，可将Ai与Aj交换，问能否通过合法的操作将A变成B，并打印操作序列 思路：从屁股往前扫一遍，如果Ai和Bi不一样，就从A[Bi_pos]往前扫，寻求最优解，瞎JB贪心，wa2待补 E_Buy and Delete (图论) 题意：给了你一些带权有向边，Alice可以用已有的c元钱购买一些边形成一张有向图；随后Bob进行删边，每次可以删除一个无环的子集，Alice想最大化删边次数，Bob想最小化，二者都采取最优操作，问Bob需要删除几次 思路：答案只可能是0,1,2，0的情况是Alice一条边都买不起，1的情况是Alice买的无环图，2的情况是Alice买的带环图，无论有几个环，Bob都只需要删两次就够了，这个比较容易理解。 解法：直接把所有边存到一个有向图里，做Dijkstra找从v-&gt;v 的最短路，判断买不买得起就可以了 ps: 开始犯病用 n2 的Dij结果T了，换了 nlogn 的堆优化Dij就不T了；然后还在想改造一下Dij让起点为 i 的dist数组可以存 dist[i]，结果想了想直接Dij完了之后dist[j] + mincost[j][i] 不就是环的长度吗，wssb #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 1000000001 #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 2005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int n, m, c; struct qnode&#123; int v,c; qnode(int _v=0,int _c=0):v(_v),c(_c)&#123;&#125; bool operator &lt;(const qnode &amp;r)const&#123; return c>r.c; &#125; &#125;; struct Edge&#123; int v,cost; Edge(int _v=0,int _cost=0):v(_v),cost(_cost)&#123;&#125; &#125;; vector&lt;Edge>E[maxn]; bool vis[maxn]; int dist[maxn]; int mincost[maxn][maxn]; void Dijkstra(int start)&#123; memset(vis,false,sizeof(vis)); for(int i=1;i&lt;=n;i++)dist[i]=INF; priority_queue&lt;qnode>que; while(!que.empty()) que.pop(); dist[start]=0; que.push(qnode(start,0)); qnode tmp; while(!que.empty())&#123; tmp=que.top(); que.pop(); int u=tmp.v; if(vis[u])continue; vis[u]=true; for(int i=0;i&lt;E[u].size();i++)&#123; int v=E[tmp.v][i].v; int cost=E[u][i].cost; if(!vis[v]&amp;&amp;dist[v]>dist[u]+cost)&#123; dist[v]=dist[u]+cost; que.push(qnode(v,dist[v])); &#125; &#125; &#125; &#125; void addedge(int u,int v,int w)&#123; E[u].push_back(Edge(v,w)); &#125; int main() &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;c); int mncost=INF; int u, v, p; rep(i,1,n+1) rep(j,1,n+1) mincost[i][j]=INF; rep(i,0,m)&#123; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;p); addedge(u,v,p); mincost[u][v]=min(mincost[u][v],p); mncost=min(mncost,p); &#125; if(mncost>c)&#123; cout&lt;&lt;0; return 0; &#125; eif(mncost==c)&#123; cout&lt;&lt;1; return 0;&#125; rep(i,1,n+1)&#123; Dijkstra(i); rep(j,1,n+1)&#123; if(i!=j &amp;&amp; dist[j]+mincost[j][i]&lt;=c)&#123;cout&lt;&lt;2; return 0;&#125; &#125; &#125; cout&lt;&lt;1; return 0; &#125; G_Occupy the Cities 二分答案/dp 题意：一个01串，每次操作可以将串中所有的1的左边一位或右边一位也变成1，问变成全1串需要几次操作 解法：二分答案，check() 中从串的左边到右边对每一位1嗯贪心，dp解法没看 #include &lt;bits/stdc++.h> #define mp make_pair #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define maxn 1000005 #define pb push_back #define fst first #define sec second using namespace std; char s[maxn]; int n; vector&lt;int> one; int need[maxn]; void init(int t) &#123; scanf(\"%s\", s + 1); one.clear(); rep(i, 1, t + 1) &#123; need[i] = 0; if (s[i] == '1') &#123; one.pb(i); &#125; &#125; &#125; int check(int x) &#123; if (one[0] - 1 > x) return 0; if (one[0] - 1 == x) need[1] = 1; int tmp; rep(i, 1, one.size()) &#123; if (one[i] - one[i - 1] == 1) continue; tmp = one[i] - one[i - 1] - 1 + need[i]; if ((tmp + 1) / 2 > x) return 0; else if ((tmp + 1) / 2 == x) &#123; if (tmp / 2 == x) need[i + 1] = 1; &#125; &#125; tmp = n - one[one.size() - 1] + need[one.size()]; if (tmp > x) return 0; return 1; &#125; void solve() &#123; cin >> n; init(n); if (one.size() == n) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return; &#125; int l = 1, r = n; int ret = 0; while (l &lt;= r) &#123; int mid = (l + r) >> 1; //cout &lt;&lt; mid &lt;&lt; \" \" rep(i, 1, n + 2) need[i] = 0; if (check(mid)) &#123; ret = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; int main() &#123; int T; cin >> T; while (T--) &#123; solve(); &#125; &#125; I_PTSD 沙比题，不想复盘了 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 1000005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; char a[maxn]; void solve() &#123; int n; cin &gt;&gt; n; ll ret&#x3D;0; rep(i,0,n)&#123; cin&gt;&gt;a[i]; &#125; int lead&#x3D;0; int mxpos; red(i,n,0)&#123; if(a[i]&#x3D;&#x3D;&#39;0&#39;)&#123; lead++; &#125;else&#123; if(lead&gt;0)&#123; lead--; ret+&#x3D;(i+1); &#125;else&#123; lead++; &#125; &#125; &#125; cout&lt;&lt;ret&lt;&lt;endl; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; 总结：今天想出来D了吗","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"图论","slug":"图论","permalink":"https://maskros.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://maskros.top/tags/Dijkstra/"}]},{"title":"Educational Codeforces Round 117 (Div.2)","slug":"codeforces/cf Edu 117","date":"2021-11-23T10:02:00.000Z","updated":"2022-01-25T07:51:13.529Z","comments":true,"path":"/post/codeforces/cf Edu 117.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20117.html","excerpt":"Educational Codeforces Round 116 (Div.2)","text":"Educational Codeforces Round 117 (Rated for Div. 2)A_Distance 签到 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; void solve() &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; int xx &#x3D; -1, yy &#x3D; -1; int tot &#x3D; x + y; if (abs(tot) % 2 &#x3D;&#x3D; 1) &#123; cout &lt;&lt; xx &lt;&lt; &quot; &quot; &lt;&lt; yy &lt;&lt; endl; return; &#125; else &#123; if (abs(x) % 2 &#x3D;&#x3D; 0 &amp;&amp; abs(y) % 2 &#x3D;&#x3D; 0) &#123; cout &lt;&lt; x &#x2F; 2 &lt;&lt; &quot; &quot; &lt;&lt; y &#x2F; 2 &lt;&lt; endl; return; &#125; else &#123; tot &#x2F;&#x3D; 2; if (x &gt; y) cout &lt;&lt; tot &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; tot &lt;&lt; endl; &#125; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; B_Special_Permutation 贪心构造 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; int num[105]; bool vis[105]; void solve() &#123; int n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; memset(vis,0,sizeof(vis)); memset(num, 0, sizeof(num)); vis[a]&#x3D;1; vis[b]&#x3D;1; num[n&#x2F;2+1]&#x3D;b; num[1]&#x3D;a; int tmp&#x3D;1; bool find; rep(i,n&#x2F;2+2,n+1)&#123; find&#x3D;false; rep(j,tmp,b)&#123; if(!vis[j])&#123; vis[j]&#x3D;1; num[i]&#x3D;j; tmp&#x3D;j+1; find&#x3D;1; break; &#125; &#125; if(!find) &#123;cout&lt;&lt;-1&lt;&lt;endl; return;&#125; &#125; tmp&#x3D;n; rep(i,2,n&#x2F;2+1)&#123; find&#x3D;false; red(j,tmp+1,a)&#123; if(!vis[j])&#123; vis[j]&#x3D;1; num[i]&#x3D;j; tmp&#x3D;j-1; find&#x3D;1; break; &#125; &#125; if(!find) &#123;cout&lt;&lt;-1&lt;&lt;endl; return;&#125; &#125; rep(i,1,n+1)&#123; cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; C_Chat_Ban 题意： 输入k,x ; 你有2k-1条信息要发，信息的长度为1,2,3…k-1,k,k-1…1，在发出当前信息时，你已经发送的总长度必须小于x，问你最多能发多少条 思路： 二分答案即可 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; ll cal(ll begin, ll end)&#123; ll ret; if((begin+end)%2&#x3D;&#x3D;0)&#123; ret&#x3D;(begin+end)&#x2F;2*(end-begin+1); &#125;else&#123; ret&#x3D;(end-begin+1)&#x2F;2*(begin+end); &#125; return ret; &#125; void solve() &#123; ll k,x; cin&gt;&gt;k&gt;&gt;x; ll ans&#x3D;0; ll test&#x3D;cal(1,k); if(test&#x3D;&#x3D;x)&#123; cout&lt;&lt;k&lt;&lt;endl; return; &#125;eif(test&lt;x)&#123; ans+&#x3D;k; x-&#x3D;test; test&#x3D;cal(1,k-1); if(test&lt;&#x3D;x)&#123; cout&lt;&lt;2*k-1&lt;&lt;endl; return;&#125; else&#123; ll l&#x3D;1,r&#x3D;k; ll mid; ll tmp&#x3D;0; while(l&lt;&#x3D;r)&#123; mid&#x3D;(l+r)&gt;&gt;1; test&#x3D;cal(mid,k-1); if(test&#x3D;&#x3D;x)&#123; tmp&#x3D;k-mid; break; &#125;eif(test&lt;x)&#123; tmp&#x3D;k-mid+1; r&#x3D;mid-1; &#125;else&#123; l&#x3D;mid+1; &#125; &#125; ans+&#x3D;tmp; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;else&#123; ll l&#x3D;1,r&#x3D;k; ll mid; while(l&lt;&#x3D;r)&#123; mid&#x3D;(l+r)&gt;&gt;1; test&#x3D;cal(1,mid); if(test&#x3D;&#x3D;x)&#123; ans&#x3D;mid; break; &#125;eif(test&lt;x)&#123; ans&#x3D;mid+1; l&#x3D;mid+1; &#125;else&#123; r&#x3D;mid-1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; D_X_Magic_Pair (gcd) 题意： 给你 a, b, x，每次操作可以将a或b替换为 |a-b|, 询问能否将a或b进行任意次操作后替换为 x 思路： gcd变种，每次判断一下 a%b 是否等于 x%b，即 (a-x)%b==0 ，如果相等即为YES，否则即为NO #include &lt;bits/stdc++.h> #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define mp make_pair #define fst first #define sec second #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x - 1; i >= y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; ll a, b, x; bool gcd(ll a, ll b)&#123; if(a==x||b==x) return 1; if(b==0) return 0; if(a>x&amp;&amp;(a-x)%b==0) return 1; if(b>x&amp;&amp;(b-x)%a==0) return 1; return gcd(b,a%b); &#125; void solve() &#123; cin>>a>>b>>x; if(x>a&amp;&amp;x>b)&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; return; &#125; if(x==a||x==b)&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; return;&#125; ll tmpa=(a>b)?a:b; ll tmpb=(b&lt;a)?b:a; if(gcd(tmpa,tmpb)) puts(\"YES\"); else puts(\"NO\"); &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; 总结仨签到很顺溜，最后一个题因为判断条件结果sb了，掉分","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"gcd","slug":"gcd","permalink":"https://maskros.top/tags/gcd/"}]},{"title":"进行一个毛概题库的爬","slug":"projects/maogai_crawler","date":"2021-11-10T14:43:00.000Z","updated":"2021-12-25T07:17:11.282Z","comments":true,"path":"/post/projects/maogai_crawler.html","link":"","permalink":"https://maskros.top/post/projects/maogai_crawler.html","excerpt":"Crawler in THEOL","text":"进行一个毛概题库的爬 前言：🐷b毛概题库要截止了，几个时间段的题库各自有截止日期😅，眼见着ddl就要到了可👴又不想去刷，所以萌生了借助python爬虫来进行偷懒的想法 办事流程 由于之前👴说过：“python狗都不用”，“用python的都沙比” 的名言，所以一开始是拒绝的，但是迫于现状，所以简单突击了几天，学到了一些知识，实战用到的也就只有不到 1/5 需求： 题库共计一百多道题目，每次测试15道题，5单选5多选5判断，提交做题结果之后方可获得所有题的正确答案，所以我们的思路就是从所有测试尝试的反馈页面中爬取题目题面和正确答案并持久化存储，over 原先步骤(全自动) 模拟登录 由于这个b bb平台需要信息门户登录成功之后才能做那b题，所以需要模拟登陆之后才能请求到做题结果的页面，所以我们利用session会话对象在向登录页面发起请求后储存cookie，这样后面直接用session对象再对需求的页面进行get请求即可。 自动做题 自动开始新尝试并且提交 开爬 get到了页面之后，利用xpath进行数据解析，持久化存储即可 想法很好，后来出现了一些问题，所以以下是最终流程： 现实步骤(几乎全自动) 2021/11/13 更新了 v1.1 版本：①优化了存储方式：按字典序排序即按题目的章节进行分类；②实现了 v1.0 没实现的自动做题功能 模拟登录(x) 手动登录(√) 按照原先的想法模拟登陆，返回的消息也是登陆成功，但是请求所需页面是还是被拦截了，需要重新登录，由于才疏学浅，一时不知道如何是好，干脆直接手动登录后，利用浏览器F12，找到登录的cookie，手动复制到源码中的 headers 内，直接用 requests 进行 post 和 get 的请求即可获得所需页面 自动做题(√) 开始新尝试：发现开始新尝试的按钮中对应的 &lt;a&gt;标签的 url 中的参数有个有趣的地方 new_attempt=1，直接访问即可以开始一次新的尝试，直接get请求即可 提交新尝试：点击提交按钮后进行抓包，发现有一个post请求对应的 url : do/take/saveAttempt?saveSequence=1/... ，观察数据包中传输的数据发现有这样几个有趣的地方：data_submitted:true, save_and_submit:true；我们猜测这就是对服务器进行的提交结果请求。之后对比两次不同的提交所得的数据包发现，所需修改的参数为current_attempt_id 和 current_attempt_id_backup，二者是一样的，于是观察哪里有这个id，发现和做题页面中的&lt;div&gt;标签的类名有着惊人的一致🤠。直接对做题页面进行xpath解析，解析到div标签的类名传输进post请求的数据中，再发送post请求即可完成自动提交新尝试😪 自动开爬 ！(√) get到所有尝试的页面，利用xpath解析到对应每次做题结果的 &lt;a&gt; 标签的href地址存到 list 中，拼接成完整的url 对每个url 利用xpath解析到对应题目和答案的标签，根据题目类型分别存储，利用字典存储，题目名称为key，题目答案为value，为了防止存储重复题目，每次存储前先查询key是否存在，不存在再存入字典中，写入文件的同时计数器+1，方便统计爬取题目的个数 冻手冻手 🐴来import requests from lxml import etree import os import time if __name__ == '__main__': # 创建文件夹 if not os.path.exists('./maogai/Round_2/'): os.mkdir('./maogai/Round_2/') session = requests.Session() detail_url = 'https://wlkc.ouc.edu.cn' # 使用现成的cookie直接绕过登录页面 headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36', 'Cookie': 'JSESSIONID=AC1DEAF6D6037A4B310E53885942338D; LOGIN=3139303230303331303330; UM_distinctid=17bcb2f4e579ab-0e328a4e032f8-a7d193d-144000-17bcb2f4e58315; SCREEN_NAME=4f566b646b73396b79642f396274486b665a503656773d3d; session_id=4025A5EAD4245D545DCB1E8FD2D1EE4E; s_session_id=864B98DCC97327775D6853902DCD0138; web_client_cache_guid=871e5dc2-27ae-44b8-898f-a44d97e217f2', &#125; # 自动请求开始测试和提交 times_att为次数 每次请求间隔3s times_att = 10 print('attempt started...') for i in range(0,times_att): # 请求测试 attempt_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/take/launch.jsp?course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;new_attempt=1&amp;content_id=_633969_1&amp;step=' atmp = session.get(url=attempt_url, headers=headers) # 拿到本次测试id do_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/take/launch.jsp?course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;content_id=_633969_1&amp;step=null' do = session.get(url=do_url, headers=headers) tree_att = etree.HTML(do.text) atnum = tree_att.xpath('//div[@class=\"takeQuestionDiv \"]/@id')[0] print('attemptid = ' + str(atnum)) # 提交本次测试 submit_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/do/take/saveAttempt?saveSequence=17&amp;takePageId=1636771783088&amp;course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;content_id=_633969_1' data = &#123; 'blackboard.platform.security.NonceUtil.nonce.ajax': 'c87385ed-48d7-4d9c-8c8c-a9f6cb45826d', 'data-submitted': 'true', 'course_assessment_id': '_30131_1', 'course_id': '_13492_1', 'content_id': '_633969_1', 'step': '', 'original_user_id': '_47406_1', 'save_and_submit': 'true', 'timer_completion': '', 'fileUploadType': '', 'toggle_state': 'qShow', 'current_question': '1', 'current_attempt_item_id': atnum, 'current_attempt_item_id_backup': atnum, 'method': 'notajax', 'saveonequestion': '', &#125; submit = session.post(url=submit_url, headers=headers, data=data) print('post finished! times: '+ str(i+1)) time.sleep(3) print('attempt over!') print('--------------------') # 总尝试页面 total_url = 'https://wlkc.ouc.edu.cn/webapps/gradebook/do/student/viewAttempts?method=list&amp;course_id=_13492_1&amp;outcome_definition_id=_95191_1&amp;outcome_id=_2069239_1' page_text_tot = session.get(url=total_url, headers=headers) tree_tot = etree.HTML(page_text_tot.text) attempt_list = tree_tot.xpath('//div[@class=\" columnStep clearfix\"]//a/@href') # 为了去重使用字典保存键值对 danxuan = &#123;&#125; duoxuan = &#123;&#125; panduan = &#123;&#125; cnt1 = 0 cnt2 = 0 cnt3 = 0 fp1 = open('./maogai/Round_2/单选.txt', 'w', encoding='utf-8') fp2 = open('./maogai/Round_2/多选.txt', 'w', encoding='utf-8') fp3 = open('./maogai/Round_2/判断.txt', 'w', encoding='utf-8') times = 0 print('download started...') for attempt in attempt_list: times = times + 1 new_url = detail_url + attempt # print(new_url) page_text = session.get(url=new_url, headers=headers) tree = etree.HTML(page_text.text) pro_list = tree.xpath('//ul[@id=\"content_listContainer\"]/li') cnt = 0 # 每次尝试的内容进行爬取 for li in pro_list: cnt = cnt + 1 pro_name = li.xpath('normalize-space(.//div[@class=\"vtbegenerated inlineVtbegenerated\"])') pro_answer_1 = li.xpath('.//div[@class=\"vtbegenerated inlineVtbegenerated\"]//label/text()') pro_answer_1 = str(pro_answer_1) pro_answer_2 = li.xpath('normalize-space(.//span[@class=\"answerTextSpan\"])') if cnt &lt;= 5: if pro_name not in danxuan: cnt1 = cnt1 + 1 danxuan[pro_name] = pro_answer_1 # fp1.write(str(cnt1) + '. ' + pro_name+'\\n'+pro_answer_1+'\\n') elif cnt &lt;= 10: if pro_name not in duoxuan: cnt2 = cnt2 + 1 duoxuan[pro_name] = pro_answer_1 # fp2.write(str(cnt2) + '. ' + pro_name + '\\n' +pro_answer_1+'\\n') else: if pro_name not in panduan: cnt3 = cnt3 +1 panduan[pro_name] = pro_answer_2 # fp3.write(str(cnt3) + '. ' + pro_name + '\\n'+pro_answer_2+'\\n') print('times: ' + str(times) + ' 单选: ' + str(cnt1) + ',多选：' + str(cnt2) + ',判断: ' + str(cnt3) ) # 将字典进行按key排序实现不同章节分类进行存储 num = 0 for pro in sorted(danxuan): num = num + 1 fp1.write(str(num)+'. '+ pro + '\\n' + danxuan[pro] + '\\n') num = 0 for pro in sorted(duoxuan): num = num + 1 fp2.write(str(num)+'. ' + pro + '\\n' + duoxuan[pro] + '\\n') num = 0 for pro in sorted(panduan): num = num + 1 fp3.write(str(num)+'. ' + pro + '\\n' + panduan[pro] + '\\n') fp1.close() fp2.close() fp3.close() print('total: ' + str(cnt1+cnt2+cnt3) + ' problems have been downloaded.') 一个小实战，效果还行😅，以后会想办法修改自动登录的问题，可以提点意见 github项目地址 link 爬取的题库在文件夹里 over大火","categories":[{"name":"PROJECT","slug":"PROJECT","permalink":"https://maskros.top/categories/PROJECT/"}],"tags":[{"name":"Crawler","slug":"Crawler","permalink":"https://maskros.top/tags/Crawler/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"},{"name":"requests","slug":"requests","permalink":"https://maskros.top/tags/requests/"}]},{"title":"python爬虫杂记","slug":"note/Crawler","date":"2021-11-10T09:03:30.000Z","updated":"2022-01-22T09:37:42.226Z","comments":true,"path":"/post/note/Crawler.html","link":"","permalink":"https://maskros.top/post/note/Crawler.html","excerpt":"Crawler in python","text":"python爬虫杂记Crawler in python 又名 《为了偷懒爬毛概题库的突击学习》 一些知识 爬虫在使用场景中的分类： 通用爬虫：抓取系统重要促成部分，抓取的是一整张页面数据 聚焦爬虫：是建立在通用爬虫的基础上，抓取的是页面中特定的局部内容 增量式爬虫：检测网站中数据更新的情况，只会抓取网站中最新更新出来的数据 robots.txt协议：君子协议，规定网站中哪些数据能爬哪些不能，约定俗成 http &amp; https 协议： http协议：服务器和客户端进行数据交互的一种形式 https协议：安全的超文本传输协议 证书秘钥加密 常用请求头信息： User-Agent：请求载体的身份标识 Connection：请求完毕后，是断开连接还是保持连接 常用响应头信息： Content-Type：服务器响应回客户端的数据类型 requests模块 requests: python原生的基于网络请求的模块，模拟浏览器发请求 .text 字符串 .content 二进制 .json() 对象 编码流程： 指定url 发起请求 获取响应数据 持久化存储 0x00 requests 一血 response.text import requests # 1.指定url url='xxxx/xxx/xxx.xxx' # 2.发起请求 get方法会返回一个响应对象 response = requests.get(url=url) # 3.获取响应数据 .text返回的是字符串形式的响应数据 page_text = response.text print(page_text) # 4.持久化存储 with open('./xxx.html','w',encoding='utf-8') as fp: fp.write(page_text) print('over!') 0x01 网页采集器 UA检测 UA伪装 requests.get(url, params, headers) import requests # UA：User-Agent 请求载体的身份标识 # UA检测：门户网站的服务器会检测对应请求的载体身份标识，如果检测到的标识为基于某一款浏览器的， # 则说明是正常请求，反之服务端就可能拒绝这次请求 # UA伪装：让爬虫对应的请求载体身份标识伪装成某一款浏览器 if __name__ == '__main__': # UA伪装：将对应的User-Agent封装到一个字典中 headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; url = 'https://www.sogou.com/web' # 处理url携带的参数：封装到字典中 kw = input('enter a word:') param = &#123; 'query': kw &#125; # 对指定url发起的请求对应url是携带参数的，并且请求过程中处理了参数 response = requests.get(url=url, params=param, headers=headers) page_text = response.text fileName = './requests_test/test2/'+kw+'.html' with open(fileName, 'w', encoding='utf-8') as fp: fp.write(page_text) print(fileName, ' is saved') 0x02 百度翻译 post请求 (携带了参数) ajax 响应数据是一组json数据 requests.post(url, data, json, headers...) response.json() import requests import json if __name__ == '__main__': # 1.指定url post_url = 'https://fanyi.baidu.com/sug' # 2.进行UA伪装 headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; # 3.post请求参数处理(同get请求一致) word = input('enter a word') data = &#123; 'kw': word &#125; # 4.请求发送 response = requests.post(url=post_url, data=data, headers=headers) # 5.获取响应数据:json()方法返回的是obj(如果确认响应数据是json类型才能使用) dic_obj=response.json() print(dic_obj) # 6.持久化存储 fileName = './requests_test/test3/'+word+'.json' fp = open(fileName,'w',encoding='utf-8') # 由于中文不能用ascii编码，所以令ensure_ascii=False json.dump(dic_obj,fp=fp,ensure_ascii=False) print('over!') 0x03 豆瓣电影 request.get import requests import json if __name__ == '__main__': url = 'https://movie.douban.com/j/chart/top_list' param = &#123; 'type': '24', 'interval_id': '100:90', 'action': '', 'start': '40', # 从库中的第几部电影去取 'limit': '20', # 一次从库中取出的个数 &#125; headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; response = requests.get(url=url, params=param, headers=headers) list_data = response.json() # print(list_data) fp = open('./requests_test/test4/douban.json', 'w', encoding='utf-8') json.dump(list_data, fp=fp, ensure_ascii=False) print('over!') 0x04 综合案例-数据提取import requests import json if __name__ == '__main__': headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; id_list = [] # 存储企业id all_data_list = [] # 存储所有的企业详情数据 # 批量获取不同企业的id值 url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsList' # 参数的封装 for page in range(1,6): page=str(page) data = &#123; 'on': 'true', 'page': page, 'pagesize': '15', 'productName': '', 'conditionType': '1', 'applyname': '', 'applysn': '', &#125; json_ids = requests.post(url=url, headers=headers, data=data).json() for dic in json_ids['list']: id_list.append(dic['ID']) # 获取企业详细数据 post_url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById' for id in id_list: data = &#123; 'id': id &#125; detail_json = requests.post( url=post_url, headers=headers, data=data).json() print(detail1_json, '--------ending--------') all_data_list.append(detail_json) # 持久化存储all_data_list fp = open('./requests_test/test5/allData.json', 'w', encoding='utf-8') json.dump(all_data_list, fp=fp, ensure_ascii=False) print('over!') 数据解析 聚焦爬虫：爬取页面中指定的页面内容 编码流程： 指定url 发起请求 获取响应数据 数据解析 持久化存储 数据解析分类：正则，bs4，xpath 数据解析原理概述： 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储 进行指定标签的定位 标签或者标签对应的属性中存储的数据值进行提取 (解析) 0x00 图片 .content 返回二进制 import requests if __name__ == '__main__': # 如何爬取图片数据 url = 'https://i2.hdslb.com/bfs/archive/237001f0163eb48c1745a906c5b480f449183d66.jpg@672w_378h_1c_100q.webp' # content 返回的是二进制形式图片数据 img_data = requests.get(url=url).content with open('./data_parse_test/test1/dsm.jpg','wb') as fp: fp.write(img_data) 0x01 正则解析 需要导入re模块 常用正则表达式 ex: &lt;div class=\"test\"> &lt;a href=\"/dsadas/sdada\" target=\"_blank\"> &lt;img src=\"//sdadasd/dsadas/dasdas\" alt=\"sdada\"> &lt;/a> &lt;/div> ex='&lt;div class=\"test\">.*?&lt;img src=\"(.*?)\" alt .*?&lt;/div>' 练习：图片分页爬取 import requests import re import os # 需求：爬取所有图片 if __name__ == '__main__': headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; #创建文件夹，保存所有图片 if not os.path.exists('./data_parse_test/test1'): os.mkdir('./data_parse_test/test1/') #设置一个通用url模板 url = 'https://www.qiushibaike.com/pic/page/%d/?s=5184961' for pageNum in range(1,36): #对应页码的url new_url = format(url%pageNum) # 使用通用爬虫对url对应的一整张页面进行爬取 page_text = requests.get(url=url, headers=headers).text # 使用聚焦爬虫将页面中所有漫画进行解析/提取 ex = '&lt;div class=\"thumb\">.*?&lt;img src=\"(.*?)\" alt.*?&lt;/div> ' img_src_list = re.findall(ex, page_text, re.S) # print(img_src_list) for src in img_src_list: #拼接出一个完整的图片url src='https:'+src #请求到了图片的二进制数据 img_data=requests.get(url=src,headers=headers).content #生成图片名称 img_name=src.split('/')[-1] #图片存储的路径 imgPath='./data_parse_test/test1/'+img_name with open(imgPath,'wb') as fp: fp.write(img_data) print(img_name,'下载成功！') 0x02 bs4解析 所需模块：bs4 lxml 数据解析的原理： 标签定位 提取标签、标签属性中存储的数据值 bs4数据解析的原理： 实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中 通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取 如何实例化Beautiful对象： from bs4 import BeautifulSoup 对象的实例化：将本地/互联网上获取的页面源码加载到该对象中 soup=BeautifulSoap(page_text.content,&#39;lxml&#39;) 提供的用于数据解析的方法和属性： soup.tagName 对应html标签 返回的是html中第一次出现的tagName标签 soup.find() : soup.find(&#39;tagName&#39;) 同 soup.tagName 属性定位：soup.find(&#39;tagName&#39;,class_=&#39;xxx&#39;) (class要带下划线) soup.find_all(&#39;tagName&#39;) 返回所有的标签(列表) soup.select() soup.select(&#39;某种选择器(id,class,标签...)&#39;)，返回的是一个列表 #id, tag, .class 层级选择器： soup.select(&#39;.class1 &gt; ul &gt; li &gt; a&#39;)[2] 表示 class1 下的 ul 标签下的 li 标签中的第二个 a 标签。 &gt; 表示一个层级关系 soup.select(&#39;.class1 &gt; ul a&#39;)[2] 表示同上，空格表示的是多个层级关系 获取标签之间的文本数据 soup.a.text/string/get_text() .text/.get_text() 可以获得某一个标签中所有的文本内容 .string 只可以获取改标签下面直系的文本内容 获取标签中属性值 soup.a[&#39;href&#39;] 练习：小说章节名和内容爬取 import requests import lxml from bs4 import BeautifulSoup # 需求：爬取小说的所有章节标题和内容 if __name__ == '__main__': if not os.path.exists('./data_parse_test/test2'): os.mkdir('./data_parse_test/test2/') headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' &#125; # 对首页的页面进行爬取 url = 'http://www.banzhu22.org/5_5853/' page_text = requests.get(url=url, headers=headers) # 在首页中解析出章节的标题和详情页的url # 1. 实例化BeautifulSoup对象，将网页源码加载到对象中 soup = BeautifulSoup(page_text.content, 'lxml') dd_list = soup.select('.box_con > #list dd')[9:] fp = open('./data_parse_test/test2/49gifts.txt', 'w', encoding='utf-8') for dd in dd_list: title = dd.a.string detail_url = 'http://www.banzhu22.org' + dd.a['href'] # 对详情页发起请求，解析出章节内容 detail_page_text = requests.get(url=detail_url, headers=headers) # 解析出详情页中相关章节的内容 detail_soup = BeautifulSoup(detail_page_text.content, 'lxml') div_tag = detail_soup.find('div', id='content') # 解析到章内容 content = div_tag.text fp.write(title+'\\n'+content+'\\n') print(title+'downloaded successfully!') print('over!') 0x03 xpath解析 是最常用且最便捷高效的爬取方式，通用性最强 所需模块：lxml xpath解析原理： 实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中 调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获 如何实例化etree对象： from lxml import etree 本地源码：etree.parse(filePath) 互联网源码：etree.HTML(&#39;page_text&#39;) xpath(&#39;xpath表达式&#39;) xpath表达式： 各表达式可以用 | 连接 /：表示的是一个层级，从根节点开始定位 开头./：定位了层级后，当前层级下的层级 //：表示的是多个层级，可以从任意位置开始定位 属性定位：//div[@class=&quot;xxx&quot;] 即 tag[@attrName=&quot;attrValue&quot;] 索引定位：//div[@class=&quot;xxx&quot;]/p[3] 索引是从1开始的 取文本： /text() 标签下直系的文本内容 //text() 标签下所有的文本内容 取属性：/@attrName 通用处理中文乱码的解决方案 name = name.encode('iso-8859-1').decode('gbk') 练习略 验证码识别反爬机制：验证码 识别验证码的操作： 第三方自动识别：云打码 to be added…. 模拟登陆需求：对校园网进行登陆 (无验证码) 点击登陆按钮后会发起一个POST请求，POST请求中会携带登录信息(username,pwd) print(response.status_code) 打印响应状态码，如果打印200则证明模拟登陆成功 需求：爬取当前用户的相关信息 http/https协议特性：无状态 没有请求到对应页面数据的原因：发起的第二次基于页面的请求时，服务器端不知道此次请求是基于登录状态下的请求 cookie：用来让服务端记录客户端的相关状态 cookie值的来源是哪里：模拟登陆post请求后，有服务器端创建 session会话对象： 可以进行请求的发送 如果请求过程中产生了cookie，则cookie会被自动存储/携带在该session对象中 步骤： 创建一个session对象： session = requests.Session() 使用session对象进行模拟登录post请求的发送 (cookie就会被存储在session中) session对象再对登录后页面对应的get请求进行发送 (携带了cookie) selenium工具 解决requests无法执行javaScript代码的问题 用于web应用程序自动化测试的工具，直接运行在浏览器当中，支持chrome、firefox等主流浏览器。可以通过代码控制与页面上元素进行交互（点击、输入等），也可以获取指定元素的内容 缺点： 效率低，速度慢 to be added …","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"Crawler","slug":"Crawler","permalink":"https://maskros.top/tags/Crawler/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"}]},{"title":"2021CCPC女生专场vp","slug":"xcpc/2021ccpc_girl","date":"2021-11-08T14:25:00.000Z","updated":"2022-01-22T09:35:29.311Z","comments":true,"path":"/post/xcpc/2021ccpc_girl.html","link":"","permalink":"https://maskros.top/post/xcpc/2021ccpc_girl.html","excerpt":"2021年中国大学生程序设计竞赛女生专场","text":"2021CCPC女生专场 “假如我是女生” A_公交线路 水题 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int n,x,y; cin>>n>>x>>y; int k[20]; rep(i,1,n+1) cin>>k[i]; int m; cin>>m; int p[20]; rep(i,1,m+1) cin>>p[i]; int lpos=x-1,rpos=x+1; rep(i,1,m+1)&#123; if(k[lpos]!=p[i])&#123; if(y&lt;x) &#123;cout&lt;&lt;\"Wrong\"&lt;&lt;endl; return;&#125; else &#123;cout&lt;&lt;\"Right\"&lt;&lt;endl; return;&#125; &#125; if(k[rpos]!=p[i])&#123; if(x&lt;y) &#123;cout&lt;&lt;\"Wrong\"&lt;&lt;endl; return;&#125; else &#123;cout&lt;&lt;\"Right\"&lt;&lt;endl; return;&#125; &#125; lpos--; rpos++; &#125; cout&lt;&lt;\"Unsure\"&lt;&lt;endl; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; D_修建道路 沙比题，两两取最大值即可，脂环王写了一发线段树优化递归我不是很认可 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 200005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int a[maxn]; void solve() &#123; int n; cin >> n; ll ans = 0; rep(i, 0, n) &#123; cin >> a[i]; if(i>0) ans+=max(a[i],a[i-1]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; G_3G网络 输出1/n即可 我搞错了double 结果wa在精度上了 最后手写了个除法 结果发现 printf(“%.16lf”,ans) 即可，少写个小数点😅 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int n; cin>>n; int x,y; rep(i,0,n)&#123; cin>>x>>y; &#125; int ans[15]; rep(i,0,12)&#123; if(i==0)&#123; if(n==1) &#123;ans[0]=1; tmp=0;&#125; else &#123;ans[0]=0; tmp*=10;&#125; &#125;else&#123; ans[i]=tmp/n; tmp=tmp%n; tmp*=10; &#125; &#125; cout&lt;&lt;ans[0]&lt;&lt;\".\"; rep(i,1,12)&#123; cout&lt;&lt;ans[i]; &#125; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; // ans=1.0/n // printf(\"%.16lf\",ans); I_驾驶卡丁车 楞模拟就行，八个方向 dis[8][2] 直接做掉啊做掉 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; char mp[55][55]; int dis[8][2] = &#123; &#123;-1, 0&#125;, &#123;-1, -1&#125;, &#123;0, -1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;0, 1&#125;, &#123;-1, 1&#125;&#125;; int n, m, x, y, v, face; bool crsh=0; bool check(int x, int y) &#123; if (x &lt;= 0 || x > n || y &lt;= 0 || y > m) return false; if (mp[x][y] == '#') return false; else return true; &#125; void go()&#123; rep(j, 0, v) &#123; if (dis[face][0] != 0 &amp;&amp; dis[face][1] != 0) &#123; if (!check(x + dis[face][0], y) &amp;&amp; !check(x, y + dis[face][1])) &#123; crsh = true; v = 0; break; &#125; &#125; if (check(x + dis[face][0], y + dis[face][1])) &#123; x += dis[face][0]; y += dis[face][1]; &#125; else &#123; crsh = true; v = 0; break; &#125; &#125; &#125; void solve() &#123; cin >> n >> m; v=0, face=0; rep(i, 1, n+1) &#123; rep(j, 1, m+1) &#123; cin >> mp[i][j]; if (mp[i][j] == '*') &#123; x = i, y = j; &#125; &#125; &#125; int opcnt; cin >> opcnt; char op; crsh = false; rep(i, 0, opcnt) &#123; cin >> op; crsh = false; if (op == 'L') &#123; face++; if (face > 7) &#123; face = 0; &#125; go(); &#125; eif(op == 'R') &#123; face--; if (face &lt; 0) &#123; face = 7; &#125; go(); &#125; eif(op == 'U') &#123; v++; go(); &#125; eif(op == 'D') &#123; v = max(v - 1, 0); go(); &#125; if (crsh) cout &lt;&lt; \"Crash! \"; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; &#125; &#125; int main() &#123; int T = 1; // cin >> T; while (T--) &#123; solve(); &#125; &#125; K_音乐游戏 沙比题 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; void solve() &#123; int n; cin&gt;&gt;n; string s; int cnt&#x3D;0; rep(i,0,n+1)&#123; getline(cin,s); rep(j,0,s.length())&#123; if (s[j] &#x3D;&#x3D; &#39;-&#39;) cnt++; &#125; &#125; cout&lt;&lt;cnt; &#125; int main() &#123; int T &#x3D; 1; &#x2F;&#x2F; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; 总结：再次化身签到皇帝，还在想B题的字符串，请把“今天想出来B了吗”打在评论区😘","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"Codeforces Round 752 (Div.2)","slug":"codeforces/cf 752","date":"2021-10-31T14:50:00.000Z","updated":"2022-01-25T07:50:06.014Z","comments":true,"path":"/post/codeforces/cf 752.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20752.html","excerpt":"Codeforces Round 750 (Div.2)","text":"Codeforces Round #752 (Div.2)A_Era 水题 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int n; cin >> n; ll ans = 0; int t; int pos = 1; rep(i, 1, n + 1) &#123; cin >> t; if (t > pos) &#123; ans += t - pos; pos += t - pos; &#125; pos++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; B_XOR_Specia_LIS_t 题意： 沙比题，如果序列所分成的若干子序列中，最长的任意递增序列(不需要连续)的长度相异或，可以为0则输出 yes 否则输出 no 思路： 没说咋分，就一个一个分，所以就是 1^1^1^… ，根据序列长度的奇偶性判断一下即可，偶数一定yes，奇数就判断是不是单增序列，不是的话一定yes，反之no #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int a[maxn]; void solve() &#123; int n; cin>>n; int tmp; rep(i,0,n)&#123; cin >> a[i]; &#125; bool is=false; if(n&amp;1)&#123; rep(i,1,n)&#123; if(a[i]&lt;=a[i-1])&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; is=true; break; &#125; &#125; if(!is) cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; C_Di_visible_Confusion 题意： 一个序列，可以对a[i]进行删除操作的前提是 a[i]%(i+1)!=0，问这个序列能不能被删干净 思路： 暴力即可 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; int a[maxn]; void solve() &#123; int n; cin>>n; rep(i,1,n+1)&#123; cin>>a[i]; &#125; bool flag=false; rep(i,1,n+1)&#123; flag=false; rep(j,2,i+2)&#123; if(a[i]%j!=0)&#123; flag=true; break; &#125; &#125; if(!flag)&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; return; &#125; &#125; cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; D_Vupsen_Pupsen_and_0 题意： 输入x,y 两个偶数，找出 n，使得 n%x=y%n 思路： 分类讨论即可： x&gt;y 时，n=x+y x&lt;y 时，n=y-(y%x)/2 考虑特例 思考不出来的时候画数轴可以给你灵感 #include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; ll x, y; cin >> x >> y; if (x == y) &#123; cout &lt;&lt; x &lt;&lt; endl; return; &#125; if (x > y) &#123; cout &lt;&lt; x + y &lt;&lt; endl; &#125; else &#123; if (y % x == 0) &#123; cout &lt;&lt; x &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; y - (y % x) / 2 &lt;&lt; endl; &#125; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125;","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Educational Codeforces Round 116 (Div.2)","slug":"codeforces/cf Edu 116","date":"2021-10-30T06:02:00.000Z","updated":"2021-12-25T07:17:35.361Z","comments":true,"path":"/post/codeforces/cf Edu 116.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20Edu%20116.html","excerpt":"Educational Codeforces Round 116 (Div.2)","text":"Educational Codeforces Round 116 (Rated for Div. 2)A_AB_Balance 题意： 由ab构成的串，做最少操作使ab和ba出现的次数相同 思路： 如果出现次数不同，最多差1，修改首位即可 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; void solve() &#123; string s; cin &gt;&gt; s; int l &#x3D; s.length(); int ab &#x3D; 0, ba &#x3D; 0; rep(i, 0, l) &#123; if (s[i] &#x3D;&#x3D; &#39;a&#39;) &#123; if (s[i + 1] &#x3D;&#x3D; &#39;b&#39;) ab++; &#125; if (s[i] &#x3D;&#x3D; &#39;b&#39;) &#123; if (s[i + 1] &#x3D;&#x3D; &#39;a&#39;) ba++; &#125; &#125; if (ab &#x3D;&#x3D; ba) cout &lt;&lt; s &lt;&lt; endl; else &#123; if (ab &gt; ba) &#123; if (s[0] &#x3D;&#x3D; &#39;a&#39;) s[0] &#x3D; &#39;b&#39;; &#125; else &#123; if (s[0] &#x3D;&#x3D; &#39;b&#39;) s[0] &#x3D; &#39;a&#39;; &#125; cout &lt;&lt; s &lt;&lt; endl; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; B_Update_Files 水题 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; ll quickpow(ll a, ll b) &#123; ll ans &#x3D; 1; ll res &#x3D; a; while (b) &#123; if (b &amp; 1) ans &#x3D; ans * res; b &gt;&gt;&#x3D; 1; res &#x3D; res * res; &#125; return ans; &#125; void solve() &#123; ll n, k; cin &gt;&gt; n &gt;&gt; k; if (n &#x3D;&#x3D; 1) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; int need &#x3D; 0; ll tmp &#x3D; 0; rep(i, 0, 65) &#123; tmp &#x3D; quickpow(2, i); if (tmp &gt;&#x3D; k || tmp &gt;&#x3D; n) &#123; need &#x3D; i; break; &#125; &#125; if (tmp &gt;&#x3D; n) cout &lt;&lt; need &lt;&lt; endl; else &#123; ll times &#x3D; need; if ((n - tmp) % k &gt; 0) &#123; times +&#x3D; (n - tmp) &#x2F; k + 1; &#125; else &#123; times +&#x3D; (n - tmp) &#x2F; k; &#125; cout &lt;&lt; times &lt;&lt; endl; &#125; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; C_Banknotes 题意： 给定n,k, n代表纸币种类，k代表最多可用纸币数量，接下来给出a[0…n-1]， 顺序由小到大，表示每张纸币的面值为 10^a[i]，求不能表示出的金额的最小值 思路： 贪心，按10进制从低位到高位取，能取够低位就是 a[i+1]-1 的形式，即为 x999… , 如果a[i]取不到a[i+1] 或者 没有更大面值的钞票，答案即为 a[i] * 剩余张数 + a[i]-1 , 能取到就接着找a[i+1]。 #include &lt;bits&#x2F;stdc++.h&gt; #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar(&#39;\\n&#39;) #define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++) #define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;; typedef long long ll; #define pll pair&lt;ll, ll&gt; using namespace std; ll a[20]; ll quickpow(ll a, ll b) &#123; ll ans &#x3D; 1; ll res &#x3D; a; while (b) &#123; if (b &amp; 1) ans &#x3D; ans * res; b &gt;&gt;&#x3D; 1; res &#x3D; res * res; &#125; return ans; &#125; void solve() &#123; ll n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 0, n) &#123; cin &gt;&gt; a[i]; a[i] &#x3D; quickpow(10, a[i]); &#125; a[n] &#x3D; 0; ll ans &#x3D; 0; ll tmp &#x3D; 0; rep(i, 0, n) &#123; if (i &#x3D;&#x3D; 0) &#123; if (n &#x3D;&#x3D; 1) &#123; cout &lt;&lt; k + 1 &lt;&lt; endl; return; &#125; if (a[i] * k + 1 &lt; a[i + 1]) &#123; cout &lt;&lt; a[i] * k + 1 &lt;&lt; endl; return; &#125; else &#123; tmp +&#x3D; a[i + 1] &#x2F; a[i] - 2; ans &#x3D; a[i + 1] - 1; &#125; &#125; else &#123; if ((k - tmp) * a[i] &lt; a[i + 1]) &#123; ans &#x3D; (k - tmp) * a[i] + a[i] - 1; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; eif(a[i + 1] &#x3D;&#x3D; 0) &#123; ans &#x3D; (k - tmp) * a[i] + a[i] - 1; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; else &#123; tmp +&#x3D; a[i + 1] &#x2F; a[i] - 1; ans &#x3D; a[i] - 1; &#125; &#125; &#125; &#125; int main() &#123; int T &#x3D; 1; cin &gt;&gt; T; while (T--) &#123; solve(); &#125; &#125; 总结我真是个沙比，打的时候因为有个判断条件写错了一直wa2，比赛完十分钟就过了，纯掉分飞舞 😅","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Codeforces Round 750 (Div.2)","slug":"codeforces/cf 750","date":"2021-10-27T17:02:50.000Z","updated":"2022-01-25T07:49:43.171Z","comments":true,"path":"/post/codeforces/cf 750.html","link":"","permalink":"https://maskros.top/post/codeforces/cf%20750.html","excerpt":"Codeforces Round 750 (Div.2)","text":"Codeforces Round #750 (Div.2)A_Luntik_and_Concerts#include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; ll a, b, c; cin >> a >> b >> c; int mn = min(a, b); if ((mn + c) &amp; 1) &#123; mn--; a -= mn; b -= mn; &#125; else &#123; a -= mn; b -= mn; &#125; b &amp;= 1; if (b) &#123; if (a >= 2) a -= 2; cout &lt;&lt; (a &amp; 1) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; (a &amp; 1) &lt;&lt; endl; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; B_Luntik_and_Subsequences#include &lt;bits/stdc++.h> #define gcd(a, b) __gcd(a, b) #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 400005 #define co(x) cout &lt;&lt; x &lt;&lt; \" \"; typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; ll quickpow(int a, int b)&#123; ll ans = 1; ll res = a; while (b) &#123; if (b &amp; 1) ans = ans * res; b >>= 1; res = res * res; &#125; return ans; &#125; void solve() &#123; int n; cin>>n; int a[65]; rep(i,0,n) cin>>a[i]; sort(a,a+n); ll cnt=0; if(a[0]>1) cout&lt;&lt;0&lt;&lt;endl; else&#123; ll cnt0=0,cnt1=0; rep(i,0,n)&#123; if(a[i]==0) cnt0++; eif(a[i]==1) cnt1++; else break; &#125; cnt=cnt1*quickpow(2,cnt0); cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; int main() &#123; IOS; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125; C_Grandma_Capa_Knits_a_Scarf 题意： 待补 思路： 待补 #include &lt;iostream> #include &lt;algorithm> #include &lt;cstring> #include &lt;vector> #define ll long long #define pb push_back using namespace std; int sum1[100005], sum2[100005]; int p[1000005]; int main() &#123; int T; cin >> T; //T = 1; while(T--) &#123; int n; cin >> n; string s; cin >> s; int ans = 0x3f3f3f3f; for(int i = 0; i &lt; 26; i++) &#123; string s1 = \"\"; sum1[0] = sum2[n + 1] = sum2[n] = 0; char now = 'a' + i; for(int j = 0; j &lt; s.size(); j++) &#123; if(s[j] == now) &#123; if(j == 0) sum1[j] = 1; else sum1[j] = sum1[j - 1] + 1; &#125; else &#123; if(j == 0) sum1[j] = 0; else sum1[j] = sum1[j - 1]; s1 += s[j]; p[s1.size() - 1] = j; &#125; &#125; for(int j = s.size() - 1; j >= 0; j--) &#123; sum2[j] = sum2[j + 1]; if(s[j] == now) sum2[j]++; &#125; string s2 = s1; reverse(s2.begin(), s2.end()); //cout &lt;&lt; \"fuck\" &lt;&lt; endl; if(s1 == s2) &#123; //cout &lt;&lt; (char)('a' + i) &lt;&lt; endl; int del = 0; for(int k = 0; k &lt; s1.size() / 2 + (s1.size() &amp; 1 ? 1 : 0); k++) &#123; //if(i == 0) cout &lt;&lt; k &lt;&lt; \" \" &lt;&lt; endl; int pos1 = p[k], pos2 = p[s1.size() - 1 - k]; //if(i + 'a' == 'r') cout &lt;&lt; k &lt;&lt; \" \" &lt;&lt; del &lt;&lt; endl; if(k == 0) del += abs(sum1[pos1] - sum2[pos2]); else del += abs((sum1[pos1] - sum1[p[k - 1]]) - (sum2[pos2] - sum2[p[s1.size() - k]])); &#125; ans = min(ans, del); &#125; &#125; if(ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; // 1 // 8 // rprarlap D_Vupsen_Pupsen_and_0 题意： 已知非零数组a[i]，求非零数组b[i]，使得a[i]*b[i] 的和为0 思路： 个数为偶数两两相消，个数为奇数的话，选取尾部三个数，判断两个相加不为零的数出来，当作一个数与剩下的一个数两两相消即可。 坑点：三个数时合并的两个数相加不能为0 #include &lt;bits/stdc++.h> #define INF 0x3f3f3f3f3f #define eps 1e-6 #define PI acos(-1.0) #define pb push_back #define eif else if #define en putchar('\\n') #define rep(i, x, y) for (int i = x; i &lt; y; i++) #define red(i, x, y) for (int i = x; i > y; i--) #define mem(a, x) memset(a, x, sizeof(a)) #define IOS cin.tie(0), ios::sync_with_stdio(false) #define maxn 100005 typedef long long ll; #define pll pair&lt;ll, ll> using namespace std; void solve() &#123; int a[maxn]; int n; cin >> n; rep(i, 0, n) &#123; cin >> a[i]; &#125; bool t1 = false, t2 = false, t3 = false; if (n &amp; 1) &#123; if (a[n - 1] + a[n - 2] != 0) &#123; a[n - 2] = a[n - 1] + a[n - 2]; t1 = true; &#125; else &#123; if (a[n - 2] + a[n - 3] != 0) &#123; a[n - 3] = a[n - 2] + a[n - 3]; a[n - 2] = a[n - 1]; t2 = true; &#125; else &#123; a[n - 3] = a[n - 3] + a[n - 1]; t3 = true; &#125; &#125; for (int i = 0; i &lt; n - 1; i += 2) &#123; if (i == n - 3) &#123; if (t1) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \"; &#125; eif(t2) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i]; &#125; eif(t3) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \" &lt;&lt; a[i + 1]; &#125; &#125; else &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \"; &#125; &#125; cout &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; n; i += 2) &#123; cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; &#125; int main() &#123; int T = 1; cin >> T; while (T--) &#123; solve(); &#125; &#125;","categories":[{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"}]},{"title":"kmp & exkmp","slug":"algorithm/learn/kmp & exkmp","date":"2021-10-23T17:02:50.000Z","updated":"2022-01-22T09:37:50.261Z","comments":true,"path":"/post/algorithm/learn/kmp & exkmp.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/kmp%20&%20exkmp.html","excerpt":"Knuth-Morris-Pratt & E-kmp","text":"kmp &amp; exkmpKnuth-Morris-Pratt &amp; entend kmp 字符串匹配 kmp Keywords：next[] 由BF改进，O(m+n)，传世经典属于是😅 以下均假设主串为 S，模式串为 P What is next[] ? 针对模式串，next[j] 表示模式串下标 j 之前 最长相同前后缀的长度，这不重要。 你只需要记住：next[j]表示当 P[j]!=S[i] 时，j 指针的下一步移动位置。 偷个好图： How to quickly build next[] ? 话不多说，直接上🐎 void kmp_pre(string p, int next[])&#123; int i,j; j&#x3D;next[0]&#x3D;-1; i&#x3D;0; while(i&lt;p.length())&#123; while(-1!&#x3D;j &amp;&amp; p[i]!&#x3D;p[j]) j&#x3D;next[j]; next[++i]&#x3D;++j; &#125; &#125; ① 初始化next[0]=-1 ② 如果 P[next[m]]==P[m] ，那么 next[m+1]=next[m]+1 ③ 如果 P[next[m]]!=P[m]，令 t=m, t=next[t]，比较 P[next[t]]和 P[m]：相同的话 next[m]=next[t]+1 , 不同的令t=next[t] 继续比较，直到 t==-1 时，next[m]=0 kmp计数模板 模式串在主串中出现了几次 (可重叠、不可重叠) void kmp_pre(string p, int next[])&#123; int i,j; j&#x3D;next[0]&#x3D;-1; i&#x3D;0; while(i&lt;p.length())&#123; while(-1!&#x3D;j &amp;&amp; p[i]!&#x3D;p[j]) j&#x3D;next[j]; next[++i]&#x3D;++j; &#125; &#125; int kmp_Count(string x, string y, int next[])&#123; &#x2F;&#x2F;x是模式串，y是主串 int i,j; int ans&#x3D;0; kmp_pre(x,next); i&#x3D;j&#x3D;0; while(i&lt;y.length())&#123; while(-1!&#x3D;j &amp;&amp; y[i]!&#x3D;x[j]) j&#x3D;next[j]; i++;j++; if(j&gt;&#x3D;x.length())&#123; ans++; &#x2F;&#x2F;以下二选一 j&#x3D;next[j]; &#x2F;&#x2F;可重叠计数 j&#x3D;0; &#x2F;&#x2F;不可重叠计数 &#125; &#125; return ans; &#125; exkmp Keywords: extend[] next[] O(m+n) e-kmp 可以找到主串中所有模式串的匹配 What are they? next[i]: 对模式串，表示 P[i...m-1] 与 P[0...m-1] 的最长公共前缀 extend[i] : 对主串和模式串，表示 S[i...n-1]与 P[0...m-1] 的最长公共前缀 How to build them? 🐎来 void ekmp_pre(string x, int next[])&#123; int m&#x3D;x.length(); next[0]&#x3D;m; int j&#x3D;0; while(j+1&lt;m &amp;&amp; x[j]&#x3D;&#x3D;x[j+1]) j++; next[1]&#x3D;j; int k&#x3D;1; for(int i&#x3D;2; i&lt;m; i++)&#123; int p&#x3D;next[k]+k-1; int L&#x3D;next[i-k]; if(i+L&lt;p+1) next[i]&#x3D;L; else&#123; j&#x3D;max(0,p-i+1); while(i+j&lt;m &amp;&amp; xi+j]&#x3D;&#x3D;x[j]) j++; next[i]&#x3D;j; k&#x3D;i; &#125; &#125; &#125; void ekmp(string x, string y, int next[], int extend[])&#123; ekmp_pre(x,next); int j&#x3D;0; int m&#x3D;x.length(), n&#x3D;y.length(); while(j&lt;n &amp;&amp; j&lt;m &amp;&amp; x[j]&#x3D;&#x3D;y[j]) j++; extend[0]&#x3D;j; int k&#x3D;0; for(int i&#x3D;1; i&lt;n; i++)&#123; int p&#x3D;extend[k]+k-1; int L&#x3D;next[i-k]; if(i+L&lt;p+1) extend[i]&#x3D;L; else&#123; j&#x3D;max(0,p-i+1); while(i+j&lt;n &amp;&amp; j&lt;m &amp;&amp; y[i+j]&#x3D;&#x3D;x[j]) j++; extend[i]&#x3D;j; k&#x3D;i; &#125; &#125; &#125; 假设我们已经知道 next[] , 如何求 extend[] 呢？ 此处变量设置会和🐎有所出入，主要是理解过程😅 ① 假设当前 S 串遍历到位置i, 即extend[0...i-1]的值均以求出；首先设置两个变量，a 和 p，p 代表以a为起始位置的字符匹配成功的最右边界，’p = 最后一个匹配成功位置+1’ ，即 S[a...p) == P[0...p-a)，假设下面基于S[i] 对应 P[i-a] 的几种情况开始讨论： ② 如图所示，如果 i+next[i-a] &lt; p ，根据 next[] 数组的定义，易知 extend[i] = next[i-a] ③ 如果 i+next[i-a] == p ，此时S[p]!=P[p-a] 且P[p-i]!=P[p-a]，但是S[p]==P[p-i]的可能仍然存在，所以直接从 S[p] 与 P[p-i] 开始向后匹配即可 ④ 如果 i+next[i-a] &gt; p ，此时说明 S[i...p) 与 P[i-a...p-a]相同，注意到 S[p]!=P[p-a] 并且 P[p-i]==P[p-a]，即 S[p]!=T[p-i] ，所以没必要继续往下判断了，故赋值extend[i]=p-i ⑤ 由上面的过程，求解next[i]的过程即为 P 自己和自己匹配的过程，over 需要细品 题单Solution 0x01 剪花布条 HDU-2087 link 0x02 Secret HDU-6153 link 0x03 Cow Patterns POJ-3167 link … 待更 kmp 和 exkmp 整的头晕….","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"SpringMVC学习杂记","slug":"note/springMVC","date":"2021-09-15T18:37:28.000Z","updated":"2022-01-22T09:37:58.349Z","comments":true,"path":"/post/note/springMVC.html","link":"","permalink":"https://maskros.top/post/note/springMVC.html","excerpt":"SpringMVC","text":"SpringMVC学习杂记 注：杂记即为看到啥记啥 毫无章法 乱jb记 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等 SpringSpring 是最受欢迎的企业级 Java 应用程序开发的轻量级框架 Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践 三层架构 表现层 web层 MVC是表现层的一个设计模型 业务层 service层 持久层 dao层 优良特性 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API 控制反转：IOC——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。 依赖注入：DI——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。 面向切面编程：Aspect Oriented Programming——AOP 容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC） 体系结构 MVC职责分析 Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 MVC框架需要做哪些事情： 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求—调用相关的业务处理—封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . Servletjsp：本质就是一个servlet 添加pom依赖 新建空Maven项目 Add Framework Support 选择Web Application添加 变成web项目 导入servlet和jsp的依赖 编写一个Servlet类，用来处理用户的请求 public class HelloServlet extends HttpServlet 在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp 在web.xml中注册Servlet 配置Tomcat 并启动测试 SpringMVC Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量 级Web框架 Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁 中心控制器Spring MVC框架以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080 服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 配置版 配置web.xml ， 注册DispatcherServlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"> &lt;!--1.注册DispatcherServlet--> &lt;servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value> &lt;/init-param> &lt;!--启动级别-1--> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!--/ 匹配所有的请求；（不包括.jsp）--> &lt;!--/* 匹配所有的请求；（包括.jsp）--> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;/beans> 添加 处理映射器 &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/> 添加 处理器适配器 &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/> 添加 视图解析器 &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"> &lt;!--前缀--> &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/> &lt;!--后缀--> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； package com.maskros.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //注意：这里我们先导入Controller接口 public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; &#125; &#125; 将自己的类交给SpringIOC容器，注册bean &lt;!--Handler--> &lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/> 写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; $&#123;msg&#125; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 配置tomcat启动测试 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ ※注解版 由于Maven可能存在资源过滤的问题，我们将配置完善 &lt;build> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;includes> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;/resources> &lt;/build> 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入 配置 web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"> &lt;!--1.注册servlet--> &lt;servlet> &lt;servlet-name>SpringMVC&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value> &lt;/init-param> &lt;!-- 启动顺序，数字越小，启动越早 --> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!--所有请求都会被springmvc拦截 --> &lt;servlet-mapping> &lt;servlet-name>SpringMVC&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 会匹配 .jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错 添加 SpringMVC 配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --> &lt;context:component-scan base-package=\"com.kuang.controller\"/> &lt;!-- 让Spring MVC不处理静态资源 --> &lt;mvc:default-servlet-handler /> &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --> &lt;mvc:annotation-driven /> &lt;!-- 视图解析器 --> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"> &lt;!-- 前缀 --> &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /> &lt;!-- 后缀 --> &lt;property name=\"suffix\" value=\".jsp\" /> &lt;/bean> &lt;/beans> 创建 Contronller @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 // 编写控制类 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/HelloController\") public class HelloController &#123; //真实访问地址 : 项目名/HelloController/hello @RequestMapping(\"/hello\") public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\",\"hello,SpringMVC\"); //web-inf/jsp/hello.jsp return \"hello\"; &#125; &#125; 创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息 &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;SpringMVC&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; $&#123;msg&#125; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 配置 Tomcat 运行 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 控制器和RestFul 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种，一般使用注解@Controller 实现Controller接口 mvc的配置文件只留下 视图解析器 ControllerTest1 //定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; &#125; &#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 &lt;bean name=\"/t1\" class=\"com.maskros.controller.ControllerTest1\"/> 编写前端test.jsp &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; $&#123;msg&#125; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --> &lt;context:component-scan base-package=\"com.kuang.controller\"/> 增加一个ControllerTest2类，使用注解实现 //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2&#123; //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; &#125; &#125; 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 @RequestMapping 使用 @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径 // 只注解在方法上面 @Controller public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125; &#125; //访问路径：http://localhost:8080 / 项目名 / h1 // 同时注解类与方法@Controller @RequestMapping(\"/admin\") public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125; &#125; //访问路径：http://localhost:8080 / 项目名/ admin /h1 RestFul风格 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。localhost:8080/a/b/c/d/…… 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上 @Controller public class RestFulController &#123; //映射访问路径 @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\") public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; &#125; &#125; 使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 //映射访问路径,必须是POST请求 @RequestMapping(value = \"/hello\",method = &#123;RequestMethod.POST&#125;) public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\"; &#125; // 我们使用浏览器地址栏进行访问默认是Get请求，会报错405 // 如果将POST修改为GET则正常了 //映射访问路径,必须是Get请求 @RequestMapping(value = \"/hello\",method = &#123;RequestMethod.GET&#125;) public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\"; &#125; Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\\ 所有的地址栏请求默认都会是 HTTP GET 类型的 方法级别的注解变体有如下几个：组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多, 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式 数据处理和跳转转发 重定向 接受请求参数以及数据回显 @RequestParam(\"xxx\") //必须要求传这个参数 Json JavaScript Object Notation, JS 对象标记 是一种轻量级的数据交换格式，目前使用特别广泛，采用完全独立于编程语言的文本格式来存储和表示数据 @Controller：定义一个控制器类， @RestController： 注解相当于 @Controller ＋ @ResponseBody 合在一起的作用。 @ResponseBody：标记Controller类中的方法。把return的结果变成JSON对象返回。 语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值 &#123;\"name\": \"QinJiang\"&#125; &#123;\"age\": \"3\"&#125; &#123;\"sex\": \"男\"&#125; Json 和 JavaScript 对象互转： JSON.parse() //从JSON字符串转换为JavaScript 对象 JSON.stringify() //从JavaScript 对象转换为JSON字符串 Controller返回Json数据Jackson使用导入它的jar包 配置SpringMVC 编写Controller时需要运用到两个新东西：@ResponseBody，ObjectMapper对象 乱码处理 FastJson使用 阿里开发 方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换 乱码问题&lt;!-- Json乱码问题配置 --> &lt;mvc:annotation-driven> &lt;mvc:message-converters register-defaults=\"true\"> &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"> &lt;constructor-arg value=\"UTF-8\"/> &lt;/bean> &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"> &lt;property name=\"objectMapper\"> &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"> &lt;property name=\"failOnEmptyBeans\" value=\"false\"/> &lt;/bean> &lt;/property> &lt;/bean> &lt;/mvc:message-converters> &lt;/mvc:annotation-driven> Ajax Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 可以通过 iframe 标签来伪造一个Ajax 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 …. jQuery.ajax Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据 jQuery是一个库，提供大量的JavaScript函数 jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 Ajax异步加载数据实现了数据回显 &lt;script> $(function () &#123; $(\"#btn\").click(function () &#123; $.post(\"$&#123;pageContext.request.contextPath&#125;/a2\",function (data) &#123; console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) &#123; html+= \"&lt;tr>\" + \"&lt;td>\" + data[i].name + \"&lt;/td>\"+ \"&lt;td>\" + data[i].age + \"&lt;/td>\" + \"&lt;td>\" + data[i].sex + \"&lt;/td>\" + \"&lt;/tr>\" &#125; //html拼接 $(\"#content\").html(html); &#125;); &#125;) &#125;) &lt;/script> 拦截器Interceptor SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。可用于验证用户是否登录 (认证用户) 过滤器和拦截器的区别： 过滤器： servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 (是AOP思想的具体应用) 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 想要自定义拦截器，必须实现 HandlerInterceptor 接口 在springmvc的配置文件中配置拦截器 &lt;!--关于拦截器的配置--> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;!--/** 包括路径及其子路径--> &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--> &lt;!--/admin/** 拦截的是/admin/下的所有--> &lt;mvc:mapping path=\"/somewhere/**\"/> &lt;!--拦截somewhere下的 somewhere用@RequestMapping()配置 --> &lt;!--bean配置的就是拦截器--> &lt;bean class=\"com.maskros.interceptor.MyInterceptor\"/> &lt;/mvc:interceptor> &lt;/mvc:interceptors> 每写一个拦截器要到xml中配置这个拦截器 exp：未登录时点击主页按钮会被拦截器重定向到登录页面 杂记SpringMVC + Vue + SpringBoot + SpringCloud + Linux Spring：IOC 和 AOP SpringMVC：SpringMVC的执行流程，SSM框架整合 SSM = javaweb做项目 MVC：模型 (dao, service) , 视图 (jsp) , 控制器 (servlet) servlet: 转发 重定向 前端 数据传输 实体类 实体类：用户名 密码 生日 ….. n个 前端：用户名 密码 pojo: User vo: UserVo MVVM: M - V - VM (ViewModel: 双向绑定) form表单 method: get/post &lt;form action&#x3D;&quot;&#x2F;hello&quot; method&#x3D;&quot;post&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;method&quot;&gt; &lt;input type&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;form&gt; Spring: 大杂烩，我们可以将SpringMVC中所有要用到的Bean，注册到Spring中 访问网站：-&gt; Servlet(中转调度) &lt;=&gt; Service -&gt; Dao -&gt; Sql 前后端分离时代： 后端部署后端，提供接口，提供数据：json 前端独立部署，负责渲染后端的数据 js: 函数：闭包() () Dom id, name, tag create, remove Bom window document ES6: import require js: data:&#123;'name':$(\"#username\").val()&#125;, // data传键值对 &#123;x:y&#125; .val()==value 左边的name对应controller的name 右边的username对应下面输入框的id,加#才能取到！ IDEA alt+insert 快捷键 实现接口等等","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"java","slug":"java","permalink":"https://maskros.top/tags/java/"},{"name":"springMVC","slug":"springMVC","permalink":"https://maskros.top/tags/springMVC/"}]},{"title":"STL使用手册","slug":"algorithm/learn/STL使用手册","date":"2021-08-13T06:15:31.000Z","updated":"2022-03-24T06:40:35.653Z","comments":true,"path":"/post/algorithm/learn/STL使用手册.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/STL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html","excerpt":"Standard Template Library","text":"STL使用手册Standard Template Library 又名《👴怕忘了先把他写下来》 我 是 谁 ?斯丹德儿的 坦普雷特 莱博瑞 即标准模板库 重要特点：数据结构和算法的分离 重要特性：不是面向对象的 逻辑层次：体现了泛型化程序设计的思想 实现层次：以一种类型参数化的方式实现，基于模板(template) 六大组件： 容器（Container），是一种数据结构，如list，vector，deques ，以模板类的方法提供 ; 迭代器（Iterator），提供了访问容器中对象的方法。迭代器就如同一个指针。C++的指针也是一种迭代器。迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象； 算法（Algorithm），是用来操作容器中的数据的模板函数。如sort()，find()，函数本身与他们操作的数据的结构和类型无关 ; 仿函数（Functor） 适配器（Adaptor） 分配器（allocator） 👴 常用的 以下不按顺序，想到啥就写啥，有个🥚的顺序 容器string字符串 &#x2F;&#x2F;构造函数 string s(str,index); &#x2F;&#x2F;将字符串str内“始于位置index”的部分当作字符串的初值 string s(str,index,n); &#x2F;&#x2F;将字符串str内“始于index且长度顶多n”的部分作为字符串的初值 string s(n,c); &#x2F;&#x2F;生成一个字符串，包含n个c字符(char) string s(str.begin(),str.end()); &#x2F;&#x2F;以区间begin():end() (不包含end())内的字符作为字符串s的初值 &#x2F;&#x2F;操作函数 s.erase(s.begin(),s.end()); &#x2F;&#x2F;删除 s.replace(pos,len,str); &#x2F;&#x2F;替换，从pos开始长为len被替换为str s.find(str,pos&#x3D;0); &#x2F;&#x2F;从pos向右查找，返回str第一次出现的位置 s.rfind(str,pos&#x3D;npos); &#x2F;&#x2F;从pos反向查找，返回找到位置 s.find_first_of(str); &#x2F;&#x2F;查找第一个属于str中字符的位置 s.find_first_not_of(str); &#x2F;&#x2F;查找第一个不属于str中字符位置 s.find_last_of(str); s.find_last_not_of(str); s1.compare(s2); &#x2F;&#x2F;比较，相等0大于1小于-1 s1.compare(pos,len,s2)&#x2F;&#x2F;从s1的pos开始长为len与s2比较 stringstream自动且直接的类型转换 stringstream sstream; &#x2F;&#x2F;数据类型转换 string str; int a&#x3D;123; sstream &lt;&lt; a; sstream &gt;&gt; str; cout&lt;&lt;str; cout&lt;&lt;sstream.str(); &#x2F;&#x2F;多个字符串拼接 sstream &lt;&lt; &quot;xxxx&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;aaaaa&quot;; &#x2F;&#x2F;清空stringstream sstream.clear(); sstream.str(&quot;&quot;); pair便携结构体 &#x2F;&#x2F;访问通过first second &#x2F;&#x2F;可以通过一般运算符比较，先比较first再second pair&lt;string,int&gt; p (str,123); pair&lt;string,int&gt; p &#x3D; make_pair(str,123); vector向量容器，动态存储 vector&lt;int&gt; v; v.front(); v.back(); v.begin(); v.end(); v.push_back(); v.size(); v.empty(); v.clear(); v.pop_back(); &#x2F;&#x2F;删除表尾元素 v.insert(it,x); &#x2F;&#x2F;向迭代器it 指向的元素前插入新元素x v.insert(it,n,x); &#x2F;&#x2F;插入n个x v.insert(it, first, last); &#x2F;&#x2F;将由迭代器first和last 所指定的序列[first, last)插入到迭代器it指向的元素前面 v.erase(it); &#x2F;&#x2F;删 v.erase(first,last); v.reverse(n); &#x2F;&#x2F;预分配缓冲空间，使存储空间至少可容纳n个元素 v.resize(n); &#x2F;&#x2F;改变序列长度，超出元素删除，若源空间小于n，则默认值填满空间 v.resize(n,val); &#x2F;&#x2F;超出的用val填满 stack栈 stack&lt;int&gt; s; s.push(x); s.pop(); s.top(); s.empty(); s.size(); queue队列，优先队列，双端队列 &#x2F;&#x2F; queue queue&lt;int&gt; q; q.push(x); q.pop(); q.front(); q.back(); q.empty(); q.size(); &#x2F;&#x2F; priority_queue priority&lt;int&gt; q; &#x2F;&#x2F;默认大者优先 priority&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; &#x2F;&#x2F;小的先出队 三个模板参数：元素类型，容器类型，比较算子 &#x2F;&#x2F; 优先级设置：定义结构体 struct Student&#123; int num; int grade; friend bool operator &lt; (Student s1, Student s2)&#123; return s1.grade&lt;s2.grade; &#x2F;&#x2F;此处小于号还是小于的作用，故队列中以成绩高的学生优先，若反之变号即可 &#125; &#125;; priority_queue&lt;Student&gt; q; &#x2F;&#x2F;也可以把重载的函数写在结构体外面 struct cmp&#123; bool operator() (Student s1, Student s2)&#123; return s1.grade&lt;s2.grade; &#125; &#125;;&#x2F;&#x2F;tips:优先队列中的cmp和sort中的cmp效果相反 priority_queue&lt;Student,vector&lt;Student&gt;,cmp&gt; q; &#x2F;&#x2F;如果结构体内数据庞大，像出现字符串或者数组，建议使用引用来提高效率。此时比较类的参数需要加上 const 和 &amp; friend bool operator &lt; (const Student &amp;s1, const Student &amp;s2)&#123; return s1.grade&lt;s2.grade; &#125; &#x2F;&#x2F;deque deque&lt;int&gt; d; d.push_back(x); &#x2F;&#x2F;尾部插入 d.push_front(x); &#x2F;&#x2F;首部插入元素 d.insert(d.begin()+len,x); &#x2F;&#x2F;中间插入元素 &#x2F;&#x2F;可以通过 d[0] d[1] 访问 d.pop_front(); &#x2F;&#x2F;删除头部 d.pop_back(); d.erase(d.begin()+len); &#x2F;&#x2F;删除指定位置元素，可以写多个 map键值对，元素按关键字有序，内部红黑树 &#x2F;&#x2F; map空间占用率高 map&lt;string,int&gt; m; m[key]&#x3D;value; m.insert(make_pair(key,value)); m.erase(key); m.erase(it); m.clear(); m.size(); map&lt;string,int&gt;::iterator it; for(it&#x3D;mp.begin();it!&#x3D;mp.end();++it)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; &#x2F;&#x2F; unordered_map 效率较高 内部哈希表 &#x2F;&#x2F; 对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map set无重复，按键值自动排序 数据结构为红黑树。以节点形式保存（动态)，用迭代器访问 set&lt;int&gt; s; s.begin(); s.end(); s.clear(); s.empty(); s.erase(x); s.find(x); s.insert(x); s.size(); s.lower_bound(value); &#x2F;&#x2F;返回第一个大于等于value的定位器 s.upper_bound(value); &#x2F;&#x2F;返回最后一个大于等于value的定位器 set&lt;int&gt;::iterator it; for(it&#x3D;s.begin();it!&#x3D;s.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; list链表 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector 如果你需要大量的插入和删除，而不关心随即存取，则应使用list 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque list&lt;int&gt; a(n); list&lt;int&gt; a&#123;1,2,3,4&#125;; a.push_back(x); a.push_front(x); a.empty(); a.resize(n); a.clear(); a.front(); a.back(); a.reverse(); a.merge(b); &#x2F;&#x2F;b变空，a尾插入b a.insert(pos,x); a.insert(pos,b.begin(),b.end()); a.erase(a.begin(),a.end()); a.remove(x); bitset存放二进制0/1的容器，可以声明非常大的二进制位而不限于64，用来优化 bitset&lt;N&gt; b; &#x2F;&#x2F;表示长为N的二进制串 &#x2F;&#x2F; 通过b[pos]访问 b.any(); &#x2F;&#x2F;存在为1的二进制位 b.none(); &#x2F;&#x2F;不存在为1的二进制位 b.count(); &#x2F;&#x2F;置1的二进制位的个数 b.size(); b.test(pos); &#x2F;&#x2F;在pos位处是否为1 b.set(); &#x2F;&#x2F;所有位置1 b.set(pos); b.reset(); &#x2F;&#x2F;所有位置0 b.reset(pos); b.flip(); &#x2F;&#x2F;逐位取反 b.flip(pos); functions查找&#x2F;&#x2F; 对于sort(a, a + n) 升序排列 lower_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于等于x的位置 upper_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于x的位置 &#x2F;&#x2F; 对于sort(a, a + n, greater&lt;int&gt;()) 降序排列 lower_bound(a,a+n,x,greater&lt;int&gt;(); &#x2F;&#x2F;二分查找第一个小于等于x的位置 upper_bound(a,a+n,x,greater&lt;int&gt;(); &#x2F;&#x2F;二分查找第一个小于x的位置 find(); rfind(); 排序sort(a,a+n,cmp); &#x2F;&#x2F;默认ASC 修改swap(a,b); &#x2F;&#x2F;交换 replace(pos,len,str); &#x2F;&#x2F;替换 unique(a,a+n); &#x2F;&#x2F;去除相邻的重复元素,会把重复的藏到末尾，使用前需要先排序 排列next_permutation(a,a+n); &#x2F;&#x2F;下一个全排列 prev_permutation(a,a+n); &#x2F;&#x2F;上一个全排列 &#x2F;&#x2F;函数返回bool值，一般配合while() 其他__builtin_popcount(n); &#x2F;&#x2F;返回n的二进制1的个数 isalpha(char x); &#x2F;&#x2F;小写字母返回2，大写字母1，非字母0 tolower(char x); toupper(char x); &#x2F;&#x2F;返回小写，大写字母的ASCII值，非字母则相等 &#x2F;&#x2F;海伦公式 p&#x3D;(a+b+c)&#x2F;2; s&#x3D;sqrt(p*(p-a)*(p-b)*(p-c)); abs(int x); &#x2F;&#x2F;只用于整数 fabs(double x); &#x2F;&#x2F;精度更高 暂时就这些了，寄！","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"我确实不会线段树","slug":"algorithm/learn/线段树","date":"2021-08-06T08:14:31.000Z","updated":"2022-01-25T10:28:54.978Z","comments":true,"path":"/post/algorithm/learn/线段树.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"Segment Tree","text":"线段树Segment Tree 一个问题，只要能化成对一些连续点l的修改和统计问题，基本就可以用线段树来艹了 原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2,b]。 作用：对编号连续的一些点的区间信息进行修改或者统计操作，用线段树统计的东西，必须符合区间加法。与树状数组不同的是，线段树不止适用于区间求和的查询，也可以进行区间最大值，区间最小值，或者区间异或值的查询。 主要操作：区间查询、点更新、区间更新 例如： 给定s和t，求其区间上的最小值 给定i和x，把ai的值改成x 更新和区间查询的复杂度都是 O(log(N)) 操作 build, update(内含push_down), query 建树 (build)线段树是一棵平衡二叉树，每个节点都对应一条线段(区间)，反之不成立，每个节点 的左右子节点的编号分别为 和 ，假如节点 储存区间 的和，设 ，那么两个子节点分别储存 和 的和。可以发现，左节点对应的区间长度，与右节点相同或者比之恰好多 。 故建树可考虑递归进行： void build(ll l = 1, ll r = n, ll p = 1) { if (l == r) // 到达叶子节点 tree[p]=A[l]; // 用数组中的数据赋值 else{ ll mid = (l + r) / 2; build(l, mid, p * 2); // 先建立左右子节点 build(mid + 1, r, p * 2 + 1); tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 该节点的值等于左右子节点之和 } } 这里👴偷了个 gif 来演示一下过程 (虽然大部分都是偷的🤡) 区间修改(update)首先定义”懒标记“(即“延迟标记”) mark[]： 对于区间修改，朴素的想法是用递归的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个标记，将来要用到它的子区间的时候，再向下传递 直接上🐴 (非最简): void update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n) { if (cl &gt; r || cr &lt; l) // 区间无交集 return; // 剪枝 else if (cl &gt;= l &amp;&amp; cr &lt;= r) // 当前节点对应的区间包含在目标区间中 { tree[p] += (cr - cl + 1) * d; // 更新当前区间的值 if (cr &gt; cl) // 如果不是叶子节点 mark[p] += d; // 给当前区间打上标记 } else // 与目标区间有交集，但不包含于其中 { ll mid = (cl + cr) / 2; mark[p * 2] += mark[p]; // 标记向下传递 mark[p * 2 + 1] += mark[p]; tree[p * 2] += mark[p] * (mid - cl + 1); // 往下更新一层 tree[p * 2 + 1] += mark[p] * (cr - mid); mark[p] = 0; // 清除标记 update(l, r, d, p * 2, cl, mid); // 递归地往下寻找 update(l, r, d, p * 2 + 1, mid + 1, cr); tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 根据子节点更新当前节点的值 } } 更新时，我们是从最大的区间开始，递归向下处理。注意到，任何区间都是线段树上某些节点的并集。于是我们记目标区间为 ，当前区间为 ， 当前节点为 ，我们会遇到三种情况： 当前区间与目标区间没有交集： 直接结束递归 当前区间被包括在目标区间里： 可以更新区间，不能忘记乘上区间长度 tree[p] += (cr - cl + 1) * d; 然后打上懒标记（叶子节点可以不打标记，因为不会再向下传递了） mark[p] += d; //表示“该区间上每一个点都要加上d”。因为原来可能存在标记，所以是+=而不是= 当前区间与目标区间相交，但不包含于其中: 这时把当前区间一分为二，分别进行处理。如果存在懒标记，要先把懒标记传递给子节点（注意也是+=，因为原来可能存在懒标记) ll mid = (cl + cr) / 2; mark[p * 2] += mark[p]; mark[p * 2 + 1] += mark[p]; 两个子节点的值也就需要相应的更新（后面乘的是区间长度) :[p * 2] += mark[p] * (mid - cl + 1); tree[p * 2 + 1] += mark[p] * (cr - mid); 不要忘记清除该节点的懒标记： mark[p]=0; 因为贵标记和👴一样是个懒蛋，只往下传递一层，所以这个过程并不是递归的，以后要用再才继续传递。其实我们常常把这个传递过程封装成一个函数扑屎裆 : inline void push_down(ll p, ll len){ mark[p * 2] += mark[p]; mark[p * 2 + 1] += mark[p]; tree[p * 2] += mark[p] * (len - len / 2); tree[p * 2 + 1] += mark[p] * (len / 2); // 右边的区间可能要短一点 mark[p] = 0; } //这样儿 update() 里面调用的时候直接 push_down(p, cr - cl + 1); 就彳亍 传递完标记后，再递归地去处理左右两个子节点就彳亍乐 下面儿👴又偷了个视频展示一下区间 加上 的过程： 至于单点修改，只需要令左右端点相等即可~ 区间查询(query)还就那个直接上🐴 ll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n){ if (cl &gt; r || cr &lt; l) return 0; else if (cl &gt;= l &amp;&amp; cr &lt;= r) return tree[p]; else{ ll mid = (cl + cr) / 2; push_down(p, cr - cl + 1); return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr); // 上一行拆成三行写就和区间修改格式一致了 } } 一样的递归，一样自顶至底地寻找，一样的合并信息，即插即用😍 模板 source : 洛谷P3372 【模板】线段树 1 题目描述如题，已知一个数列，你需要进行下面两种操作：1.将某区间每一个数加上x2.求出某区间每一个数的和输入格式第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。接下来M行每行包含3或4个整数，表示一个操作，具体如下：操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和输出格式输出包含若干行整数，即为所有操作2的结果。 tips: 本模板分为龙鸣版和贵族版 龙鸣version (此龙鸣非彼龙鸣，意为把上面的龙鸣🐴整合起来): #define MAXN 100005 ll n, m, A[MAXN], tree[MAXN * 4], mark[MAXN * 4]; inline void push_down(ll p, ll len){ mark[p * 2] += mark[p]; mark[p * 2 + 1] += mark[p]; tree[p * 2] += mark[p] * (len - len / 2); tree[p * 2 + 1] += mark[p] * (len / 2); mark[p] = 0; } void build(ll l = 1, ll r = n, ll p = 1){ if (l == r) tree[p] = A[l]; else{ ll mid = (l + r) / 2; build(l, mid, p * 2); build(mid + 1, r, p * 2 + 1); tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } void update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n){ if (cl &gt; r || cr &lt; l) return; else if (cl &gt;= l &amp;&amp; cr &lt;= r){ tree[p] += (cr - cl + 1) * d; if (cr &gt; cl) mark[p] += d; } else{ ll mid = (cl + cr) / 2; push_down(p, cr - cl + 1); update(l, r, d, p * 2, cl, mid); update(l, r, d, p * 2 + 1, mid + 1, cr); tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } ll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n){ if (cl &gt; r || cr &lt; l) return 0; else if (cl &gt;= l &amp;&amp; cr &lt;= r) return tree[p]; else{ ll mid = (cl + cr) / 2; push_down(p, cr - cl + 1); return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr); } } int main(){ n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) A[i] = read(); build(); for (int i = 0; i &lt; m; ++i){ ll opr = read(), l = read(), r = read(); if (opr == 1){ ll d = read(); update(l, r, d); } else printf(\"%lld\\n\", query(l, r)); } return 0; } 贵族version 豪华升级plus，本来想加个乘除的发现板子不兼容，👴是懒狗 const int MAXN = 1e5 + 5; ll tree[MAXN &lt;&lt; 2], mark[MAXN &lt;&lt; 2], n, m, A[MAXN]; void push_down(int p, int len){ tree[p &lt;&lt; 1] += mark[p] * (len - len / 2); mark[p &lt;&lt; 1] += mark[p]; tree[p &lt;&lt; 1 | 1] += mark[p] * (len / 2); mark[p &lt;&lt; 1 | 1] += mark[p]; mark[p] = 0; } void build(int p = 1, int cl = 1, int cr = n){ if (cl == cr) { tree[p] = A[cl]; return; } int mid = (cl + cr) &gt;&gt; 1; build(p &lt;&lt; 1, cl, mid); build(p &lt;&lt; 1 | 1, mid + 1, cr); tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]; } ll query(int l, int r, int p = 1, int cl = 1, int cr = n){ if (cl &gt;= l &amp;&amp; cr &lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) &gt;&gt; 1, ans = 0; if (mid &gt;= l) ans += query(l, r, p &lt;&lt; 1, cl, mid); if (mid &lt; r) ans += query(l, r, p &lt;&lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n){ if (cl &gt;= l &amp;&amp; cr &lt;= r) { tree[p] += d * (cr - cl + 1), mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) &gt;&gt; 1; if (mid &gt;= l) update(l, r, d, p &lt;&lt; 1, cl, mid); if (mid &lt; r) update(l, r, d, p &lt;&lt; 1 | 1, mid + 1, cr); tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]; } 常见模型步骤： 将问题转化成点信息和目标信息 将目标信息根据需要扩充成区间信息 增加信息符合区间加法 增加标记支持区间操作 代码中的主要模块：区间加法，标记下推，点信息-&gt;区间信息，各种操作(修改、查询…) 字符串哈希 URAL1989 Subpalindromes 题解 给定一个字符串(长度&lt;=100000)，有两个操作。 1：改变某个字符。 2：判断某个子串是否构成回文串 分析： 直接判断会超时，此处用 线段树维护字符串哈希 对于一个字符串它对应的哈希函数为$a[0]+a[1]K + a[2]K^2 +…+a[n-1]*K^{n-1}$ 再维护一个从右往左的哈希值： $a[0]K^{n-1} + a[1]K^{n-2} +…+a[n-1]$ 若是回文串，则左右的哈希值会相等。而左右哈希值相等，则很大可能这是回文串。 若出现误判，可以再用一个K2，进行二次哈希判断，可以减小误判概率。实现上，哈希值最好对某个质数取余数，这样分布更均匀。 解题模型： 目标信息：某个区间的左，右哈希值 点信息：一个字符 目标信息已经符合区间加法，所以区间信息=目标信息 故线段树结构： 区间信息：区间哈希值 点信息：一个字符 核心：就是找到区间信息， 写好区间加法 最长连续零 Codeforces 527C Glass Carving 题解 给定一个矩形，不停地纵向/横向切割，问每次切割后，最大的矩形面积是多少 分析： 最大矩形面积=最长的长*最宽的宽 长宽范围均为1e5，故用01序列表示每个点是否被切割 最长的长就是长的最长连续0的数量+1，宽同理，于是可用用线段树维护最长连续零 解题模型： 目标信息：区间最长连续零的个数 点信息：0或1 由于目标信息不符合区间加法，所以要扩充目标信息 故线段树结构： 区间信息：从左，右开始的最长连续零，本区间是否全零，本区间最长连续零 点信息：0或1 计数排序 Codeforces 558E A Simple Task 题解 给定一个长度不超过1e5的字符串（小写英文字母），和不超过5000个操作，每个操作 L R K 表示给区间[L,R]的字符串排序，K=1为升序，K=0为降序。 最后输出最终的字符串 解题模型： 目标信息：区间的计数排序结果 点信息：一个字符 目标信息是符合区间加法的，但是为了支持区间操作，还是需要扩充信息 故线段树结构： 目标信息：区间的计数排序结果，排序标记，排序种类（升降） 点信息：一个字符 To be continued…","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"博弈论","slug":"algorithm/learn/博弈论","date":"2021-07-31T01:51:28.000Z","updated":"2022-02-04T15:44:39.081Z","comments":true,"path":"/post/algorithm/learn/博弈论.html","link":"","permalink":"https://maskros.top/post/algorithm/learn/%E5%8D%9A%E5%BC%88%E8%AE%BA.html","excerpt":"Game Theory","text":"博弈论Game Theory Nim游戏属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下： 两名选手交替移动，在有限的合法移动集合中任选一种进行移动 对于任何一种局面，合法的移动集合只取决于局面本身 到谁无法移动谁就输了 以下给出 P/N 的定义： P-Position：先手必败点 (Previous) N-Position：先手必胜点 (Next) 可知所有终结点都是P点，一步就能到P点的一定是N点，通过一步只能到N点的一定是P点 下面来说说Nim游戏：“有若干堆石子，每堆石子的数量有限，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为没有任何合法的移动）“，简单来想，我们可以想到一个递归的算法：对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P，那么向这个子局面的移动就是必胜策略。这其中有大量的重叠子问题，所以可以用DP或者记忆化搜索的方法以提高效率。 但是👴们已经有了一个nb的结论： 对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1^a2^…^an=0，其中^表示异或(xor)运算 根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。 Sprague-Grundy函数ICG的抽象模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负 首先定义mex(minimal excludnt) 运算： 施加于集合，表示最小的不属于这个集合的非负整数，exp: mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 下面给出SG函数的定义： 对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数如下：sg(x)=mex{ sg(y) | y是x的后继 }。 结论：当SG[x] = 0时，x为必败状态；当SG[x] &gt; 0时，x为必胜状态 所以从1~n的SG函数值应该如何计算呢？ 使用 数组 f[ ] 将可改变当前状态 的方式记录下来 然后我们使用 另一个数组 S[ ] 将当前状态x 的后继状态标记 模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x) 不断重复 2-3 的步骤，即完成计算 1-n 的SG函数值 SG定理：SG(G)=SG(G1)^SG(G2)^…^SG(Gn)，原游戏的SG函数值是它的所有子游戏的SG函数值的异或 解题模型 把原游戏分解成多个独立的子游戏，则原游戏的SG函数值就变为SG(G)=SG(G1)^SG(G2)^…^Sg(Gn) 分别考虑每一个子游戏，计算其SG值 SG值的计算方法（important）： ​ a. 可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1) （Bash game） ​ b. 可选步数为任意步，SG(x) = x（Nim game） ​ c. 可选步数为一系列不连续的数，用模板计算 板子 首选打表预处理，打表没法使的时候就怼dfs ☆打表&#x2F;&#x2F;打表 int f[N],SG[MAXN],S[MAXN]; &#x2F;&#x2F; f[] 可改变当前状态的方式(可取走石子个数) S[] 当前状态的后继状态集合 void getSG(int n) &#123; int i,j; memset(SG,0,sizeof(SG)); for(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; memset(S,0,sizeof(S)); for(j&#x3D;0; f[j]&lt;&#x3D;i &amp;&amp; j&lt;&#x3D;N;j++) S[SG[i-f[j]]]&#x3D;1; &#x2F;&#x2F;S[]数组来保存当前状态的后继状态集合 for(j&#x3D;0;j&lt;&#x3D;n;j++)&#123; if(!S[j])&#123;&#x2F;&#x2F;模拟mex运算 SG[i]&#x3D;j; break; &#125; &#125; &#125; &#125; 深搜&#x2F;&#x2F;注意 f数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍 &#x2F;&#x2F;n是集合f的大小 f[i]是定义的特殊取法规则的数组 int f[110],SG[10010],n; int SG_dfs(int x)&#123; int i; if(SG[x]!&#x3D;-1) return SG[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i&#x3D;0;i&lt;n;i++)&#123; if(x&gt;&#x3D;f[i])&#123; SG_dfs(x-f[i]); vis[SG[x-f[i]]]&#x3D;1; &#125; &#125; int e; for(i&#x3D;0;;i++) if(!vis[i])&#123; e&#x3D;i; break; &#125; return SG[x]&#x3D;e; &#125; 常见博弈Bash Game只有一堆n个物品，两个人轮流取物，每次至少取一个，最多取m个。最后取光者得胜（谁拿了最后一个谁赢） 结论：最优选择为保持给对手留下 m+1 的倍数 if(n%(m+1) != 0) 则先手必赢 if(n%(m+1) == 0) 则后手必赢 Wythoff Game 各位👴属实🐮，黄金分割数（1+√5）/2 = 1.618 都给整上了 有两堆各若干个物品，两个人轮流从某一堆取物或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜 这里用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势 由ak，bk组成的矩形近似为黄金矩形 结论： (int)((bk-ak)*(1+sqrt(5.0))/2) != ak , 先手必赢 (int)((bk-ak)*(1+sqrt(5.0))/2) == ak , 后手必赢 Nim Game若干堆石子，每堆石子的数量有限，两个人可以选择一堆石子并拿走若干颗 结论：xor 略 Fibonacci Nim有一堆个数为n的石子，游戏双方轮流取石子，满足: (1)先手不能在第一次把所有的石子取完 (2)每次可以取的石子数介于1到对手刚取的石子数的2倍之间(包含) (3) 取走最后一个石子的人为赢家 结论：当n为Fibonacci数的时候，必败 f[i]：1,2,3,5,8,13,21,34,55,89……","categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"博弈","slug":"博弈","permalink":"https://maskros.top/tags/%E5%8D%9A%E5%BC%88/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"}]},{"title":"sql学习笔记","slug":"note/sql","date":"2021-07-28T16:07:28.000Z","updated":"2022-01-22T09:36:48.564Z","comments":true,"path":"/post/note/sql.html","link":"","permalink":"https://maskros.top/post/note/sql.html","excerpt":"Structured Query Language","text":"SQL结构化查询语言-Structured Query Language @author：Maskros Type类型 字符型 VARCHAR型和CHAR型 文本型 TEXT 数值型 整数INT 、小数NUMERIC、钱数MONEY) 逻辑型 BIT 日期型 DATETIME Operation操作 增删改查 CURD tips : 不区分大小写，列名表名前``可以省略 SELECT(FROM) SELECT COLUMN 查询单个列 SELECT `column_name` FROM `table_name`; SELECT COLUMN, COLUMN 查询多个列 SELECT `column_name_1`, `column_name_2` FROM `table_name`; 使用 SELECT * 查询所有列 SELECT * FROM `table_name`; 使用 SELECT DISTINCT 查询不同行 SELECT DISTINCT `column_name` FROM `table_name` ​ 希望查询的值都是唯一不重复的 SELECT WHERE 对行进行筛选过滤 SELECT `column_name1`,`column_name2`… FROM `table_name` WHERE `column_name` operator `value`; INSERT(INTO) INSERT INTO 在不指定列的情况下插入数据 INSERT INTO `table_name` VALUES (value1, value2, value3,...); # 'value' INSERT INTO 在指定的列中插入数据 INSERT INTO `table_name` (`column1`, `column2`, `column3`,...) VALUES (value1, value2, value3,...); UPDATE(SET) UPDATE 更新数据 UPDATE `table_name` SET `column1`=value1,`column2`=value2,... WHERE `some_column`=some_value; # WHERE 可以省略 DELETE(FROM) DELETE 删除数据 DELETE FROM `table_name` WHERE `some_column` = `some_value`; TRUNCATE TABLE 清空表 Condition条件 比较运算符WHERE A OPERATOR B tips: &lt;&gt; , != 均为不等于，但用法不同 逻辑运算符 AND 连接多条件 OR 连接多条件 NOT 过滤不满足条件的数据 SELECT `column_name` FROM `table_name` WHERE NOT `condition`; # (condition1 operator condition2) 特殊条件 IN 查询多条件 Where `column_name1` IN (condition) # condition 中也可以写 IN (select `column_name1` xxxxxxxx) NOT IN 排除 SELECT * FROM `table_name` WHERE `column_name` (NOT) IN `value`; # （value1, value2） BETWEEN AND 查询两值间的数据范围 SELECT * FROM `table_name` WHERE `column_name` BETWEEN `value` AND `value`; IS NULL 查询空数据 使用 LIKE 模糊查询 SELECT * FROM `table_name` WHERE `column_name` LIKE `value`; # LIKE `D%` # 'D%' 表示以D开头的所有单词，% 表示为通配符，可以替代0~n个字符 ORDER BY &amp; LIMIT ORDER BY 对数据进行排序（一列/多列(多列按SELECT顺序)） ASC (ascend)升序(默认) | DESC(descend) 降序 SELECT &#96;column_name&#96;, &#96;column_name&#96; FROM &#96;table_name&#96; # WHERE XXXX ORDER BY &#96;column_name&#96;, &#96;column_name&#96; ASC|DESC; 使用 LIMIT 限制输出行数 offset ：是返回集的初始标注，起始点是0 count ：制定返回的数量 SELECT `column_name`, `column_name` FROM `table_name` # ORDER BY XXXX LIMIT `offset` , `count`; # offset和count通常只用一个count：LIMIT (0,)1 Function函数 算数函数 AVG() 函数求数值列的平均值 SELECT AVG(`column_name`) # AS `column2_name` FROM `table_name`; MAX() 函数返回指定列中的最大值 MIN() 函数返回指定列中的最小值 SUM() 函数统计数值列的总数 ROUND() 函数将数值四舍五入 ROUND() 返回值数据类型会被变换为一个BIGINT 。 当 decimals 为正数时，column_name 四舍五入为 decimals 所指定的小数位数。省略decimals自动保留四舍五入后的整数。当 decimals 为负数时，column_name 则按 decimals 所指定的在小数点的左边四舍五入。 SELECT ROUND(`column_name`, `decimals`) FROM `table_name`; #decimals 规定要返回的小数位数 NULL() 函数判断空值 ISNULL() SELECT ISNULL(`column_name`) FROM `table_name`; # 返回 0 或 1 IFNULL() SELECT IFNULL(`column_name`, `value`) FROM `table_name`; # 是 NULL 则返回 value 值，不是则返回对应内容 COUNT() 函数计数 # COUNT(column_name) 对列具有的行数进行计数 除去值为 NULL 的行 # 主要用于查看各列数据的数量情况，便于统计数据的缺失值 SELECT COUNT(`column_name`) FROM `table_name`; # COUNT(*) 对表中行的数目进行计数,包括 NULL 所在行和重复项所在行 # 主要用于查看表中的记录数 SELECT COUNT(*) FROM `table_name`; # COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目 SELECT COUNT(DISTINCT `column_name`) FROM `table_name`; 时间函数 NOW()，CURDATE()、CURTIME() 获取当前时间 NOW() 返回当前日期和时间 YYYY-MM-DD hh:mm:ss CURDATE() 返回当前日期 YYYY-MM-DD CURTIME() 返回当前时间 hh:mm:ss 要精确的秒以后的时间的话，可以在 () 中加数字，加多少，就表示精确到秒后多少位 DATE()、TIME() 函数提取日期和时间 EXTRACT() 函数提取指定的时间信息 FROM 返回日期/时间的单独部分 unit : YEAR (年)、MONTH (月)、DAY (日)、HOUR (小时)、MINUTE (分钟)、 SECOND (秒) SELECT EXTRACT(unit FROM date) # unit 为单独部分名 FROM `table` # date - 合法column DATE_FORMAT() 格式化输出日期 %Y 年份 %m 月份 %d 日期 %w 星期 %H 小时 %i 分钟 %s 秒 小写y 表示年份后两位，小写h表示12小时计的小时 SELECT DATE_FORMAT(date,'format'); DATE_ADD() 增加时间 INTERVAL 向日期添加指定的时间间隔 expr 是希望添加的时间间隔的数值 type : MICROSECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , QUARTER , YEAR SELECT DATE_ADD(date, INTERVAL expr type) FROM table_name DATE_SUB() 减少时间 DATEDIFF() 和 TIMESTAMPDIFF() 计算日期差 时间1-时间2 DATEDIFF() 默认只能计算天数差 SELECT DATEDIFF(时间1,时间2) AS date_diff FROM courses; TIMESTAMPDIFF() 计算相差年月周日时 类型YEAR,MONTH,WEEK,DAY,HOUR SELECT TIMESTAMPDIFF (类型,时间1,时间2) AS year_diff； Constraints约束 NOT NULL非空约束 强制列不接受 NULL 值 # 建表 CREATE TABLE &#96;Persons&#96; ( &#96;ID&#96; int NOT NULL, &#96;LastName&#96; varchar(255) ); # 已建表 ALTER TABLE &#96;Persons&#96; MODIFY &#96;Age&#96; int NOT NULL; # 撤销 ALTER TABLE &#96;Persons&#96; MODIFY &#96;Age&#96; int NULL; UNIQUE唯一约束 不希望出现重复记录 CONSTRAINT 命名 DROP 撤销 # 建表 ## MySQL CREATE TABLE `Persons`( `P_Id` int NOT NULL, UNIQUE (`P_Id`) ) ## SQL Server / Oracle / MS Access CREATE TABLE `Persons`( `P_Id` int NOT NULL UNIQUE, ) ## 命名+多列 CREATE TABLE `Persons`( `P_Id` int NOT NULL, `LastName` varchar(255) NOT NULL, CONSTRAINT uc_PersonID UNIQUE (`P_Id`,`LastName`) ) # 已建 ALTER TABLE `Persons` ADD UNIQUE（`P_Id`） ## 多列 ALTER TABLE `Persons` ADD CONSTRAINT uc_PersonID UNIQUE (`P_Id`,`LastName`) # 撤销 ## MySQL ALTER TABLE `Persons` DROP INDEX uc_PersonID ## SQL Server / Oracle / MS Access ALTER TABLE `Persons` DROP CONSTRAINT uc_PersonID PRIMARY KEY主键约束 简单的说，PRIMARY KEY = UNIQUE + NOT NULL NOT NULL UNIQUE 可以将表的一列或多列定义为唯一性属性，而 PRIMARY KEY 设为多列时，仅能保证多列之和是唯一的，具体到某一列可能会重复。 PRIMARY KEY 可以与外键配合，从而形成主从表的关系 PRIMARY KEY 一般在逻辑设计中用作记录标识，这也是设置 PRIMARY KEY 的本来用意，而 UNIQUE 只是为了保证域/域组的唯一性 # 建表 ## MySQL CREATE TABLE `Persons( `P_Id` int NOT NULL, PRIMARY KEY (`P_Id`) ); ## SQL Server / Oracle / MS Access CREATE TABLE `Persons`( `P_Id` int NOT NULL PRIMARY KEY, ) ## 命名+多列 CONSTRAINT pk_PersonID PRIMARY KEY (`P_Id`,`LastName`) # 已建 ALTER TABLE `Persons` ADD PRIMARY KEY (`P_Id`) ## 多列 ALTER TABLE `Persons` ADD CONSTRAINT pk_PersonID PRIMARY KEY (`P_Id`,`LastName`) # 撤销 ## MySQL ALTER TABLE `Persons` DROP PRIMARY KEY ## SQL Server / Oracle / MS Access ALTER TABLE `Persons` DROP CONSTRAINT pk_PersonID FOREIGN KEY外键约束 一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY 保证数据的完整性和一致性 在两个表之间建立关系，需要指定引用主表的哪一列，REFERENCES 表示引用一个表 # 建表 ## MySQL CREATE TABLE `Orders`( `P_Id` int, FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) ) ## SQL Server / Oracle / MS Access CREATE TABLE `Orders`( P_Id int FOREIGN KEY REFERENCES Persons(P_Id) ) ## 命名+多列 CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) # 已建 ALTER TABLE `Orders` ADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) ## 命名 ALTER TABLE `Orders` ADD CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) # 撤销 ## MySQL ALTER TABLE `Orders` DROP FOREIGN KEY fk_PerOrders ## SQL Server / Oracle / MS Access ALTER TABLE `Orders` DROP CONSTRAINT fk_PerOrders CHECK检查约束 限制列中的值的范围，评估插入或修改后的值。满足条件插入，否不插 可以为同一列指定多个 CHECK 约束 # 建表 CREATE TABLE `courses`( `student_count` int, … CHECK (Condition1 AND Condition2) ) ## 命名 CONSTRAINT chk_courses CHECK (`student_count` > 0); # 已建 ALTER TABLE `courses` ADD CHECK ( `student_count` > 0); ## ADD CONSTRAINT XXX CHECK (Condition); # 撤销 ## MySQL ALTER TABLE `courses` DROP CHECK chk_courses ## SQL Server / Oracle / MS Access ALTER TABLE `courses` DROP CONSTRAINT chk_courses DEFAULT默认约束 `City` varchar(255) DEFAULT 'Sandnes' `OrderDate` date DEFAULT GETDATE() # 可以用函数 ALTER TABLE `Persons` ALTER `City` SET DEFAULT 'SANDNES' ADD CONSTRAINT ab_c DEFAULT 'SANDNES' for `City` ALTER `City` DROP DEFAULT ALTER COLUMN `City` DROP DEFAULT Join多表联结 联结 在一条 SELECT 语句中关联多个表，返回一组输出 两大主角 : 主键 (PRIMARY KEY) 和外键 (FOREIGN KEY) 使用完全限定列名（用一个点分隔表名和列名） # condition `table1`.`common_field` = `table2`.`common_field` JOIN 连接子句 INNER JOIN 内连接：如果表中有至少一个匹配，则返回行 OUTER JOIN 外连接 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN 全连接：只要其中一个表中存在匹配，则返回行 CROSS JOIN 交叉连接：又称笛卡尔积，两个表数据一一对应，返回结果的行数等于两个表行数的乘积 INNER JOIN内连接 又称为EQUIJOIN 等值连接 内连接就是取两个表的交集，返回的结果就是连接的两张表中都满足条件的部分 SELECT `table1`.`column1`, `table2`.`column2`... FROM `table1` (INNER) JOIN `table2` # INNER 可省略不写 ON `table1`.`common_field` = `table2`.`common_field`; # ON CONDITION # exp SELECT `c`.`id`, `c`.`name` AS `course_name`, `t`.`name` AS `teacher_email` FROM `courses` `c` (INNER) JOIN `teachers` `t` ON `c`.`teacher_id` = `t`.`id`; courses c 等同于 courses AS c ，给courses 表取别名为 c OUTER JOIN外连接 分为左外连接 右外连接 全外连接 外连接可以将某个表格中，在另外一张表格中无对应关系，但是也能将数据匹配出来 SELECT column_name 1,column_name 2 ... column_name n FROM table1 LEFT | RIGHT | FULL (OUTER) JOIN table2 ON CONDITION; LEFT JOIN : 以左表为参考表，返回左表中的所有记录，加上右表中匹配到的记录 RIGHT JOIN : 以右表为参考表 FULL JOIN : 只要左表和右表其中一个表中存在匹配，则返回行 tips : MySQL 数据库不支持全连接，想要实现全连接可以使用 UNION ALL 来将左连接和右连接结果组合在一起实现全连接 UNION : 联合，把两次或多次查询结果合并起来 要求：两次查询的列数必须一致，同时，每条 SELECT 语句中的列的顺序必须相同 UNION 会去掉重复的行。 如果不想去掉重复的行，可以使用 UNION ALL 如果子句中有 order by , limit，需用括号()包起来。推荐放到所有子句之后，即对最终合并的结果来排序或筛选 SELECT column_name 1,column_name 2 ... column_name n FROM table1 LEFT JOIN table2 ON CONDITION UNION SELECT column_name 1,column_name 2 ... column_name n FROM table1 RIGHT JOIN table2 ON CONDITION ; CROSS JOIN交叉连接 结果也称作笛卡尔积 返回左表中的所有行，左表中的每一行与右表中的所有行组合。即将两个表的数据一一对应，其查询结果的行数为左表中的行数乘以右表中的行数。 # 隐式连接 不需要使用 CROSS JOIN 关键字 SELECT `table1`.`column1`, `table2`.`column2`... FROM `table1`,`table2`; # 显式连接 SELECT `table1`.`column1`, `table2`.`column2`... FROM `table1` CROSS JOIN `table2`; 通过增加联结条件，使用 WHERE 子句帮助筛选过滤无效的数据 Advanced Select分组查询 GROUP BY 子句 对同类的数据进行分类 SELECT `column_name`, aggregate_function(`column_name`) FROM `table_name` WHERE `column_name` operator value GROUP BY `column_name`; HAVING 子句 使用 WHERE 条件子句时不能与聚合函数联合使用 HAVING 子句经常与 GROUP BY 联合使用，HAVING 子句就是对分组统计函数进行过滤的子句 HAVING 子句对于 GROUP BY 子句设置条件的方式其实与 WHERE 子句与 SELECT 的方式类似，语法相近，但 WHERE 子句搜索条件是在分组操作之前，而 HAVING 则是在之后 SELECT `column_name`, aggregate_function(`column_name`) FROM `table_name` WHERE `column_name` operator value GROUP BY `column_name` HAVING aggregate_function(`column_name`) operator value; ex: 查询教师表 teachers计算不同国籍教师的平均年龄和所有教师的平均年龄，比较两者的大小，最后返回大于所有教师平均年龄的不同国籍下的全部教师信息 # 子查询 SELECT * FROM teachers WHERE country IN (SELECT country FROM teachers GROUP BY country HAVING AVG(age) > (SELECT AVG(age) FROM teachers)) 子查询(Base) SELECT 语句中的子查询 SELECT `column_name(s)` FROM `table_name` WHERE `column_name` OPERATOR ( SELECT `column_name(s)` FROM `table_name` ); INSERT 语句中的子查询 INSERT INTO `table_name` SELECT `colnum_name(s)` FROM `table_name` [ WHERE VALUE OPERATOR ] UPDATE 语句中的子查询 UPDATE `table_name` SET `column_name` = `new_value` WHERE `column_name` OPERATOR (SELECT `column_name` FROM `table_name` [WHERE] ) DELETE 语句中的子查询 DELETE FROM `table_name` WHERE `column_name` OPERATOR (SELECT `column_name` FROM `table_name` [WHERE] ) 子查询(Adv.) 内联视图子查询 将查询的结果集作为一个查询表，继续进行查询操作 SELECT * FROM ( SELECT * xxxx ) `T` WHERE xxx = ( SELECT xxxx ); IN 操作符的多行子查询 / NOT IN ANY 操作符的多行子查询 在子查询中使用 ANY ，表示与子查询返回的任何值比较为真，则返回真 SELECT `column_name(s)` FROM `table_name` WHERE `column_name` OPERATOR ANY(SELECT column_name FROM table_name) ALL 操作符的多行子查询 在子查询中使用 ALL ，表示与子查询返回的所有值比较为真，则返回真 多列子查询 HAVING 子句中的子查询","categories":[{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"}],"tags":[{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"sql","slug":"sql","permalink":"https://maskros.top/tags/sql/"}]},{"title":"竞赛记录","slug":"life/竞赛记录","date":"2019-08-24T16:00:01.000Z","updated":"2022-05-15T14:56:05.895Z","comments":true,"path":"/post/life/竞赛记录.html","link":"","permalink":"https://maskros.top/post/life/%E7%AB%9E%E8%B5%9B%E8%AE%B0%E5%BD%95.html","excerpt":"算法废物的打铁记录","text":"竞赛记录 = 打铁记录 2020.10 CCPC威海打铁2020.10.17 蓝桥省二打铁2020.11 华为杯校赛三等2020.12 ICPC南京线上赛打铁2021.3 ICPC山东省赛打铁 这也能铁？纯废物 2021.5.16 ICPC银川现场赛打铁 阅读签到WA32，卡行末空格AC+6，Trie当时没掌握 2021.4.18 蓝桥省二打铁2021.8.21 百度之星复赛打铁2021.8 CCPC网络预选赛打铁2021.9 ICPC网络预选赛打铁2021.10 CCPC网络赛重赛打铁2021.11.28 ICPC上海线上赛打铁 卡树上DP签到，DP变形 2021.12 CCSP分赛铜首华东rk712021.4 蓝桥杯A组省一2021.4.17 ICPC昆明站线上赛打铜 亲手A掉铜牌题","categories":[{"name":"LIFE","slug":"LIFE","permalink":"https://maskros.top/categories/LIFE/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://maskros.top/tags/Life/"},{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"}]}],"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","permalink":"https://maskros.top/categories/ALGORITHMS/"},{"name":"NOTE","slug":"NOTE","permalink":"https://maskros.top/categories/NOTE/"},{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","permalink":"https://maskros.top/categories/ALGORITHM-TRAINING/"},{"name":"SOLUTIONS","slug":"SOLUTIONS","permalink":"https://maskros.top/categories/SOLUTIONS/"},{"name":"LIFE","slug":"LIFE","permalink":"https://maskros.top/categories/LIFE/"},{"name":"PROJECT","slug":"PROJECT","permalink":"https://maskros.top/categories/PROJECT/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://maskros.top/tags/ACM/"},{"name":"note","slug":"note","permalink":"https://maskros.top/tags/note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://maskros.top/tags/algorithm/"},{"name":"树状数组","slug":"树状数组","permalink":"https://maskros.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"string","slug":"string","permalink":"https://maskros.top/tags/string/"},{"name":"二分","slug":"二分","permalink":"https://maskros.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"hash","slug":"hash","permalink":"https://maskros.top/tags/hash/"},{"name":"java","slug":"java","permalink":"https://maskros.top/tags/java/"},{"name":"STL","slug":"STL","permalink":"https://maskros.top/tags/STL/"},{"name":"dp","slug":"dp","permalink":"https://maskros.top/tags/dp/"},{"name":"dfs","slug":"dfs","permalink":"https://maskros.top/tags/dfs/"},{"name":"solutions","slug":"solutions","permalink":"https://maskros.top/tags/solutions/"},{"name":"前缀和","slug":"前缀和","permalink":"https://maskros.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"nowcoder","slug":"nowcoder","permalink":"https://maskros.top/tags/nowcoder/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"https://maskros.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"},{"name":"codeforces","slug":"codeforces","permalink":"https://maskros.top/tags/codeforces/"},{"name":"思维","slug":"思维","permalink":"https://maskros.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"bfs","slug":"bfs","permalink":"https://maskros.top/tags/bfs/"},{"name":"讨论","slug":"讨论","permalink":"https://maskros.top/tags/%E8%AE%A8%E8%AE%BA/"},{"name":"差分","slug":"差分","permalink":"https://maskros.top/tags/%E5%B7%AE%E5%88%86/"},{"name":"构造","slug":"构造","permalink":"https://maskros.top/tags/%E6%9E%84%E9%80%A0/"},{"name":"LCA","slug":"LCA","permalink":"https://maskros.top/tags/LCA/"},{"name":"数学","slug":"数学","permalink":"https://maskros.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线段树","slug":"线段树","permalink":"https://maskros.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"欧拉降幂","slug":"欧拉降幂","permalink":"https://maskros.top/tags/%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/"},{"name":"位运算","slug":"位运算","permalink":"https://maskros.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"博弈","slug":"博弈","permalink":"https://maskros.top/tags/%E5%8D%9A%E5%BC%88/"},{"name":"模拟","slug":"模拟","permalink":"https://maskros.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"ST表","slug":"ST表","permalink":"https://maskros.top/tags/ST%E8%A1%A8/"},{"name":"Life","slug":"Life","permalink":"https://maskros.top/tags/Life/"},{"name":"图论","slug":"图论","permalink":"https://maskros.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"逆元","slug":"逆元","permalink":"https://maskros.top/tags/%E9%80%86%E5%85%83/"},{"name":"euler","slug":"euler","permalink":"https://maskros.top/tags/euler/"},{"name":"python","slug":"python","permalink":"https://maskros.top/tags/python/"},{"name":"WeRoBot","slug":"WeRoBot","permalink":"https://maskros.top/tags/WeRoBot/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","permalink":"https://maskros.top/tags/ComputerNetwork/"},{"name":"Trie","slug":"Trie","permalink":"https://maskros.top/tags/Trie/"},{"name":"kmp","slug":"kmp","permalink":"https://maskros.top/tags/kmp/"},{"name":"CCPC","slug":"CCPC","permalink":"https://maskros.top/tags/CCPC/"},{"name":"打表","slug":"打表","permalink":"https://maskros.top/tags/%E6%89%93%E8%A1%A8/"},{"name":"贪心","slug":"贪心","permalink":"https://maskros.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://maskros.top/tags/Dijkstra/"},{"name":"gcd","slug":"gcd","permalink":"https://maskros.top/tags/gcd/"},{"name":"Crawler","slug":"Crawler","permalink":"https://maskros.top/tags/Crawler/"},{"name":"requests","slug":"requests","permalink":"https://maskros.top/tags/requests/"},{"name":"springMVC","slug":"springMVC","permalink":"https://maskros.top/tags/springMVC/"},{"name":"sql","slug":"sql","permalink":"https://maskros.top/tags/sql/"}]}