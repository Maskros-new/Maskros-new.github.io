[{"id":"0308df9afb3678486e587f2739f6cf31","title":"竞赛记录","content":"竞赛记录\n\n\n\n\n\n\n\n\n= 打铁记录\n2020.10 CCPC威海打铁2020.10.17 蓝桥省二打铁2020.11 华为杯校赛三等2020.12 ICPC南京线上赛打铁2021.3 ICPC山东省赛打铁\n\n\n\n\n\n\n\n\n这也能铁？纯废物\n2021.5.16 ICPC银川现场赛打铁\n\n\n\n\n\n\n\n\n阅读签到WA32，卡行末空格AC+6，Trie当时没掌握\n2021.4.18 蓝桥省二打铁2021.8.21 百度之星复赛打铁2021.8 CCPC网络预选赛打铁2021.9 ICPC网络预选赛打铁2021.10 CCPC网络赛重赛打铁2021.11.28 ICPC上海线上赛打铁\n\n\n\n\n\n\n\n\n卡树上DP签到，DP变形\n2021.12 CCSP分赛铜首华东rk71","slug":"竞赛记录","date":"2021-12-29T16:22:28.000Z","categories_index":"LIFE","tags_index":"ACM,Life","author_index":"Maskros"},{"id":"73cfcb86305a1dc05f8e11e3779f31e9","title":"Notes on Kurose's Computer Networking：A TOP-DOWN APPROACH","content":"Notes on Kurose’s Computer NetworkingA TOP-DOWN APPROACH \n\n\n\n\n\n\n\n\n\nThanks to 我爹的博客，让我偷了不少😋\nChapter 1  Computer Networks and the Internet1.1 What is the Internet?\n\n\n\n\n\n\n\n\n因特网：世界范围的计算机网络\nNuts-and-Bolts Description\n\n计算设备称为 主机(host) / 端系统(end system) \n\n端系统通过 通信链路(communication link) 和 分组交换机(packet switch) 连接到一起；不同链路传输速率不同，发送端将数据分段后每段加上首部所形成的信息包称为 分组(packet)\n\n端系统通过 因特网服务提供商(ISP, Internet Service Provider) 接入因特网\n\n端系统、分组交换机和其他部件需要运行一系列协议(protocol) 。因特网的主要协议：TCP/IP (Transmission Control Protocol, 传输控制协议 / Internet Protocol, 网际协议)\n\n\nService\n\n分布式应用程序：因特网应用中涉及多个相互交换数据的端系统的应用程序\n与因特网相连的端系统提供了一个 套接字接口(Socket interface)，规定在一个端系统上的程序请求因特网基础设施向另一个端系统上的目的地程序交付数据的方式\n\nProtocol\n\n\n\n\n\n\n\n\n\nDef:  定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作\n\n不同的协议用于不同的通信任务\n\n1.2 The Network Edge\n主机分类：客户(Client) / 服务器(Server)\n\nAccess Networks\n\n\n\n\n\n\n\n\n\n接入网：将主机物理连接到其边缘路由器(Edge router)的网络\n家庭接入：数字用户线(DSL)、电缆因特网接入、光纤到户(FTTH)、拨号、卫星\n企业/家庭接入：以太网(Ethernet)、WIFI\n广域无线接入：3G、LTE\nPhysical Media\n双绞铜线、同轴电缆、光纤、陆地/卫星无线电信道\n1.3 The Network Core\n\n\n\n\n\n\n\n\n通过网络链路和交换机移动数据有两种基本方法：电路交换 和 分组交换\n1.3.1 Packet Switching\n\n\n\n\n\n\n\n\n分组交换 : 端系统彼此交换报文(message)，源端将报文划分成较小的数据块，称为分组；在源和目的地之间每个分组经过通信链路和 分组交换机 (packet switch)传送，两类交换机分别为 路由器(router) 和 链路层交换机(link-layer switch)\nStore-and-Forward Transmission\n存储转发传输：交换机在开始向输出链路传输分组之前需要接收到整个分组\nexp: 通过 $N$ 条速率均为 $R$ 的链路组成的路径 (即在源和目的地之间有 $N-1$ 台路由器) 所用 端到端时延为 $d=N \\dfrac{L}{R}$\nQueuing Delays and Packet Loss\n排队时延和分组丢失：分组交换机具有一个输出缓存(output buffer) 即输出队列，除存储转发时延外分组还要承受输出缓存的排队时延(queuing delay)，如果一个分组到达后发现该缓存空间已满，则发生丢包(packet loss)，到达的分组或已经排队的分组之一将被丢弃\nForwarding Tables and Routing Protocols\n转发表和路由选择协议：每台路由器有一个转发表(Forwarding Table)，用于将目的地址/目的地址的一部分映射成输出链路。路由选择协议(routing protocol)用于自动地设置转发表\n1.3.2 Circuit Switching\n\n\n\n\n\n\n\n\n电路交换：建立名副其实的连接，路径上的交换机维护连接状态，电路交换网络上的两主机通信时，网络在两主机间创建一条专用的端到端连接(end-to-end connection)\nMultiplexing\n链路中的电路通过频分复用(FDM, Frequency-Division Multiplexing)或时分复用(TDM, Time-Division Multiplexing)来实现\nFDM：链路的频谱由所有连接共享，在连接期间链路为每条连接专用一个频段，频段的宽度称为带宽(band-width)\nTDM：时间被划分为固定期间的帧，每个帧被划分为固定数量的时隙(slot)，在网络跨越链路创建连接时，在每个帧中为该联结制定一个时隙，由该连接单独使用\n\n\n\n\n\n\n\n\n\n分组交换的性能优于电路交换的性能\n1.4 Delay, Loss, and Throughput in Packet-Switched Networks\n\n\n\n\n\n\n\n\n计算机网络的性能测度：时延、丢包、吞吐量\nDelay\nTotal nodal delay = 节点处理时延(nodal processing delay) + 排队时延(queuing delay) + 传输时延(transmission delay) + 传播时延(propagation delay)\n传输时延：将所有分组的比特推向链路所需要的时间 $\\frac{L}{R}$\n传播时延：将比特从链路的起点到目的地传播所需要的时间 $\\frac{d}{s}$，传播速率 $s$ 取决于物理媒体(光纤/双铜绞线等)\nThroughput\n瞬时吞吐量(instantaneous throughput)：接收到文件的瞬时速率 (bps)\n平均吞吐量(average throughput)：文件大小/收到文件所有比特的时间 计算所得的平均速率 (bps)\n1.5 Protocol Layers and Their Service Models\n分层(Layer)的体系结构\n每层通过自己的内部动作/依靠下一层提供的服务来提供服务\n\nProtocol Stack\n\n\n\n\n\n\n\n\n\n协议栈：各层的所有协议\n因特网协议栈：应用层、运输层、网络层、链路层、物理层\nISO OSI参考模型：应用层、表示层、会话层、运输层、网络层、链路层、物理层\n应用层 Application Layer\n\n网络应用程序、应用层协议\nHTTP/SMTP/FTP/DNS\n协议数据单元(实体交换的数据单位)/信息分组：报文(message)\n\n运输层 Transport Layer\n\nTCP/UDP\n协议数据单元：报文段(segment)\n进程间传输\n\n网络层 Network Layer\n\nIP/路由选择协议\n协议数据单元：数据报(datagram)\n主机间传输\n\n链路层 Link Layer\n\n以太网/802.11(WiFi)/PPP\n协议数据单元：帧(frame)\n\n物理层 Physical Layer\n\n控制比特的发送\n\nEncapsulation\n\n\n\n\n\n\n\n\n\n封装过程：应用层报文 -&gt; 运输层报文段 -&gt; 网络层数据报 -&gt; 链路层帧\n每一层的分组：首部字段 + 有效载荷字段(payload field)\n┌───────────┐┌─────────┐        ┌───────┐                  ┌────┐                    ┌────────┐\n│Application││Transport│        │Network│                  │Link│                    │Physical│\n└─────┬─────┘└────┬────┘        └───┬───┘                  └─┬──┘                    └───┬────┘\n      │           │                 │                        │                           │     \n      │Message &#x3D; M│                 │                        │                           │     \n      │──────────&gt;│                 │                        │                           │     \n      │           │                 │                        │                           │     \n      │           │Segment &#x3D; H_t + M│                        │                           │     \n      │           │────────────────&gt;│                        │                           │     \n      │           │                 │                        │                           │     \n      │           │                 │Datagram &#x3D; H_n + H_t + M│                           │     \n      │           │                 │───────────────────────&gt;│                           │     \n      │           │                 │                        │                           │     \n      │           │                 │                        │Frame &#x3D; H_l + H_n + H_t + M│     \n      │           │                 │                        │──────────────────────────&gt;│     \n┌─────┴─────┐┌────┴────┐        ┌───┴───┐                  ┌─┴──┐                    ┌───┴────┐\n│Application││Transport│        │Network│                  │Link│                    │Physical│\n└───────────┘└─────────┘        └───────┘                  └────┘                    └────────┘\n\n\nChapter 2 Application Layer\n\n\n\n\n\n\n\n\n应用层\n2.1 Principles of Network Applications主流体系结构：**客户-服务器体系结构 **(C/S, client-server)，对等体系结构 (P2P, peer-to-peer)\nC/S：\n\n服务器S：\n\n总是打开的主机 (always-on host)\n固定的IP地址 (permanent IP address)\n服务于客户的请求\n\n\n客户C:\n\n请求主机\n\n客户间不进行通信  exp: 两个浏览器并不直接通信\n\n动态IP地址 (dynamic IP address)\n\n\n\n\nP2P：\n\n没有永远在线的服务器\n\n任意主机对直接通信，对等方\n\n自扩展性 (self-scalability)  新的对等方增加服务能力 \nexp: P2P文件共享\n\n流量密集型\n\n动态IP地址\n\n\nProcesses Communicating\n\n\n\n\n\n\n\n\n\n进程(process) : 运行在主机上的程序\n同一主机内的进程：进程间通信\n不同主机内的进程：交换报文(Message)\n客户进程：发起通信的进程\n服务器进程：在会话开始时等待联系的进程\n进程与计算机网络间的接口：套接字(socket)，软件接口，进程向/从其套接字发送/接收报文\nReliable Date Transfer\n\n\n\n\n\n\n\n\n\nDef: 确保应用程序的一端发送的数据正确、完全地交付给了该应用程序的另一端，称为可靠数据传输\n2.2 The Web and HTTP\n\n\n\n\n\n\n\n\nWeb的应用层协议是 超文本传输协议 (HTTP, HyperText Transfer Protocol) \n\nC/S 模式\n\nHTTP客户端：Web浏览器 (Web browser)\n\nHTTP服务器端：Web服务器 (Web server)\n\n定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式\n\n支撑运输协议：TCP\n\n客户发起TCP连接，服务器接受TCP连接\n\n建立连接后浏览器和服务器进程就可以通过套接字接口访问TCP\n\n无状态协议(stateless protocol)：HTTP服务器不保存关于客户的信息\n\n\nHTTP Message Format\n\nRequest Message 请求报文\n第一行为请求行(request line)：方法字段、URL字段、HTTP版本字段\n后继四行为首部行(header line)\n\n\nResponse Message 响应报文\n一个状态初始行(status linge)\n六个首部行(header line)\n实体体(entity body)\n\n\nStatus Code 状态码\n200 OK：请求成功，信息在返回的相应报文中\n301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL\n400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解\n404 Not Found：被请求的文档不在服务器上\n505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本\n\n\n\nUser-Server Interaction: Cookies\ncookie的4个组件：\n\nHTTP响应报文中的一个cookie首部行\nHTTP请求报文中的一个cookie首部行\n保留在客户端的cookie文件，由用户的浏览器进行管理\n保留在Web服务器的后端数据库\n\nWeb Caching\n\n\n\n\n\n\n\n\n\nWeb缓存器(Web cache) 又称 代理服务器(proxy server)\n代表初始Web服务器来满足HTTP请求的网络实体\n\n浏览器建立到Web缓存器的TCP连接，客户端将所有HTTP请求首先发送到Web缓存器中的对象，Web缓存器检查本地是否存储该对象副本\n\n有：Web缓存器向客户浏览器用HTTP响应报文返回该对象\n无：打开一个与该对象的初始服务器的TCP连接，发送该对象的HTTP请求，收到请求后初始服务器向该Web缓存器发送HTTP响应\n\n\nWeb缓存器既是客户也是服务器\n\n服务器：接收浏览器的请求发回响应\n客户：向初始服务器发出请求并接收响应\n\n\n减少了客户端请求的响应时间\n\n减少了一个机构的接入链路到因特网的通信量\n\n\nThe Conditional GET\n\n\n\n\n\n\n\n\n\n条件GET：为了保证Web缓存器的对象是最新的\n\n请求报文中使用GET方法并且包含一个”If-Modified-Since”首部行\n客户端：在HTTP请求中指定缓存副本的日期\n服务器：如果缓存的副本是最新的，则响应不包含任何对象\n\n┌──────┐                  ┌──────┐\n│client│                  │server│\n└──┬───┘                  └──┬───┘\n   │                         │    \n   │If-modified-since &lt;date&gt; │    \n   │────────────────────────&gt;│    \n   │                         │    \n   │HTTP&#x2F;1.0 304 Not Modified│    \n   │&lt;────────────────────────│    \n   │                         │    \n   │If-modified-since &lt;date&gt; │    \n   │────────────────────────&gt;│    \n   │                         │    \n   │ HTTP&#x2F;1.0 200 OK &lt;data&gt;  │    \n   │&lt;────────────────────────│    \n┌──┴───┐                  ┌──┴───┐\n│client│                  │server│\n└──────┘                  └──────┘\n\n2.3 Electronic Mail in the InternetComponents of Email\n\n用户代理(User Agent)：邮件客户端\n\n邮件服务器(Mail Server)：\n\n邮箱(mailbox)：包含用户的传入信息\n报文队列(message queue)：包含外发(待发)信息\n\n\n简单邮件传输协议(SMTP, Simple Mail Transfer Protocol)：\n\n向/在邮件服务器上传递/存储消息\nC/S模式：\n客户端：用户代理或邮件服务器\n服务器：邮件服务器\n\n\n与HTTP的比较：\nHTTP：拉协议(pull protocol)，用户使用HTTP协议从服务器拉取信息\nSMTP：推协议(push protocol)，发送邮件服务器把文件推向接受邮件服务器\n\n\n\n\n因特网邮件访问协议(IMAP, Internet Mail Access Protocol)\n\n检索/删除/文件夹中存储的邮件服务器上的邮件\n\n\n\nexp: Alice sends an email to Bob\n┌──────────────────┐┌───────────────────┐┌─────────────────┐                 ┌────────────────┐\n│Alice&#39;s user agent││Alice&#39;s mail server││Bob&#39;s mail server│                 │Bob&#39;s user agent│\n└────────┬─────────┘└─────────┬─────────┘└────────┬────────┘                 └───────┬────────┘\n         │                    │                   │                                  │         \n         │        SMTP        │                   │                                  │         \n         │───────────────────&gt;│                   │                                  │         \n         │                    │                   │                                  │         \n         │                    │       SMTP        │                                  │         \n         │                    │──────────────────&gt;│                                  │         \n         │                    │                   │                                  │         \n         │                    │                   │mail access protocol (IMAP or POP)│         \n         │                    │                   │─────────────────────────────────&gt;│         \n┌────────┴─────────┐┌─────────┴─────────┐┌────────┴────────┐                 ┌───────┴────────┐\n│Alice&#39;s user agent││Alice&#39;s mail server││Bob&#39;s mail server│                 │Bob&#39;s user agent│\n└──────────────────┘└───────────────────┘└─────────────────┘                 └────────────────┘\n\n2.4 DNS-The Internet’s Directory Service\n\n\n\n\n\n\n\n\n域名系统(DNS, Domain Name System)：一个由分层的DNS服务器(DNS server)实现的分布式数据库；一个使得主机能够查询分布式数据库的应用层协议\nServices\n\n主机名到IP地址的转换\n\n主机别名(host aliasing)，规范主机名(CNAME, canonical hostname)\n\n邮件服务器别名(mail server aliasing)\n\n负载分配(load distribution)：许多IP地址对应一个名称\n\n\nHow DNS Works\n\n分布式、层次数据库\n根DNS服务器，顶级域DNS服务器，权威DNS服务器\n本地DNS服务器\n递归查询(recursive query)，迭代查询(iterative query)\n\n\nDNS缓存(DNS caching)\n\n\n\n\n\n\n\n\n\n\nexp: a distributed, hierarchical database\n\n\n\n\n\n\n\n\n\n\nexp: iterative query (more commonly used) vs recursive query\n\n2.6 Video Streaming and Content Distribution Networks\n\n\n\n\n\n\n\n\n经HTTP的动态适应性流(DASH, Dynamic Adaptive Streaming over HTTP)\n内容分发网(CDN, Content Distribution Network)\n\n服务器：\n将视频文件分为多个块，每个块以多种不同速率进行编码\n不同速率的编码(encoding)存储在不同的文件中\n文件被复制到多个CDN节点中\n生成告示文件(maifest file)，为不同块提供URL\n\n\n客户端：\n定义估算服务器到客户的带宽\n查阅告示文件，每次请求一个分块\n决定何时/何种编码率/请求哪台服务器\n\n\n\nStreaming stored video: playout buffering\n\n\n\n\n\n\n\n\n\nSummary: video streaming = encoding + DASH + playout buffering\n\nChapter 3 Transport Layer\n\n\n\n\n\n\n\n\n传输层\n3.1 Introduction and Transport-Layer Services\n\n\n\n\n\n\n\n\n运输层协议为不同主机上的应用进程之间提供了逻辑通信(logic communication)\n\n发送方\n通过套接字传递应用层的报文\n确定报文段(segment)报头的值\n创建报文段\n将报文段传递给网络层\n\n\n接收方\n从网络层接收报文段\n检查报头值\n提取应用层的报文\n通过套接字将报文传递给应用层\n\n\n\nTransport vs Network layer services\nexp: 家庭间的邮件传递\n主机：家庭\n进程：孩子\n应用层报文：信件\n运输层协议：两个家庭中由 Ann 和 Bill 为孩子们收发信件\n网络层协议：邮政服务\n不提供的服务：延迟保证，带宽保证\n3.2 Multiplexing and Demultiplexing\n\n\n\n\n\n\n\n\n复用(multiplexing)：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息生成报文段，将报文段传递给网络层\n分用(demultiplexing)：将运输层报文段的数据交付到正确的套接字\n套接字有唯一标识符，而每个报文段通过源端口号字段(source port number field)，目的端口号字段(destination port number field)指示报文段所要交付到的套接字\n\n\n\n\n\n\n\n\n\n下图展示了复用和分用的过程\n\n3.3 UDP: Connectionless Transport\n\n\n\n\n\n\n\n\n用户数据报协议\n\n无连接的\n\nUDP发送方和接收方之间没有握手协议\n每个UDP数据报独立处理\n\n\n尽力而为交付服务(best-effort delivery service)\n\n报文段可能丢失\n报文段可能不符合顺序\n\n\n\nWhy there is a UDP\n\n无需建立连接\n不需要握手(无RTT延迟)\n无连接状态\n\n\n报头尺寸小\n没有拥塞控制\n速度快\n有面对拥堵时的机制\n\n\n用例：DNS, SNMP, HTTP/3(在应用层增加所需可靠性以及拥堵控制)\n\nUDP Segment Structure\n ------------ 32bit ------------\n┌───────────────┬───────────────┐\n| source port # |  dest port #  |\n├───────────────┼───────────────┤\n|    length     |   checksum    |\n├───────────────┴───────────────┤\n|                               |\n|  application data (payload)   |\n|                               |\n└───────────────────────────────┘\n\n检验和(checksum): 提供差错检测功能，发送方的UDP对报文段中所有16bit字的和进行反码运算得到\n3.4 Principles of Reliable Data Transfer\n\n\n\n\n\n\n\n\n可靠数据传输协议(rdt协议, reliable data transfer protocol)：为TCP的可靠性保证做准备\nBuilding a Reliable Data Transfer Protocol\n假设：\n\n单向的数据传输(发送方到接收方)\n在不可靠的信道中进行双向控制信息(即ACK)流动\n\n逐步改进rdt协议(提供有限状态机(Finite-State Machine, FSM) )：\n\nrdt1.0：信道完全可靠\n\nrdt2.0：信道具有比特差错，使用ACK(肯定确认, positive acknowledgment) /NAK(否定确认, negative acknowledgment)，基于这样重传机制的可靠数据传输协议称为自动重传请求(ARQ, Automatic Repeat reQuest)协议\n\nrdt2.1：如果ACK/NAK被破坏，使用序号(sequence number)来处理重复的信息\n\nrdt2.2：只使用ACK\n\nrdt3.0：信道具有比特差错和丢包，使用倒计数定时器(countdown timer)，rdt3.0又称比特交替协议\n\n\nStop-and-Wait (starting from rdt2.0)\n\n\n\n\n\n\n\n\n\n停等协议：发送方发送一个数据包，然后等待接收方的回应\n发送方必须等待发送的数据包到达，或者直到超时，在某些情况下会导致发送方长时间处于空闲状态等待确认\nPipelining\n\n\n\n\n\n\n\n\n\nsuccessor of Stop-and-Wait\n流水线：发送方允许多个发送中的、尚未被ACK的数据包\n\nGo-Back-N(GBN)\n发送方：\n最多可以有序号范围为N个的、连续传输但未ACK的数据包的窗口，N被称为窗口长度(window size)\n累计确认(commulative ACK(n))\n表明接收方以正确收到序号为n的以前且包括n在内的所有数据包\n向前移动窗口使起点位于 n+1\n\n\n对发送时间最早但未被确认的数据包进行计时\n超时事件(timeout(n))：重传n号和所有序号更高的数据包\n\n\n接收方：\n仅发送最高序号的ACK\n在收到失序的数据包时\n丢弃或缓存\n重新发送按照顺序的最高序号的ACK\n\n\n\n\n\n\nSelective Repeat(SR)\n发送方：\n最多可以有序号范围为N个的、连续传输但未ACK的数据包的窗口\nACK(n)：标记n号数据包已收到，如果n是最小的未ACK的数据包，则窗口向前移动到下一个未ACK的数据包开始\ntimeout(n)：对未ACK的数据包单独重传\n\n\n接收方\n单独ACK(n)\n收到失序的数据包时：缓存\n收到有序的数据包时：交付(也交付缓冲的、符合顺序的数据包)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在Go-Back-N中使用的累计确认在TCP中也有使用\n发送窗口和接收窗口的大小必须相等\n3.5 TCP: Connection-Oriented Transport\n\n\n\n\n\n\n\n\n传输控制协议\n\n点对点(point-to-point)：一个发送方，一个接收方\n可靠的，有序的字节流(byte-stream)\n面向连接的(connection-oriented)：在数据交换前 握手(handshaking) 初始化发送方和服务器状态\n累计确认(cumulative ACKs)\n全双工服务(full-duplex service)：在同一连接中同时进行双向数据流\n流水线：流量和拥堵控制\n\nTCP Segment Structure\n\n\n\n\n\n\n\n\n\n\nUAPRSF：URG, ACK, PSH, RST, SYN, FIN\n\n序列号(Sequence Number)：分段数据中第一个字节的字节流编号\n确认号(Acknowledgement Number)：确认对方下一个字节的序列号，累计ACK\n\nRTT Estimation(via EWMA) and Timeout\n\n\n\n\n\n\n\n\n\nRTT: 连接的往返时间\nSampleRTT: 报文段的样本RTT\nEstimateRTT: 估计往返时间\nTimeoutInterval: 超时重传间隔\nDevRTT: 偏差RTT\nEWMA: 指数加权移动平均 Exponential Weighted Moving Average\n\nEstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT\n\n取α = 0.125\n\nTimeoutInterval = EstimatedRTT + 4·DevRTT\n\nDevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|\n\n取β = 0.25\n\n\nFast Retransmit\nTCP快速重传：如果检测到3个冗余的ACK，则TCP执行快速重传，在该报文段的定时器过期之前重传丢失的报文段\nFlow Control\n流量控制：\n\n接收方控制发送方，这样发送方就不会溢出接收方的缓冲区\n\n接收窗口rwnd(receive window)：在TCP头的rwnd字段中，指示该接收方还有多少可用的缓存空间，或表示发送方将数据量限制在rwnd内\n\n\nTCP Connection Management\n\n三次握手(three-way handshake)建立连接\n\n\n\n四次挥手(four-way handshake)结束连接\n\n\n\n\n\n\n\n\n\n\n\nTCP状态(TCO state)的变迁，有限状态机(FSM)\n3.6 Principles of Congestion Control\n\n\n\n\n\n\n\n\n拥塞控制\n拥塞(Congestion)：\n\n太多的发送者以太快的速度发送太多的数据\n表现：高延迟、丢包\n与流量控制不同(一个发送方对于一个接收方来说速度太快)\n\nThe Causes and the Costs of Congestion\n\n吞吐量永远不会超过容量\n延迟随着容量的增加而增加\n丢失/转发/不必要的中端会降低有效吞吐量(throughput)\n上游传输容量/缓冲区会因下游丢包而被浪费\n\nCongestion Control\n\n端到端拥塞控制(end-end approach)：\n没有来自网络的明确反馈，从观察到的延迟、损失推断拥塞情况\n\n网络辅助的拥塞控制：\nIP路由器在拥堵时向发送/接受主机提供直接反馈，可以显示拥堵程度或者明确设置发送速率\n\n\n3.7 TCP Congestion ControlTCP的拥塞控制算法(CCA, congestion control algorithm)：\n\n拥塞窗口cwnd(Congestion Window)\n\n慢启动(slow-start)：\n\ncwnd的值以1个MSS开始，每当传输的报文段首次被确认就增加一个MSS，这一过程中每过一个RTT，发送速率就翻倍，指数增长\n慢启动阈值ssthresh：如果存在一个由超时指示的丢包(即拥塞)，TCP发送方将 cwnd 设置为1并重新开始慢启动，将ssthresh设为 cwnd/2, 即当检测到拥塞时将其置位拥塞窗口值的一半。当到达或者超过ssthresh的值时，进入拥塞避免\n\n\n拥塞避免(Congestion Avoidance)\n\ncwnd的值每个RTT只增加一个MSS，线性增长\n由3个冗余ACK引起的丢包时, ssthresh = cwnd/2, cwnd = 1MSS, 进入快速恢复\n\n\n快速恢复(Fast Recovery)\n\n对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值就加一个MSS，当对丢失报文段的一个ACK到达时，TCP降低cwnd后进入拥塞避免状态\n\n\n加性增、乘性减(AIMD, Additive-Increase, Multiplicative-Decrease) 拥塞控制方式\n假定丢包由3个冗余ACK而不是超时指示：每个RTT内cwnd线性(加性)增加1MSS，然后出现3个冗余ACK事件时cwnd减半(乘性减)\n\n\n\nChapter 4 The Network Layer: Data Plane网络层：数据平面\n4.1 Overview of Network Layer\n发送方：\n将报文段封装成数据报(datagram)，传递给链路层\n\n\n接收方：\n从数据报中提取报文段，传递给传输层\n\n\n两种重要功能：\n转发(Forwarding)：将数据报从输入链路转移到适当的输出链路上，类比旅游中在每个路口做决定\n路由(Routing)：确定数据报从原点到目的地的路线\n\n\n\nTwo Network Layer Planes\n\nData Plane 数据平面\n\n本地，每台路由器的功能\n路由器内的数据报转发\n硬件\n\n\nControl Plane 控制平面\n\n全网\n沿着从原点到目的地的路径，在路由器之间进行数据报路由\n传统路由算法：在路由器中实现\n软件定义网络(SDN, Software-Defined Networking)：在远程服务器中实现\n\n\n软件\n\n\n\nNetwork layer’s “best effort” service model\n\n\n\n\n\n\n\n\n\n尽力而为服务：不保证成功交付，及时/按顺序交付，最小带宽\n4.2 What’s inside a Router?\n输入端口(input port):\n\n通过header的值进行转发表查询\n转发方式：\n基于目的地转发：只根据目的地的IP地址进行转发\n通用转发：基于任何一组header值的转发，不仅仅是网络层的功能：转发(路由器，交换机)，丢弃(防火墙)，修改(NAT)，封装并转发到控制器(SDN)\n\n\n最长前缀匹配(longest prefix matching rule)：通常使用三态内容可寻址存储器(TCAM, Tenary Content Address Memory)来查找\n\n交换结构(switching fabric)：\n\n将数据报从输入链路传输到适当的输出链路\n交换率：数据报传输的速率，通常以多个输入/输出线路速率来衡量\n三种主要类型：内存、总线、互联网\n\n排队(queueing)：\n\n输入排队：\n输入端口的综合线路速率大于交换速率\n需要缓冲：排队延迟和输入缓冲器溢出造成的损失\n阻塞(HOL, Head-Of-the-Line)：排在前面的数据报阻断后面的数据报\n\n\n输出排队：\n交换率大于链路传输速率\n需要缓冲：由于输出缓冲区溢出，造成排队延迟和损失\n\n\n\n缓冲区管理：\n\n丢弃策略：尾部丢弃，基于优先级的丢弃\n标记：ECN，RED\n\nPacket Scheduling\n\n先进先出(FIFO, First-In-First-Out)\n优先权排队(priority queuing)：\n到达时分类\n从最高优先级到最低优先级\n优先级内的FIFO\n\n\n循环排队(RR, Round Robin queuing discipline)\n到达时分类\n通过类循环\n依次从每个类中选出一个\n\n\n加权公平排队(WFQ, Weight Fair Queuing)\n广义的Round  Robin\n每个类别有权重\n在每个循环中加权服务量\n每个流量类别的最低带宽保证\n\n\n\n4.3 The Internet Protocol(IP): IPv4, Addressing, IPv6, and More网际协议IP\nIPv4 vs IPv6\n\n\n\n\n\n\n\n\n\nIPv4 32位地址编码   IPv6 128位地址编码\n\n通过隧道(tunnel)时，IPv6数据报作为IPv4数据报的有效载荷实现共存\n\nIP Addressing：\n\nIP地址：与每个主机/路由器接口(interface)相关的32位标识符\n接口：\n主机/路由器和物理链路之间的连接\n接口的数量：路由器通常多个，主机通常一个或两个\n有线以太网\n无限802.11\n\n\n\n\n点分十进制记法(dotted-decimal notation)\n无类别域间路由选择(CIDR, Classless Interdomain Routing)\n任意长度的子网地址x，即子网掩码(subnet mask)\na.b.c.d/x\n\n\n\nHow to get an IP ?\n\n主机：\n硬编码\n动态主机配置协议(DHCP, Dynamic Host Configuration)：\n主机在加入网络时动态地从DHCP服务器获取一个IP地址\nDHCP服务器位于路由器中\n地址的重复使用\n即插即用协议(plug-and-play protocol)\n返回的不仅仅是子网中分配的IP地址\n第一跳路由器的地址\nDNS服务器的名称和IP地址\n子网掩码\n\n\n\n\n\n\n子网(subnet) (即网络如何获得其IP地址的子网部分)\n从其ISP获得\n\n\nISP (即一个ISP如何获得其地址块)\n从ICANN\n\n\n\nNetwork Address Translation(NAT)\n网络地址转换NAT\n\n就外部世界而言，本地网络中的所有设备只共享一个IPv4地址\n本地IP地址在3个专用IP地址(private network)范围内\n\n\n优势\n所有设备都有一个来自ISP的IP地址\n改变本地地址不需要通知外部世界\n改变ISP而不改变本地地址\n本地设备不会被外界直接看到，保证安全\n\n\n实现 (透明)\n对发出的数据报：\n将 (源IP地址，端口) 替换为 (NAT IP地址，新端口)\n远程主机将以 (NAT IP地址，新端口) 作为目的地进行响应\n\n\nNAT转换表(NAT translation table)\n每个 (源IP地址，端口)  &lt;-&gt;  (NAT IP地址，端口)\n\n\n对传入的数据报：\n用NAT转换表进行反向转换\n\n\n\n\n\n4.4 Generalized Forwarding and SDNGeneralized Forwarding\n通用转发：一张流表(flow table)将基于目的地的转发表一般化\n\nOpenFlow：一个匹配加动作转发抽象的标准\n\n流表：匹配加动作转发表\n\n匹配：入端口、IP源地址、IP目的地址 (允许通配符*****)\n动作：转发、丢弃、修改字段\n\n\n\n\nChapter 5 The Network Layer: Control Plane网络层：控制平面\n5.1 Introduction构建网络控制平面的两种方法：\n\n每路由器控制(per-router control)：(传统的，分布式)\n每个路由器中都有单独的路由算法组件\n路由器之间直接互动\n\n\n逻辑集中式控制(logically centralized/ SDN control)\n路由器之间不相互影响\n\n\n\n\n\n\n\n\n\n\n\n\n路由算法在两种方法中都是一样的，区别只是如何实现\n5.2 Routing Algorithms路由选择算法\n\nDijkstra’s link state algorithm\n\n\n\n\n\n\n\n\n\n链路状态(Link State, LS)\n\n属于集中式路由选择算法(centralized routing algorithm)\n必须知道网络中每条链路的开销\n\n\nBellman Ford’s (BS) distance vector algorithm\n\n\n\n\n\n\n\n\n\n距离向量(Distance Vector, DV)\n\n属于分散式路由选择算法(decentralized routing algorithm)\n每个节点维护到网络中所有其他结点的开销(距离)估计的向量\n\n\n\nDijkstra’s Link State Algorithm\n\n集中式\n\n所有节点都知道网络拓扑结构(图)\n所有节点都有相同的信息\n通过链路状态广播完成\n\n\n计算从一个节点到所有其他节点的最小成本路径，为该节点生成转发表\n\n迭代(iterative)\n\n经过k次迭代，知道到k个目的地的最低成本路径\n\n\n算法复杂性: $O(n^2)$\n\n每次迭代需要检查所有不在N中的节点\n有 $O((n+m)logn )$ 的可能，有最小优先级的队列\n\n\n信息复杂性: $O(n^2)$\n\n链路状态广播(link state broadcast)：每个路由器必须向所有其他路由器广播链接状态\n有效的广播算法：$O(n)$ 个链路交叉点来传播来自一个源的广播消息\n每个路由器的消息穿过 $O(n)$​​ 个链接\n\n\n当链路成本取决于流量时可能出现振荡\n\n\nBellman Ford’s Distance Vector Algorithm\n\n分散式(decentralized)\n\n路由器最初只知道连接到邻居的成本\n路由选择表(routing table)\n\n\n迭代的(iterative)\n每个节点的行动：\n\n等待触发本地迭代的变化\n本地链路成本变化\n来自邻居的距离向量更新信息\n\n\n重新计算本地距离向量\n如果变化，发送新的本地距离向量给邻居\n\n\n异步的(asynchronous)\n\n每个节点的迭代速度可以不同\n自我终止的(self stopping) \n每个节点只在本地距离向量发生变化时通知其邻居\n没有收到通知，不采取任何行动\n\n\n\n\n好消息传得快(链接成本降低)，坏消息传的慢(链接成本增加)：无穷计数(count-to-infinity)问题\n\n算法复杂性：$O(n+m)$\n\n信息复杂性：(网络直径为 $d$ 的节点) $O(d)$ : 状态信息的扩散\n\n收敛的速度不同导致收敛的时间不同，可能有路由选择环路(routing loop) 和 无穷计数问题 (count-to-infinity)\n\n\n5.3 Intra-AS Routing in the Internet: OSPF\n\n\n\n\n\n\n\n\nISP, AS, 域在这里具有相同含义\nAutonomous System(AS)\n\n\n\n\n\n\n\n\n\n自治系统：将路由器组织进AS\n域内路由协议：\n\nAS中的所有路由器必须运行相同的域内协议\n不同AS种的路由器可以运行不同的域内协议\n网关路由器(gateway router)：\n\n域间路由协议：\n\n在AS之间进行路由选择\n网关路由器既执行域间路由，也执行域内路由\n\n转发表(Forwarding table)是由域内和域间填充的协议(目的地在AS内: Intra-; 目的地在AS外: Intra- 和 Inter-)\nOSPF(Open Shortest Path First)\n\n\n\n\n\n\n\n\n\n开放最短路优先\n\n最常用的域内路由协议\n经典的Dijkstra链路状态算法\n每个路由器向AS内所有其他路由器广播选择信息(直接通过IP而非TCP/UDP)\n可能有多个指标：带宽、延迟\n\n\n所有OSPF消息都经过认证以防止恶意入侵\n\n\n5.4 Routing Among the ISPs: BGP\n\n\n\n\n\n\n\n\n边界网关协议 (Broder Gateway Protocol, BGP)\n既涉及决策，也涉及性能\n\n自治系统间的路由选择协议 (inter- AS routing protocol)\nBGP为每个AS提供了一种方法来：\n从邻近的AS获得可达性信息(eBGP)\n将可达性信息传播给AS内的所有路由器(iBGP)\n\n\nBGP会话\n两个BGP路由器通过TCP连接交换BGP信息\n路径通告：前缀(prefix, CIDR化目标网络) + 属性(BGP attribute)\n两个重要的属性：\nAS-PATH：通告已经通过的AS列表\nNEXT-HOP(下一跳)：通往下一跳AS的内部AS路由器\n\n\n\n\n基于策略的路由选择：\n是否接受一个路径通告，exp: 永远不通过X的路由\n是否发布路径通告，exp: 流量永远不会路由到X\n\n\n\n\nHot Potato Routing\n\n\n\n\n\n\n\n\n\n热土豆路由选择：选择域内成本最低的本地网关，不用担心域间成本，即尽可能快地将数据送出\nRoute-Selection Algorithm\n\n\n\n\n\n\n\n\n\n路由器选择算法：当有一条以上的路由可用时\n\n策略决定\n最短的AS-PATH\n最近的NEXT-HOP路由器(hot potato)\n额外标准\n\n5.5 The SDN Control Plane\n\n\n\n\n\n\n\n\n软件定义网络(Software Defined Networking, SDN)\nWhy a logically centralized control plane?\n\n更容易管理\n\n基于表的转发 (OpenFlow API) 允许对路由器进行编程\n\n集中式编程更容易：集中计算表并分发\n\n\n开放的实现\n\n促进创新\n\n\n\nChapter 6 The Link Layer and LANs链路层和局域网\n6.1 Introduction to the Link Layer\n发送方：\n将网络层的数据报封装成帧(Frame)\n\n\n接收方\n从帧中提取数据报，传递给网络层\n\n\n链路层信道：\n广播信道：有线局域网、卫星网、HFC\n点对点通信链路：点对点协议(PPP, Point-to-Point Protocol)\n\n\n\nThe Services Provided by the Link Layer\n\n成帧(framing)\n链路接入(link access)：媒体访问控制(MAC, Media Access Control)协议规定了帧在链路上的传输规则\n可靠交付(Reliable delivery)：无差错地经链路层移动每个网络层数据报\n差错检测和纠正(Error detection and correction)\n\nWhere Is the Link Layer Implemented?\n网络适配器(network adapter)，也称网卡(Network Interface Card , NIC)\n6.2 Error-Detection and -Correction Techniques\n奇偶校验(Parity Checks)\n前向纠错(Forward Error Correction, FEC)：接收方检测和纠正差错的能力\n\n\n检验和(Checksumming)\n循环冗余检测(CRC, Cyclic Redundancy Check)\n多项式编码(polynomial code)\n生成多项式(generator)\n\n\n\n6.3 Multiple Access Links and Protocols\n\n\n\n\n\n\n\n\n多路访问链路和协议\n\n信道划分协议(Channel Partitioning Protocols)：\nTDM（时分多路复用）\nFDM（频分多路复用）\nCDMA (码分多址, Code Divison Multiple Access)\n\n\n随机接入协议(Random Access Protocols)\nSlotted ALOHA（时隙ALOHA）\nALOHA\nCSMA（载波侦听多路访问）\nCSMA/CD（具有碰撞检测的载波侦听多路访问）\n\n\n轮流协议(Taking-Turns Protocols)\n轮询协议(polling protocol)\n令牌传递协议(token-passing protocol)\n\n\nDOCSIS：用于电缆因特网接入的链路层协议\n\n6.4 Switched Local Area NetworksLink-Layer Addressing and ARP\n\nMAC Addresses(物理地址)\n长度6字节，2^48个可能的MAC地址\nMAC广播地址(broadcast address)：FF-FF-FF-FF-FF-FF\n\n\nARP(地址解析协议, Address Resolution Protocol)\n在IP地址和MAC地址间进行转换\n\n\n\nEthernet Frame \n\nLink-Layer Switches\n链路层交换机：\n\n交换机表(switch table)：(MAC地址，通向该MAC地址的交换机接口，时间)\n自学习(self-learning)\n即插即用设备(plug-and-play device)\n\nSwitches vs Routers\n\n交换机是第二层的分组交换机，路由器是第三层的分组交换机\n\n交换机即插即用，但对于广播风暴(broadcast storms)没有保护措施\n\n路由器和连接到他们的主机需要人为配置IP地址，路由器对第二层的广播风暴提供了防火墙保护(firewall protections)\n\n\n\n\n\n\n\n\n\n\n\n交换机，路由器和主机中的数据包处理\n\nVirtual Local Area Networks (VLANs)\n虚拟局域网的作用：流量隔离(traffic isolation)，管理用户(managing users)\n\nChapter 7 Wireless and Mobile Networks无线网络和移动网络\n7.1 Introduction\n无线主机(wireless host)：主机本身可能移动也可能不移动\n无线链路(wireless communication link)：主机通过无线线路连接到一个基站或者另一台无线主机\n基站(base station)：exp: 蜂窝塔(cell tower)，802.11无线LAN中的接入点(access point)\n\n\n\n7.2 Wireless Links and Network Characteristicswire link vs wireless link\n\n路径损耗(path loss)：信号强度递减\n\n来自其他源的干扰\n\n多径传播(multipath propagation)：电磁波的一部分受反射在发送方和接收方间走了不同长度的路径\n\n\nSignal-to-Noise Ratio(SNR)\n\n\n\n\n\n\n\n\n\n 信噪比(SNR)：所受到的信号和噪声强度的相对测量\n比特差错率(BER)：接收方收到的有错传输的比特的概率\n\n给定调制方案，SNR越高BER越低\n给定SNR，就要较高比特传输率的调制技术将具有较高的BER\n物理层调制技术的动态选择能用于适配对信道条件的调制技术\n\n7.3 WiFi: 802.11 Wireless LANsThe 802.11 Architecture\n\n\n\n\n\n\n\n\n\n速率适应(Rate Adaptation)，功率管理(Power Management)\n\n基本构建模块：基本服务集(Basic Service Set, BSS)\nBSS：一个/多个无线站点，一个接入点(Access Point, AP)的中央基站(base station)\n\n\nChannels and Association\nexp: 你携带移动设备进入WiFi丛林，找无线因特网接入，设在丛林中有5个AP，为获得因特网接入你的无线站点应加入其中一个子网故需与其中一个AP相关联(associate)，即建立一条虚拟线路\nThe 802.11 MAC Protocol\n\n随机访问协议：带碰撞避免的CSMA(CSMA with collision avoidance)，CSMA/CA，类比以太网的CSMA/CD\n\n处理隐藏终端：RTS(短请求发送，Reqeust to Send), CTS(允许发送，Clear to Send)\n\n\nThe IEEE 802.11 Frame\n\n\n","slug":"ComputerNetwork_Note","date":"2021-12-10T05:44:28.000Z","categories_index":"NOTE","tags_index":"note,ComputerNetwork","author_index":"Maskros"},{"id":"845d8d8490a208e5b118592a6863cd87","title":"Trie专题训练","content":"Trie 专题训练0.0\n0x01 统计难题 HDU 1251\n\n\n\n\n\n\n\n\nlink\n题意：给了一堆字符串，统计以模式串作前缀出现的单词个数\ntrie入门题，存结点时统计一下过当前结点的单词个数即可\n&#x2F;&#x2F;对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树\n&#x2F;&#x2F;很多题都是要用到节点下标来表示某个字符串\nconst int maxn &#x3D; 2e6 + 5;  &#x2F;&#x2F;如果是64MB可以开到2e6+5，尽量开大\nint tree[maxn][30];        &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号\nbool flagg[maxn];          &#x2F;&#x2F;表示以该节点结尾是一个单词\nint tot;                   &#x2F;&#x2F;总节点数\nint cnt[maxn];\nvoid insert_(char* str) &#123;\n    int len &#x3D; strlen(str);\n    int root &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; len; i++) &#123;\n        int id &#x3D; str[i] - &#39;a&#39;;\n        if (!tree[root][id])\n            tree[root][id] &#x3D; ++tot;\n        root &#x3D; tree[root][id];\n        cnt[root]++;\n    &#125;\n    flagg[root] &#x3D; true;\n&#125;\nbool find_(char* str) &#123;  &#x2F;&#x2F;查询操作，按具体要求改动\n    int len &#x3D; strlen(str);\n    int root &#x3D; 0;\n    int ans;\n    for (int i &#x3D; 0; i &lt; len; i++) &#123;\n        int id &#x3D; str[i] - &#39;a&#39;;\n        if (!tree[root][id])\n            return false;\n        root &#x3D; tree[root][id];\n        &#x2F;&#x2F; if(!flagg[root] &amp;&amp; i&#x3D;&#x3D;len-1) return false;   &#x2F;&#x2F;判断是否两个单词完全匹配\n    &#125;\n    ans &#x3D; cnt[root];\n    cout&lt;&lt;ans&lt;&lt;endl;\n    return true;\n&#125;\nvoid init() &#123;  &#x2F;&#x2F;最后清空，节省时间\n    for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123;\n        flagg[i] &#x3D; false;\n        for (int j &#x3D; 0; j &lt; 10; j++)\n            tree[i][j] &#x3D; 0;\n    &#125;\n    memset(cnt,0,sizeof(cnt));\n    tot &#x3D; 0;  &#x2F;&#x2F;RE有可能是这里的问题\n&#125;\nvoid solve() &#123;\n    char str[15];\n    init();\n    while(gets(str)&amp;&amp;str[0]!&#x3D;&#39;\\0&#39;)&#123;\n        insert_(str);\n    &#125;\n    while(gets(str)&amp;&amp;str[0]!&#x3D;EOF)&#123;\n        bool t &#x3D; find_(str);\n        if(!t) cout&lt;&lt;0&lt;&lt;endl;    \n    &#125;\n&#125;\n\n0x02 Remember the Word LA 3942\n\n\n\n\n\n\n\n\nlink\n题意：\n给出一个由S个不同单词组成的字典和一个长字符串，把这个字符串分解成若干个单词的连接(可重复使用)，有多少种方法。ex: 有四个单词：a, b, cd, ab；则abcd有两种分解方法：a+b+cd 和 ab+cd\n思路：\ndp + Trie\n计数问题考虑dp：\n考虑状态：dp[i] 为以i开始的后缀的方案数\n考虑转移：因为单词长度不大于100，我们可以直接暴力向后看当前单词是否存在，所以可以用Trie或者字符串哈希完成\n令dp(i)表示从字符i开始的字符串，dp(i)=sum{dp(i+len(x))}, x是s[i…L]的前缀。然后把所有可分解成的单词构造成一颗Trie树，再让母串在上面跑，dp[0]即是方案总数。\n#include &lt;bits&#x2F;stdc++.h&gt;\n#define maxn 300005\n#define mod 20071027\nchar P[maxn];\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x; i &gt;&#x3D; y; i--)\nusing namespace std;\nint dp[maxn];        &#x2F;&#x2F;dp[i] 为以i开始的后缀的方案数\nint tree[maxn][30];  &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号\nbool flagg[maxn];    &#x2F;&#x2F;表示以该节点结尾是一个单词\nint tot;             &#x2F;&#x2F;总节点数\nint m;               &#x2F;&#x2F;主串长度\nvoid insert_(char* str) &#123;\n    int len &#x3D; strlen(str);\n    int root &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; len; i++) &#123;\n        int id &#x3D; str[i] - &#39;a&#39;;\n        if (!tree[root][id])\n            tree[root][id] &#x3D; ++tot;\n        root &#x3D; tree[root][id];\n    &#125;\n    flagg[root] &#x3D; true;\n&#125;\nvoid find_(int id) &#123;  &#x2F;&#x2F;查询操作，按具体要求改动\n    int root &#x3D; 0;\n    for (int i &#x3D; id; i &lt;&#x3D; m; i++) &#123;\n        int k &#x3D; P[i] - &#39;a&#39;;\n        if (!tree[root][k]) break;\n        root &#x3D; tree[root][k];\n        if (flagg[root])    \n            dp[id] &#x3D; (dp[id] + dp[i + 1]) % mod;\n    &#125;\n&#125;\nvoid init() &#123; \n    for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123;\n        flagg[i] &#x3D; false;\n        for (int j &#x3D; 0; j &lt; 30; j++)\n            tree[i][j] &#x3D; 0;\n    &#125;\n    memset(dp, 0, sizeof(dp));\n    tot &#x3D; 0; \n&#125;\nchar c[105];\nint main() &#123;\n    long long times &#x3D; 0;\n    init();\n    while (scanf(&quot;%s&quot;, P)!&#x3D;EOF) &#123;\n        times++;\n        int S;\n        cin &gt;&gt; S;\n        &#x2F;&#x2F; init();\n        rep(i, 0, S) &#123;\n            scanf(&quot;%s&quot;, c);\n            insert_(c);\n        &#125;\n        m &#x3D; strlen(P);\n        dp[m] &#x3D; 1;\n        red(i, m, 0) &#123;\n            find_(i);\n        &#125;\n        cout &lt;&lt; &quot;Case &quot; &lt;&lt; times &lt;&lt; &quot;: &quot; &lt;&lt; dp[0] &lt;&lt; endl;\n        init();\n    &#125;\n&#125;\n\n\n\n0x03 “strcmp()” Anyone?\n\n\n\n\n\n\n\n\nlink\n题意：\n输入n个字符串，两两调用一次strcmp()，问字符比较的总次数是多少？ex:\nstrcmp(“than”, &quot;that&quot;)：cnt = 7\n题解：两个字符串比较次数其实是 *相同字符数2 + (存在不同字符? 1 : 0)**；然后建字典树，dfs一下即可。因为节点的个数比较多，所以用左孩子右兄弟的方法建立字典树。\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int maxnode &#x3D; 4000 * 1000 + 10;\nconst int sigma_size &#x3D; 26;\n&#x2F;&#x2F; 字母表为全体小写字母的Trie\nstruct Trie &#123;\n    int head[maxnode];  &#x2F;&#x2F; head[i]为第i个结点的左儿子编号\n    int next[maxnode];  &#x2F;&#x2F; next[i]为第i个结点的右兄弟编号\n    char ch[maxnode];   &#x2F;&#x2F; ch[i]为第i个结点上的字符\n    int tot[maxnode];   &#x2F;&#x2F; tot[i]为第i个结点为根的子树包含的叶结点总数\n    int sz;             &#x2F;&#x2F; 结点总数\n    long long ans;      &#x2F;&#x2F; 答案\n    void clear() &#123;\n        sz &#x3D; 1;\n        tot[0] &#x3D; head[0] &#x3D; next[0] &#x3D; 0;\n    &#125;  &#x2F;&#x2F; 初始时只有一个根结点\n\n    &#x2F;&#x2F; 插入字符串s（包括最后的&#39;\\0&#39;），沿途更新tot\n    void insert(const char* s) &#123;\n        int u &#x3D; 0, v, n &#x3D; strlen(s);\n        tot[0]++;\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            &#x2F;&#x2F; 找字符a[i]\n            bool found &#x3D; false;\n            for (v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v])\n                if (ch[v] &#x3D;&#x3D; s[i]) &#123;  &#x2F;&#x2F; 找到了\n                    found &#x3D; true;\n                    break;\n                &#125;\n            if (!found) &#123;\n                v &#x3D; sz++;  &#x2F;&#x2F; 新建结点\n                tot[v] &#x3D; 0;\n                ch[v] &#x3D; s[i];\n                next[v] &#x3D; head[u];\n                head[u] &#x3D; v;  &#x2F;&#x2F; 插入到链表的首部\n                head[v] &#x3D; 0;\n            &#125;\n            u &#x3D; v;\n            tot[u]++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 统计LCP&#x3D;u的所有单词两两的比较次数之和\n    void dfs(int depth, int u) &#123;\n        if (head[u] &#x3D;&#x3D; 0)  &#x2F;&#x2F; 叶结点\n            ans +&#x3D; tot[u] * (tot[u] - 1) * depth;\n        else &#123;\n            int sum &#x3D; 0;\n            for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v])\n                sum +&#x3D; tot[v] * (tot[u] - tot[v]);  &#x2F;&#x2F; 子树v中选一个串，其他子树中再选一个\n            ans +&#x3D; sum &#x2F; 2 * (2 * depth + 1);       &#x2F;&#x2F; 除以2是每种选法统计了两次\n            for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v])\n                dfs(depth + 1, v);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 统计\n    long long count() &#123;\n        ans &#x3D; 0;\n        dfs(0, 0);\n        return ans;\n    &#125;\n&#125;;\nconst int maxl &#x3D; 1000 + 10;  &#x2F;&#x2F; 每个单词最大长度\nint n;\nchar word[maxl];\nTrie trie;\nint main() &#123;\n    int kase &#x3D; 1;\n    while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123;\n        trie.clear();\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            scanf(&quot;%s&quot;, word);\n            trie.insert(word);\n        &#125;\n        printf(&quot;Case %d: %lld\\n&quot;, kase++, trie.count());\n    &#125;\n    return 0;\n&#125;\n\n","slug":"trie_problem","date":"2021-11-27T04:20:00.000Z","categories_index":"ALGORITHM TRAINING","tags_index":"ACM,string,algorithm,dp,Trie,dfs","author_index":"Maskros"},{"id":"f9c5a67ed89813cc4d2fda9f690375dd","title":"Trie","content":"Trie字典树/前缀树\n什么是Trie\n\n\n\n\n\n\n\n\n从根节点到每个单词结点的路径上所有字母连接成的字符串就是该结点对应的字符串\n\n多叉树，最大分支数由字典的字符集含有的字符数决定\n\n\n\n\n\n操作\n插入字符串 insert \n\n初始化 root = 0 , 遍历字符串, 对于其每一个字符, 计算其映射值 id\n\n检查Trie[root][id] == 0 是否成立：\n若成立, 则进行插入,  Trie[root][id] = ++cnt\n若不成立,说明该位置已经有该字符,直接找到下一个字符应插入的位置: root = trie[root][id].\n\n重复上述步骤,直到字符串完全插入Trie树.\n\n\n\n匹配字符串 search\n\n初始化root = 0,遍历字符串,对于其每一个字符,计算其映射值id\n\n检查Trie[root][id] == 0是否成立：\n若成立, 则说明Trie树当前路径不存在该字符,返回匹配失败\n若不成立,则说明当前路径存在该字符,找到下一个字符的位置: root = trie[root][id]\n\n重复上述步骤，若顺利匹配完整个字符串,则应该检查字符串结束的位置在Trie树中是否是结束标志，flag[root] == true成立,表明是结束标志,则返回匹配成功,否则返回匹配失败\n\n\n\n\n模板\n附：字符数组操作\n\nchar s1[maxn], s2[maxn];\nstrcpy(s1, s2);\t\t&#x2F;&#x2F;复制字符串 s2 到字符串 s1。\nstrcat(s1, s2);\t\t&#x2F;&#x2F;连接字符串 s2 到字符串 s1 的末尾。\nstrlen(s1);\t\t\t&#x2F;&#x2F;返回字符串 s1 的长度。\nstrcmp(s1, s2);\t\t&#x2F;&#x2F;如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。\nstrchr(s1, ch);\t\t&#x2F;&#x2F;返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。\nstrstr(s1, s2);\t\t&#x2F;&#x2F;返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。\n\n\n模拟\n\n\n\n\n\n\n\n\n\n\n对结构体Trie进行插入和查询操作\nval[i] &gt; 0 表示这是一个单词结点\n#define maxn 41000\n#define sigmasize 26  &#x2F;&#x2F; 字符集的大小 ex: 全体小写字母：26\nstruct Trie&#123;\n    int ch[maxn][sigmasize];\n    int val[maxn];  &#x2F;&#x2F; 结点i对应的附加信息，如每个字符串的权值, 如val[i]&gt;0 当且仅当结点i是单词结点\n    int sz;            &#x2F;&#x2F; 结点总数\n\n    Trie() &#123; sz &#x3D; 1; memset(ch[0], 0, sizeof(ch[0]));&#125;   &#x2F;&#x2F;初始只有一个根节点\n    int idx(char c) &#123; return c - &#39;a&#39;; &#125;  &#x2F;&#x2F;字符c的编号\n\n    &#x2F;&#x2F; 插入字符串s, 附加信息为v。v必须非0, 0 代表“本结点不是单词结点”\n    inline void insert(char *s, int v) &#123;\n        int u &#x3D; 0, n &#x3D; strlen(s);\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            int c &#x3D; idx(s[i]);\n            if (!ch[u][c]) &#123;  &#x2F;&#x2F;结点不存在\n                memset(ch[sz], 0, sizeof(ch[sz]));\n                val[sz] &#x3D; 0;      &#x2F;&#x2F;中间节点的附加信息为0\n                ch[u][c] &#x3D; sz++;  &#x2F;&#x2F;新建节点\n            &#125;\n            u &#x3D; ch[u][c];  &#x2F;&#x2F;往下走\n        &#125;\n        val[u] &#x3D; v;  &#x2F;&#x2F;字符串的最后一个字符的附加信息为v\n    &#125;\n    &#x2F;&#x2F; 查找字符串s\n    inline bool search(char *s) &#123;\n        int u &#x3D; 0, n &#x3D; strlen(s);\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            int c &#x3D; idx(s[i]);\n            if (ch[u][c] &#x3D;&#x3D; 0) return false;\n            u &#x3D; ch[u][c];\n        &#125;\n        if (val[u] &#x3D;&#x3D; 0)\n            return false;\n        return true;\n    &#125;\n&#125;trie;\n\n\n版本2\n\n\n\n\n\n\n\n\n\n\n可以用 find(str) 判断字典树中是否有以 str 作前缀的单词\n//对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树\n//很多题都是要用到节点下标来表示某个字符串\nconst int maxn = 2e6 + 5;  //如果是64MB可以开到2e6+5，尽量开大\nint tree[maxn][30];        //tree[i][j]表示节点i的第j个儿子的节点编号\nbool flagg[maxn];          //表示以该节点结尾是一个单词\nint tot;                   //总节点数\nvoid insert_(char* str) &#123;\n    int len = strlen(str);\n    int root = 0;\n    for (int i = 0; i &lt; len; i++) &#123;\n        int id = str[i] - 'a';\n        if (!tree[root][id])\n            tree[root][id] = ++tot;\n        root = tree[root][id];\n    &#125;\n    flagg[root] = true;\n&#125;\nbool find_(char* str)&#123;  //查询操作，按具体要求改动\n    int len = strlen(str);\n    int root = 0;\n    for (int i = 0; i &lt; len; i++) &#123;\n        int id = str[i] - 'a';\n        if (!tree[root][id])\n            return false;\n        root = tree[root][id];\n        if(!flagg[root] &amp;&amp; i==len-1) return false;   //判断是否两个单词完全匹配\n    &#125;\n    return true;\n&#125;\nvoid init()&#123; \n    for (int i = 0; i &lt;= tot; i++) &#123;\n        flagg[i] = false;\n        for (int j = 0; j &lt; 30; j++)\n            tree[i][j] = 0;\n    &#125;\n    tot = 0;  //RE有可能是这里的问题\n&#125;\n\n\n优化trie树\n\n\n\n\n\n\n\n\n\n当结点比较多，sigma_size比较大的时候，采用左儿子-右兄弟建立trie\n\n\nstruct Trie &#123;\n    int head[maxn];  &#x2F;&#x2F; head[i]为第i个结点的左儿子编号\n    int next[maxn];  &#x2F;&#x2F; next[i]为第i个结点的右兄弟编号\n    char ch[maxn];   &#x2F;&#x2F; ch[i]为第i个结点上的字符\n    int sz;             &#x2F;&#x2F; 结点总数\n\n    void clear() &#123;\n        sz &#x3D; 1;\n        tot[0] &#x3D; head[0] &#x3D; next[0] &#x3D; 0;\n    &#125;\n    void insert(const char* s) &#123;\n        int u &#x3D; 0, v, n &#x3D; strlen(s);\n        tot[0]++;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            bool found &#x3D; false;\n            for (v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v])\n                if (ch[v] &#x3D;&#x3D; s[i]) &#123;\n                    found &#x3D; true;\n                    break;\n                &#125;\n            if (!found) &#123;\n                v &#x3D; sz++;\n                tot[v] &#x3D; 0;\n                ch[v] &#x3D; s[i];\n                next[v] &#x3D; head[u];\n                head[u] &#x3D; v;\n                head[v] &#x3D; 0;\n            &#125;\n            u &#x3D; v;\n            tot[u]++;\n        &#125;\n    &#125;\n&#125;;\n\n题单solution\n\n0x01 统计难题 HDU 1251 link\n\n0x02 背单词 LA 3942 link\n\n0x03 strcmp()函数 UVa 11732 link\n\n\n\n\n\n\n\n\n\n\n\n假如再来一遍银川\n","slug":"trie","date":"2021-11-27T03:55:50.000Z","categories_index":"ALGORITHMS","tags_index":"ACM,note,string,algorithm,Trie","author_index":"Maskros"},{"id":"eb0105647eb3a218c386b75ad79d5f5a","title":"kmp专题训练","content":"kmp/ekmp 专题训练\n\n\n\n\n\n\n\n\n🐴糙人蠢凑合看\n0x01 剪花布条 HDU-2087\n\n\n\n\n\n\n\n\nlink\n纯纯kmp裸题，不可重叠计数 \n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nvoid kmp_pre(string p, int next[])\n&#123;\n    int i, j;\n    j &#x3D; next[0] &#x3D; -1;\n    i &#x3D; 0;\n    while (i &lt; p.length())\n    &#123;\n        while (-1 !&#x3D; j &amp;&amp; p[i] !&#x3D; p[j])\n            j &#x3D; next[j];\n        next[++i] &#x3D; ++j;\n    &#125;\n&#125;\nint kmp_Count(string x, string y, int next[])\n&#123; \n    int i, j;\n    int ans &#x3D; 0;\n    kmp_pre(x, next);\n    i &#x3D; j &#x3D; 0;\n    while (i &lt; y.length())\n    &#123;\n        while (-1 !&#x3D; j &amp;&amp; y[i] !&#x3D; x[j])\n            j &#x3D; next[j];\n        i++;\n        j++;\n        if (j &gt;&#x3D; x.length())\n        &#123;\n            ans++;\n            j &#x3D; 0;       &#x2F;&#x2F;不可重叠计数\n        &#125;\n    &#125;\n    return ans;\n&#125;\nint main()&#123;\n    string a,b;\n    int nxt[1005];\n    while(1)&#123;\n        cin&gt;&gt;a;\n        if(a&#x3D;&#x3D;&quot;#&quot;) break;\n        else&#123;\n            cin&gt;&gt;b;\n            memset(nxt,0,b.length()+1);\n            int ans&#x3D;kmp_Count(b,a,nxt);\n            cout&lt;&lt;ans&lt;&lt;endl;            \n        &#125;\n    &#125;    \n&#125;\n\n0x02 Secret HDU-6153\n\n\n\n\n\n\n\n\nlink\n题意：\n给两个串s1,s2，求s2所有的后缀子串的长度乘在主串s1中出现的次数之和\n解法：\n挨个枚举后缀是🐷b做法，我们可以先把字符串翻转，这样后缀变前缀，就来到了我们熟悉的kmp匹配环节\n解法一：exkmp\n翻转后发现这不就正好利用extend[]数组的定义直接求解，做一遍ekmp，遍历extend[]数组，对每个值做 (1+entend[i])*entend[i]&gt;&gt;1 处理，全部加和即为答案\n解法二：kmp\n利用对next[]数组的理解，暂时鸽了，因为想了很久没想明白\n解法一： ekmp \n\n\n\n\n\n\n\n\n\n猛wa之后给了我深刻的教训：数组开 longlong😅😅\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int mod &#x3D; 1000000007;\n#define ll long long\n#define maxn 1000005\n#define rep(i,x,y) for(int i&#x3D;x;i&lt;y;i++)\nll nxt[maxn], extend[maxn];\nvoid ekmp_pre(string x, ll next[])\n&#123;\n    int m &#x3D; x.length();\n    next[0] &#x3D; m;\n    int j &#x3D; 0;\n    while (j + 1 &lt; m &amp;&amp; x[j] &#x3D;&#x3D; x[j + 1])\n        j++;\n    next[1] &#x3D; j;\n    int k &#x3D; 1;\n    for (int i &#x3D; 2; i &lt; m; i++)\n    &#123;\n        int p &#x3D; next[k] + k - 1;\n        int L &#x3D; next[i - k];\n        if (i + L &lt; p + 1)\n            next[i] &#x3D; L;\n        else\n        &#123;\n            j &#x3D; max(0, p - i + 1);\n            while (i + j &lt; m &amp;&amp; x[i + j] &#x3D;&#x3D; x[j])\n                j++;\n            next[i] &#x3D; j;\n            k &#x3D; i;\n        &#125;\n    &#125;\n&#125;\nll ekmp(string x, string y, ll next[], ll extend[])\n&#123;\n    ekmp_pre(x, next);\n    int j &#x3D; 0;\n    ll ret &#x3D; 0;\n    int m &#x3D; x.length(), n &#x3D; y.length();\n    while (j &lt; n &amp;&amp; j &lt; m &amp;&amp; x[j] &#x3D;&#x3D; y[j])\n        j++;\n    extend[0] &#x3D; j;\n    int k &#x3D; 0;\n    for (int i &#x3D; 1; i &lt; n; i++)\n    &#123;\n        int p &#x3D; extend[k] + k - 1;\n        int L &#x3D; next[i - k];\n        if (i + L &lt; p + 1)\n            extend[i] &#x3D; L;\n        else\n        &#123;\n            j &#x3D; max(0, p - i + 1);\n            while (i + j &lt; n &amp;&amp; j &lt; m &amp;&amp; y[i + j] &#x3D;&#x3D; x[j])\n                j++;\n            extend[i] &#x3D; j;\n            k &#x3D; i;\n        &#125;\n    &#125;\n    rep(i, 0, n)\n    &#123;\n        ret &#x3D; (ret % mod + (((1 + extend[i])* extend[i])&gt;&gt;1) % mod) % mod;\n    &#125;\n    return ret;\n&#125;\nint main()\n&#123;\n    int t;\n    ios::sync_with_stdio(false);\n    cin &gt;&gt; t;\n    while (t--)\n    &#123;\n        string s, p;\n        cin &gt;&gt; s &gt;&gt; p;\n        reverse(s.begin(), s.end());\n        reverse(p.begin(), p.end());\n        memset(nxt, 0, p.length() + 1);\n        memset(extend, 0, s.length() + 1);\n        ll ans;\n        ans&#x3D;ekmp(p, s, nxt, extend);\n        cout&lt;&lt;ans&lt;&lt;endl;\n    &#125;\n&#125;\n\n解法二：kmp\n&#x2F;&#x2F; 寄\n\n\n\n\n\n0x03 Cow Patterns POJ-3167\n\n\n\n\n\n\n\n\nlink 牛题\n题意：\n模式串可以浮动的模式匹配问题\n给出模式串的相对大小顺序，需要找出在主串中模式串的匹配次数和起始位置\n样例：\nS: 5 6 2 10 10 7 3 2 9  \nP: 1 4 4 3 2 1\n故 2 10 10 7 3 2 符合要求，输出为 1 3\n解法： KMP+前缀和\n统计比当前数小，和于当前数相等的，然后进行kmp\n&#x2F;&#x2F;POJ 3167\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int MAXN &#x3D; 100005;\nconst int MAXM &#x3D; 25005;\n\nint a[MAXN];       &#x2F;&#x2F; 存放主串\nint b[MAXM];       &#x2F;&#x2F; 存放模式串\nint as[MAXN][30];  &#x2F;&#x2F; as[i][j] &#x3D; k表示0 - i位中有k个数字j\nint bs[MAXM][30];  &#x2F;&#x2F; bs[i][j] &#x3D; k表示0 - i位中有k个数字j\nint next[MAXM];    &#x2F;&#x2F; 存放模式串失配时的移动位数\nvector&lt;int&gt; ans;   &#x2F;&#x2F; 存放结果\nint n, m, s;\n\nvoid Init() &#123;\n    ans.clear();\n    memset(as, 0, sizeof(as));\n    memset(bs, 0, sizeof(bs));\n    as[1][a[1]] &#x3D; 1;\n    bs[1][b[1]] &#x3D; 1;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;\n        memcpy(as[i], as[i - 1], sizeof(as[0]));\n        ++as[i][a[i]];\n    &#125;\n    for (int i &#x3D; 2; i &lt;&#x3D; m; ++i) &#123;\n        memcpy(bs[i], bs[i - 1], sizeof(bs[0]));\n        ++bs[i][b[i]];\n    &#125;\n&#125;\n\nvoid GetNext() &#123;\n    memset(next, 0, sizeof(next));\n    int i &#x3D; 1, j &#x3D; 0, k &#x3D; 0;\n    next[1] &#x3D; 0;\n    while (i &lt;&#x3D; m) &#123;\n        int si &#x3D; 0, sj &#x3D; 0, ei &#x3D; 0, ej &#x3D; 0;\n        for (k &#x3D; 1; k &lt; b[i]; ++k)\n            si +&#x3D; bs[i][k] - bs[i - j][k];\n        ei &#x3D; bs[i][k] - bs[i - j][k];\n        for (k &#x3D; 1; k &lt; b[j]; ++k)\n            sj +&#x3D; bs[j][k];\n        ej &#x3D; bs[j][k];\n        if (0 &#x3D;&#x3D; j || (si &#x3D;&#x3D; sj &amp;&amp; ei &#x3D;&#x3D; ej))\n            next[++i] &#x3D; ++j;\n        else\n            j &#x3D; next[j];\n    &#125;\n&#125;\n\nvoid Kmp() &#123;\n    int i &#x3D; 1, j &#x3D; 1, k &#x3D; 1;\n    while (i &lt;&#x3D; n) &#123;\n        int si &#x3D; 0, sj &#x3D; 0, ei &#x3D; 0, ej &#x3D; 0;\n        for (k &#x3D; 1; k &lt; a[i]; ++k)\n            si +&#x3D; as[i][k] - as[i - j][k];\n        ei &#x3D; as[i][k] - as[i - j][k];\n        for (k &#x3D; 1; k &lt; b[j]; ++k)\n            sj +&#x3D; bs[j][k];\n        ej &#x3D; bs[j][k];\n        if (0 &#x3D;&#x3D; j || (si &#x3D;&#x3D; sj &amp;&amp; ei &#x3D;&#x3D; ej))\n            ++i, ++j;\n        else\n            j &#x3D; next[j];\n        if (j &#x3D;&#x3D; m + 1) &#123;\n            ans.push_back(i - m);\n            j &#x3D; next[j];\n        &#125;\n    &#125;\n&#125;\n\nint main() &#123;\n    while (scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s) &#x3D;&#x3D; 3) &#123;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)\n            scanf(&quot;%d&quot;, &amp;a[i]);\n        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i)\n            scanf(&quot;%d&quot;, &amp;b[i]);\n        Init();\n        GetNext();\n        Kmp();\n        size_t len &#x3D; ans.size();\n        printf(&quot;%d\\n&quot;, len);\n        for (size_t i &#x3D; 0; i &lt; len; ++i)\n            printf(&quot;%d\\n&quot;, ans[i]);\n    &#125;\n    return 0;\n&#125;\n\n","slug":"kmp_problem","date":"2021-11-26T13:59:50.000Z","categories_index":"ALGORITHM TRAINING","tags_index":"ACM,string,algorithm,kmp,dp,前缀和","author_index":"Maskros"},{"id":"38cc96ca6220c98ec8c78c52ef6fea74","title":"2021CCPC广州站vp","content":"2021CCPC广州站vp\n\n\n\n\n\n\n\n\n“如何解方程”\nC_Necklace\n\n\n\n\n\n\n\n\n二分+贪心\n读题比较关键 没改明白wa3\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define sec second\n#define eif else if\n#define en putchar('\\n')    \n#define rep(i, x, y) for (ll i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x - 1; i >= y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 1000005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nll M,N;\nll pos[maxn];\nbool check(ll x)&#123;\n    ll last=0,tmp,end;\n    end=N-pos[M-1]+pos[0];\n    rep(i,0,M)&#123;\n        if(i==0)&#123;\n            if(end&lt;=x) &#123;last=end; end=0; continue;&#125;\n            else&#123; end-=x;  last=x; continue;&#125;\n        &#125;eif(i==M-1) tmp=end+pos[i]-pos[i-1];\n        else tmp=pos[i]-pos[i-1];\n\n        ll can=pos[i]-pos[i-1]-1;\n        can=(can>0)?can:0;\n        ll sub=(x-last>can)?can:(x-last);\n        if(tmp>=sub) tmp-=sub;\n        else tmp=0;\n        if(tmp&lt;=x) last=tmp;\n        else return 0;\n    &#125;\n    return 1;\n&#125;\nvoid solve() &#123;\n    // N=read(); M=read();\n    cin>>N>>M;\n    ll ans=1,tmp,last=1;\n    rep(i,0,M)&#123;\n        cin>>pos[i];\n    &#125;\n    if(M==1) &#123;cout&lt;&lt;N; return;&#125;\n    ll l=1,r=N;\n    while(l&lt;=r)&#123;\n        ll mid=(l+r)>>1;\n        if(check(mid))&#123;\n            ans=mid;\n            r=mid-1;\n        &#125;else&#123;\n            l=mid+1;\n        &#125;\n    &#125;   \n    cout&lt;&lt;ans&lt;&lt;endl;\n&#125;\nint main() &#123;\n    int T = 1;\n    IOS;\n    // cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\nH_Three Intergers\n\n\n\n\n\n\n\n\n题意：给a,b,c，求满足x%y=a, y%z=b, z%x=c 的任意一组x,y,z\n思路：数学题，方程化简，根据条件直接造，起初忘记了模的性质导致解不出方程，看了题解恍然大悟 题解\n#include &lt;bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    int T;\n    cin >> T;\n    while (T--) &#123;\n        int a, b, c;\n        cin >> a >> b >> c;\n        if (a == b &amp;&amp; b == c) &#123;\n            if (!a) &#123;\n                cout &lt;&lt; \"YES\\n\";\n                cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; 1 &lt;&lt; \"\\n\";\n            &#125; else\n                cout &lt;&lt; \"NO\\n\";\n            continue;\n        &#125;\n        ll x, y, z, k;\n        if (b > a) &#123;\n            k = max(0, (c - a) / b) + 1;\n            x = k * b + a;\n            y = b;\n            z = (k * b + a) * 2 + c;\n        &#125; else if (a > c) &#123;\n            k = max(0, (b - c) / a) + 1;\n            x = a;\n            y = (k * a + c) * 2 + b;\n            z = k * a + c;\n        &#125; else if (c > b) &#123;\n            k = max(0, (a - b) / c) + 1;\n            x = (k * c + b) * 2 + a;\n            y = k * c + b;\n            z = c;\n        &#125; else\n            assert(false);\n        cout &lt;&lt; \"YES\\n\";\n        cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; \"\\n\";\n        assert(x % y == a &amp;&amp; y % z == b &amp;&amp; z % x == c);\n        assert(x &lt;= 1e18);\n        assert(y &lt;= 1e18);\n        assert(z &lt;= 1e18);\n    &#125;\n    return 0;\n&#125;\n\nI_Pudding Store\n\n\n\n\n\n\n\n\n手算了一下太麻烦，全排列打表找规律即可\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define sec second\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x - 1; i >= y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\n#define mod 998244353\nusing namespace std;\n// 1 2 6 12 24 48 96 192 384 768\n// int a[50];\n// void init(int n)&#123;\n//     rep(i,1,n+1) a[i]=i;\n// &#125;\n// void dfs()&#123;\n//     rep(i,1,11)&#123;\n//         ll cnt=0;\n//         init(i);\n//         bool t=true;\n//         while(t)&#123;\n//             bool can=false;\n//             rep(j,1,i+1)&#123;\n//                 ll fuck=0;\n//                 rep(k,1,j+1)&#123;\n//                     fuck+=a[k];\n//                 &#125;\n//                 fuck*=2;\n//                 if(fuck%j==0) can=true;\n//                 else &#123;can=false; break;&#125;\n//             &#125;\n//             if(can) cnt++;\n//             t=next_permutation(a+1,a+i+1);\n//         &#125;\n//         cout&lt;&lt;cnt&lt;&lt;\" \";\n//     &#125;\n// &#125;\nll qpow(ll a, ll b)&#123;\n    ll ans=1;\n    ll res=a;\n    res%=mod;\n    while(b)&#123;if(b&amp;1) ans=ans*res%mod; b>>=1; res=res*res%mod;&#125;\n    return ans%mod;\n&#125;\nvoid solve() &#123;\n    int n; cin>>n;\n    if(n==1) cout&lt;&lt;1&lt;&lt;endl;\n    eif(n==2) cout&lt;&lt;2&lt;&lt;endl;\n    eif(n==3) cout&lt;&lt;6&lt;&lt;endl;\n    else&#123;\n        ll tmp=6;\n        ll add=qpow(2,n-3);\n        tmp=add%mod*tmp%mod;\n        cout&lt;&lt;tmp&lt;&lt;endl;\n    &#125;\n&#125;\nint main() &#123;\n    int T = 1;\n    IOS;\n    // dfs();\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：什么时候才能不粗心\n","slug":"2021ccpc_guangzhou","date":"2021-11-24T16:42:00.000Z","categories_index":"SOLUTIONS","tags_index":"solutions,CCPC,ACM,二分,打表,数学,贪心","author_index":"Maskros"},{"id":"5746fb5b2209a46ecf437112c82754ca","title":"2021CCPC桂林站vp","content":"2021CCPC桂林站vp\n\n\n\n\n\n\n\n\n”祭奠擦肩而过的桂林两日游“\nA_Hero Named Magnus\n\n\n\n\n\n\n\n\n水题。为什么不ban猛犸？输出2n-1\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nvoid solve() &#123;\n    ll x; cin>>x;\n    ll ans;\n    ans=x*2-1;\n    cout&lt;&lt;ans&lt;&lt;endl;\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\nD_Assumption is All You Need\n\n\n\n\n\n\n\n\n构造题\n题意：给你两个序列A，B，对A可执行操作：若 i&lt;j 且 Ai&gt;Aj，可将Ai与Aj交换，问能否通过合法的操作将A变成B，并打印操作序列  \n思路：从屁股往前扫一遍，如果Ai和Bi不一样，就从A[Bi_pos]往前扫，寻求最优解，瞎JB贪心，wa2待补\n\n\nE_Buy and Delete\n\n\n\n\n\n\n\n\n题意：给了你一些带权有向边，Alice可以用已有的c元钱购买一些边形成一张有向图；随后Bob进行删边，每次可以删除一个无环的子集，Alice想最大化删边次数，Bob想最小化，二者都采取最优操作，问Bob需要删除几次\n思路：答案只可能是0,1,2，0的情况是Alice一条边都买不起，1的情况是Alice买的无环图，2的情况是Alice买的带环图，无论有几个环，Bob都只需要删两次就够了，这个比较容易理解。\n解法：直接把所有边存到一个有向图里，做Dijkstra找从v-&gt;v 的最短路，判断买不买得起就可以了\nps: 开始犯病用 n2 的Dij结果T了，换了 nlogn 的堆优化Dij就不T了；然后还在想改造一下Dij让起点为 i 的dist数组可以存 dist[i]，结果想了想直接Dij完了之后dist[j] + mincost[j][i] 不就是环的长度吗，wssb \n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 1000000001\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x - 1; i >= y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 2005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nint n, m, c;\nstruct qnode&#123;\n    int v,c;\n    qnode(int _v=0,int _c=0):v(_v),c(_c)&#123;&#125;\n    bool operator &lt;(const qnode &amp;r)const&#123;\n        return c>r.c;\n    &#125;\n&#125;;\nstruct Edge&#123;\n    int v,cost;\n    Edge(int _v=0,int _cost=0):v(_v),cost(_cost)&#123;&#125;\n&#125;;\nvector&lt;Edge>E[maxn];\nbool vis[maxn];\nint dist[maxn];\nint mincost[maxn][maxn];\nvoid Dijkstra(int start)&#123; \n    memset(vis,false,sizeof(vis));\n    for(int i=1;i&lt;=n;i++)dist[i]=INF;\n    priority_queue&lt;qnode>que;\n    while(!que.empty()) que.pop();\n    dist[start]=0;\n    que.push(qnode(start,0));\n    qnode tmp;\n    while(!que.empty())&#123;\n        tmp=que.top(); que.pop();\n        int u=tmp.v;\n        if(vis[u])continue;\n        vis[u]=true;\n        for(int i=0;i&lt;E[u].size();i++)&#123;\n            int v=E[tmp.v][i].v;\n            int cost=E[u][i].cost;\n            if(!vis[v]&amp;&amp;dist[v]>dist[u]+cost)&#123;\n                dist[v]=dist[u]+cost; \n                que.push(qnode(v,dist[v]));\n            &#125;\n        &#125;\n    &#125;\n&#125;\nvoid addedge(int u,int v,int w)&#123;\n    E[u].push_back(Edge(v,w));\n&#125;\nint main() &#123;\n    scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;c);\n    int mncost=INF;\n    int u, v, p;\n    rep(i,1,n+1)\n        rep(j,1,n+1)\n            mincost[i][j]=INF;\n    rep(i,0,m)&#123;\n        scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;p);\n        addedge(u,v,p);\n        mincost[u][v]=min(mincost[u][v],p);\n        mncost=min(mncost,p);\n    &#125;\n    if(mncost>c)&#123; cout&lt;&lt;0; return 0; &#125;\n    eif(mncost==c)&#123; cout&lt;&lt;1; return 0;&#125; \n    rep(i,1,n+1)&#123;\n        Dijkstra(i);\n        rep(j,1,n+1)&#123;\n            if(i!=j &amp;&amp; dist[j]+mincost[j][i]&lt;=c)&#123;cout&lt;&lt;2; return 0;&#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;1;\n    return 0;\n&#125;\n\nG_Occupy the Cities\n\n\n\n\n\n\n\n\n二分答案/dp\n题意：一个01串，每次操作可以将串中所有的1的左边一位或右边一位也变成1，问变成全1串需要几次操作\n解法：二分答案，check() 中从串的左边到右边对每一位1嗯贪心，dp解法没看\n#include &lt;bits/stdc++.h>\n#define mp make_pair\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define maxn 1000005\n#define pb push_back\n#define fst first\n#define sec second\nusing namespace std;\nchar s[maxn];\nint n;\nvector&lt;int> one;\nint need[maxn];\nvoid init(int t) &#123;\n    scanf(\"%s\", s + 1);\n    one.clear();\n    rep(i, 1, t + 1) &#123;\n        need[i] = 0;\n        if (s[i] == '1') &#123;\n            one.pb(i);\n        &#125;\n    &#125;\n&#125;\nint check(int x) &#123;\n    if (one[0] - 1 > x)\n        return 0;\n    if (one[0] - 1 == x)\n        need[1] = 1;\n    int tmp;\n    rep(i, 1, one.size()) &#123;\n        if (one[i] - one[i - 1] == 1)\n            continue;\n        tmp = one[i] - one[i - 1] - 1 + need[i];\n        if ((tmp + 1) / 2 > x)\n            return 0;\n        else if ((tmp + 1) / 2 == x) &#123;\n            if (tmp / 2 == x)\n                need[i + 1] = 1;\n        &#125;\n    &#125;\n    tmp = n - one[one.size() - 1] + need[one.size()];\n    if (tmp > x)\n        return 0;\n    return 1;\n&#125;\nvoid solve() &#123;\n    cin >> n;\n    init(n);\n    if (one.size() == n) &#123;\n        cout &lt;&lt; 0 &lt;&lt; endl;\n        return;\n    &#125;\n    int l = 1, r = n;\n    int ret = 0;\n    while (l &lt;= r) &#123;\n        int mid = (l + r) >> 1;\n        //cout &lt;&lt; mid &lt;&lt; \" \"\n        rep(i, 1, n + 2) need[i] = 0;\n        if (check(mid)) &#123;\n            ret = mid;\n            r = mid - 1;\n        &#125; else &#123;\n            l = mid + 1;\n        &#125;\n    &#125;\n\n    cout &lt;&lt; ret &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n    int T;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\nI_PTSD\n\n\n\n\n\n\n\n\n沙比题，不想复盘了\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 1000005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nchar a[maxn];\nvoid solve() &#123;\n    int n;\n    cin &gt;&gt; n;\n    ll ret&#x3D;0;\n    rep(i,0,n)&#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    int lead&#x3D;0;\n    int mxpos;\n    red(i,n,0)&#123;\n        if(a[i]&#x3D;&#x3D;&#39;0&#39;)&#123;\n            lead++;\n        &#125;else&#123;\n            if(lead&gt;0)&#123;\n                lead--;\n                ret+&#x3D;(i+1);\n            &#125;else&#123;\n                lead++;\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;ret&lt;&lt;endl;\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：今天想出来D了吗\n","slug":"2021ccpc_guilin","date":"2021-11-23T16:03:00.000Z","categories_index":"SOLUTIONS","tags_index":"solutions,CCPC,ACM,思维,模拟,二分,图论,Dijkstra","author_index":"Maskros"},{"id":"790ed4c1d654821efb9fe604376d5483","title":"Educational Codeforces Round 117 (Div.2)","content":"Educational Codeforces Round 117 (Rated for Div. 2)A_Distance\n\n\n\n\n\n\n\n\n签到\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define sec second\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nvoid solve() &#123;\n    int x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    int xx &#x3D; -1, yy &#x3D; -1;\n    int tot &#x3D; x + y;\n    if (abs(tot) % 2 &#x3D;&#x3D; 1) &#123;\n        cout &lt;&lt; xx &lt;&lt; &quot; &quot; &lt;&lt; yy &lt;&lt; endl;\n        return;\n    &#125; else &#123;\n        if (abs(x) % 2 &#x3D;&#x3D; 0 &amp;&amp; abs(y) % 2 &#x3D;&#x3D; 0) &#123;\n            cout &lt;&lt; x &#x2F; 2 &lt;&lt; &quot; &quot; &lt;&lt; y &#x2F; 2 &lt;&lt; endl;\n            return;\n        &#125; else &#123;\n            tot &#x2F;&#x3D; 2;\n            if (x &gt; y)\n                cout &lt;&lt; tot &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; endl;\n            else\n                cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; tot &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nB_Special_Permutation\n\n\n\n\n\n\n\n\n贪心构造\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define sec second\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nint num[105];\nbool vis[105];\nvoid solve() &#123;\n    int n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;\n    memset(vis,0,sizeof(vis));\n    memset(num, 0, sizeof(num));\n    vis[a]&#x3D;1;\n    vis[b]&#x3D;1;\n    num[n&#x2F;2+1]&#x3D;b;\n    num[1]&#x3D;a;\n    int tmp&#x3D;1;\n    bool find;\n    rep(i,n&#x2F;2+2,n+1)&#123;\n        find&#x3D;false;\n        rep(j,tmp,b)&#123;\n            if(!vis[j])&#123;\n                vis[j]&#x3D;1;\n                num[i]&#x3D;j;\n                tmp&#x3D;j+1;\n                find&#x3D;1;\n                break;\n            &#125;\n        &#125;\n        if(!find) &#123;cout&lt;&lt;-1&lt;&lt;endl; return;&#125;\n    &#125;\n    tmp&#x3D;n;\n    rep(i,2,n&#x2F;2+1)&#123;\n        find&#x3D;false;\n        red(j,tmp+1,a)&#123;\n            if(!vis[j])&#123;\n                vis[j]&#x3D;1;\n                num[i]&#x3D;j;\n                tmp&#x3D;j-1;\n                find&#x3D;1;\n                break;\n            &#125;\n        &#125;\n        if(!find) &#123;cout&lt;&lt;-1&lt;&lt;endl; return;&#125;\n    &#125;\n    rep(i,1,n+1)&#123;\n        cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nC_Chat_Ban\n\n\n\n\n\n\n\n\n题意：\n输入k,x ; 你有2k-1条信息要发，信息的长度为1,2,3…k-1,k,k-1…1，在发出当前信息时，你已经发送的总长度必须小于x，问你最多能发多少条\n思路：\n二分答案即可\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define sec second\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x - 1; i &gt;&#x3D; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nll cal(ll begin, ll end)&#123;\n    ll ret;\n    if((begin+end)%2&#x3D;&#x3D;0)&#123;\n        ret&#x3D;(begin+end)&#x2F;2*(end-begin+1);\n    &#125;else&#123;\n        ret&#x3D;(end-begin+1)&#x2F;2*(begin+end);\n    &#125;\n    return ret;\n&#125;\nvoid solve() &#123;\n    ll k,x; cin&gt;&gt;k&gt;&gt;x;\n    ll ans&#x3D;0;\n    ll test&#x3D;cal(1,k);\n    if(test&#x3D;&#x3D;x)&#123;\n        cout&lt;&lt;k&lt;&lt;endl;\n        return;\n    &#125;eif(test&lt;x)&#123;\n        ans+&#x3D;k;\n        x-&#x3D;test;\n        test&#x3D;cal(1,k-1);\n        if(test&lt;&#x3D;x)&#123; cout&lt;&lt;2*k-1&lt;&lt;endl; return;&#125;\n        else&#123;\n            ll l&#x3D;1,r&#x3D;k;\n            ll mid;\n            ll tmp&#x3D;0;\n            while(l&lt;&#x3D;r)&#123;\n                mid&#x3D;(l+r)&gt;&gt;1;\n                test&#x3D;cal(mid,k-1);\n                if(test&#x3D;&#x3D;x)&#123;\n                    tmp&#x3D;k-mid;\n                    break;\n                &#125;eif(test&lt;x)&#123;\n                    tmp&#x3D;k-mid+1;\n                    r&#x3D;mid-1;\n                &#125;else&#123;\n                    l&#x3D;mid+1;\n                &#125;\n            &#125;\n            ans+&#x3D;tmp;\n            cout&lt;&lt;ans&lt;&lt;endl;\n        &#125;\n    &#125;else&#123;\n        ll l&#x3D;1,r&#x3D;k;\n        ll mid;\n        while(l&lt;&#x3D;r)&#123;\n            mid&#x3D;(l+r)&gt;&gt;1;\n            test&#x3D;cal(1,mid);\n            if(test&#x3D;&#x3D;x)&#123;\n                ans&#x3D;mid;\n                break;\n            &#125;eif(test&lt;x)&#123;\n                ans&#x3D;mid+1;\n                l&#x3D;mid+1;\n            &#125;else&#123;\n                r&#x3D;mid-1;\n            &#125;\n        &#125;\n        cout&lt;&lt;ans&lt;&lt;endl;\n    &#125;\n\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nD_X_Magic_Pair\n\n\n\n\n\n\n\n\n题意：\n给你 a, b, x，每次操作可以将a或b替换为 |a-b|, 询问能否将a或b进行任意次操作后替换为 x\n思路：\ngcd变种，每次判断一下 a%b 是否等于 x%b，即 (a-x)%b==0 ，如果相等即为YES，否则即为NO\n#include &lt;bits/stdc++.h>\n\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define sec second\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x - 1; i >= y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nll a, b, x;\nbool gcd(ll a, ll b)&#123;\n    if(a==x||b==x) return 1;\n    if(b==0) return 0;\n    if(a>x&amp;&amp;(a-x)%b==0) return 1;    \n    if(b>x&amp;&amp;(b-x)%a==0) return 1;\n    return gcd(b,a%b);\n&#125;\nvoid solve() &#123;\n    cin>>a>>b>>x;\n    if(x>a&amp;&amp;x>b)&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; return; &#125;\n    if(x==a||x==b)&#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; return;&#125;\n    ll tmpa=(a>b)?a:b;\n    ll tmpb=(b&lt;a)?b:a;\n    if(gcd(tmpa,tmpb)) puts(\"YES\");\n    else puts(\"NO\");\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\n\n总结仨签到很顺溜，最后一个题因为判断条件结果sb了，掉分\n","slug":"cf Edu 117","date":"2021-11-23T10:02:00.000Z","categories_index":"SOLUTIONS","tags_index":"solutions,ACM,思维,二分,codeforces,gcd","author_index":"Maskros"},{"id":"a2c6874fc71d3b8d32c3fc7e259ed58d","title":"进行一个毛概题库的爬","content":"进行一个毛概题库的爬\n\n\n\n\n\n\n\n\n前言：🐷b毛概题库要截止了，几个时间段的题库各自有截止日期😅，眼见着ddl就要到了可👴又不想去刷，所以萌生了借助python爬虫来进行偷懒的想法\n办事流程\n\n\n\n\n\n\n\n\n由于之前👴说过：“python狗都不用”，“用python的都沙比” 的名言，所以一开始是拒绝的，但是迫于现状，所以简单突击了几天，学到了一些知识，实战用到的也就只有不到 1/5\n需求：\n题库共计一百多道题目，每次测试15道题，5单选5多选5判断，提交做题结果之后方可获得所有题的正确答案，所以我们的思路就是从所有测试尝试的反馈页面中爬取题目题面和正确答案并持久化存储，over\n原先步骤(全自动)\n\n模拟登录\n由于这个b bb平台需要信息门户登录成功之后才能做那b题，所以需要模拟登陆之后才能请求到做题结果的页面，所以我们利用session会话对象在向登录页面发起请求后储存cookie，这样后面直接用session对象再对需求的页面进行get请求即可。\n\n自动做题\n自动开始新尝试并且提交\n\n开爬\nget到了页面之后，利用xpath进行数据解析，持久化存储即可\n\n\n\n\n\n\n\n\n\n\n\n想法很好，后来出现了一些问题，所以以下是最终流程：\n\n现实步骤(几乎全自动)\n\n\n\n\n\n\n\n\n\n2021/11/13 更新了 v1.1 版本：①优化了存储方式：按字典序排序即按题目的章节进行分类；②实现了 v1.0 没实现的自动做题功能\n\n模拟登录(x) 手动登录(√)\n按照原先的想法模拟登陆，返回的消息也是登陆成功，但是请求所需页面是还是被拦截了，需要重新登录，由于才疏学浅，一时不知道如何是好，干脆直接手动登录后，利用浏览器F12，找到登录的cookie，手动复制到源码中的 headers 内，直接用 requests 进行 post 和 get 的请求即可获得所需页面\n\n自动做题(√)\n\n开始新尝试：发现开始新尝试的按钮中对应的 &lt;a&gt;标签的 url 中的参数有个有趣的地方 new_attempt=1，直接访问即可以开始一次新的尝试，直接get请求即可\n提交新尝试：点击提交按钮后进行抓包，发现有一个post请求对应的 url : do/take/saveAttempt?saveSequence=1/... ，观察数据包中传输的数据发现有这样几个有趣的地方：data_submitted:true, save_and_submit:true；我们猜测这就是对服务器进行的提交结果请求。之后对比两次不同的提交所得的数据包发现，所需修改的参数为current_attempt_id 和 current_attempt_id_backup，二者是一样的，于是观察哪里有这个id，发现和做题页面中的&lt;div&gt;标签的类名有着惊人的一致🤠。直接对做题页面进行xpath解析，解析到div标签的类名传输进post请求的数据中，再发送post请求即可完成自动提交新尝试😪\n\n\n自动开爬 ！(√)\n\nget到所有尝试的页面，利用xpath解析到对应每次做题结果的 &lt;a&gt; 标签的href地址存到 list 中，拼接成完整的url\n\n对每个url 利用xpath解析到对应题目和答案的标签，根据题目类型分别存储，利用字典存储，题目名称为key，题目答案为value，为了防止存储重复题目，每次存储前先查询key是否存在，不存在再存入字典中，写入文件的同时计数器+1，方便统计爬取题目的个数\n\n冻手冻手\n\n\n\n\n🐴来import requests\nfrom lxml import etree\nimport os\nimport time\n\nif __name__ == '__main__':\n    # 创建文件夹\n    if not os.path.exists('./maogai/Round_2/'):\n        os.mkdir('./maogai/Round_2/')\n\n    session = requests.Session()\n    detail_url = 'https://wlkc.ouc.edu.cn'\n    # 使用现成的cookie直接绕过登录页面\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36',\n        'Cookie': 'JSESSIONID=AC1DEAF6D6037A4B310E53885942338D; LOGIN=3139303230303331303330; UM_distinctid=17bcb2f4e579ab-0e328a4e032f8-a7d193d-144000-17bcb2f4e58315; SCREEN_NAME=4f566b646b73396b79642f396274486b665a503656773d3d; session_id=4025A5EAD4245D545DCB1E8FD2D1EE4E; s_session_id=864B98DCC97327775D6853902DCD0138; web_client_cache_guid=871e5dc2-27ae-44b8-898f-a44d97e217f2',\n    &#125;\n\n    # 自动请求开始测试和提交 times_att为次数 每次请求间隔3s\n    times_att = 10\n    print('attempt started...')\n    for i in range(0,times_att):\n        # 请求测试\n        attempt_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/take/launch.jsp?course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;new_attempt=1&amp;content_id=_633969_1&amp;step='\n        atmp = session.get(url=attempt_url, headers=headers)\n        \n        # 拿到本次测试id\n        do_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/take/launch.jsp?course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;content_id=_633969_1&amp;step=null'\n        do = session.get(url=do_url, headers=headers)\n        tree_att = etree.HTML(do.text)\n        atnum = tree_att.xpath('//div[@class=\"takeQuestionDiv \"]/@id')[0]\n        print('attemptid = ' + str(atnum))\n\n        # 提交本次测试\n        submit_url = 'https://wlkc.ouc.edu.cn/webapps/assessment/do/take/saveAttempt?saveSequence=17&amp;takePageId=1636771783088&amp;course_assessment_id=_30131_1&amp;course_id=_13492_1&amp;content_id=_633969_1'\n        data = &#123;\n            'blackboard.platform.security.NonceUtil.nonce.ajax': 'c87385ed-48d7-4d9c-8c8c-a9f6cb45826d',\n            'data-submitted': 'true',\n            'course_assessment_id': '_30131_1',\n            'course_id': '_13492_1',\n            'content_id': '_633969_1',\n            'step': '',\n            'original_user_id': '_47406_1',\n            'save_and_submit': 'true',\n            'timer_completion': '',\n            'fileUploadType': '',\n            'toggle_state': 'qShow',\n            'current_question': '1',\n            'current_attempt_item_id': atnum,\n            'current_attempt_item_id_backup': atnum,\n            'method': 'notajax',\n            'saveonequestion': '',\n        &#125;\n        submit = session.post(url=submit_url, headers=headers, data=data)\n        print('post finished! times: '+ str(i+1))\n        time.sleep(3)\n    print('attempt over!')\n    print('--------------------')\n\n    # 总尝试页面\n    total_url = 'https://wlkc.ouc.edu.cn/webapps/gradebook/do/student/viewAttempts?method=list&amp;course_id=_13492_1&amp;outcome_definition_id=_95191_1&amp;outcome_id=_2069239_1'\n    page_text_tot = session.get(url=total_url, headers=headers)\n    tree_tot = etree.HTML(page_text_tot.text)\n    attempt_list = tree_tot.xpath('//div[@class=\" columnStep clearfix\"]//a/@href')\n\n    # 为了去重使用字典保存键值对\n    danxuan = &#123;&#125;\n    duoxuan = &#123;&#125;\n    panduan = &#123;&#125;\n    cnt1 = 0\n    cnt2 = 0\n    cnt3 = 0\n\n    fp1 = open('./maogai/Round_2/单选.txt', 'w', encoding='utf-8')\n    fp2 = open('./maogai/Round_2/多选.txt', 'w', encoding='utf-8')\n    fp3 = open('./maogai/Round_2/判断.txt', 'w', encoding='utf-8')\n\n    times = 0\n    print('download started...')\n    for attempt in attempt_list:\n        times = times + 1\n        new_url = detail_url + attempt\n        # print(new_url)\n        page_text = session.get(url=new_url, headers=headers)\n        tree = etree.HTML(page_text.text)\n        pro_list = tree.xpath('//ul[@id=\"content_listContainer\"]/li')\n\n        cnt = 0\n        # 每次尝试的内容进行爬取\n        for li in pro_list:\n            cnt = cnt + 1\n            pro_name = li.xpath('normalize-space(.//div[@class=\"vtbegenerated inlineVtbegenerated\"])')\n            pro_answer_1 = li.xpath('.//div[@class=\"vtbegenerated inlineVtbegenerated\"]//label/text()')\n            pro_answer_1 = str(pro_answer_1)\n            pro_answer_2 = li.xpath('normalize-space(.//span[@class=\"answerTextSpan\"])')\n\n            if cnt &lt;= 5:\n                if pro_name not in danxuan:\n                    cnt1 = cnt1 + 1\n                    danxuan[pro_name] = pro_answer_1\n                    # fp1.write(str(cnt1) + '. ' + pro_name+'\\n'+pro_answer_1+'\\n')\n            elif cnt &lt;= 10:\n                if pro_name not in duoxuan:\n                    cnt2 = cnt2 + 1\n                    duoxuan[pro_name] = pro_answer_1\n                    # fp2.write(str(cnt2) + '. ' + pro_name + '\\n' +pro_answer_1+'\\n')\n            else:\n                if pro_name not in panduan:\n                    cnt3 = cnt3 +1\n                    panduan[pro_name] = pro_answer_2\n                    # fp3.write(str(cnt3) + '. ' + pro_name + '\\n'+pro_answer_2+'\\n')\n        print('times: ' + str(times) + ' 单选: ' + str(cnt1) + ',多选：' + str(cnt2) + ',判断: ' + str(cnt3) )\n\n    # 将字典进行按key排序实现不同章节分类进行存储\n    num = 0\n    for pro in sorted(danxuan):\n        num = num + 1\n        fp1.write(str(num)+'. '+ pro + '\\n' + danxuan[pro] + '\\n')\n    num = 0\n    for pro in sorted(duoxuan):\n        num = num + 1\n        fp2.write(str(num)+'. ' + pro + '\\n' + duoxuan[pro] + '\\n')\n    num = 0\n    for pro in sorted(panduan):\n        num = num + 1\n        fp3.write(str(num)+'. ' + pro + '\\n' + panduan[pro] + '\\n')\n\n    fp1.close()\n    fp2.close()\n    fp3.close()\n    print('total: ' + str(cnt1+cnt2+cnt3) + ' problems have been downloaded.')\n\n\n\n\n\n\n\n\n\n\n\n\n一个小实战，效果还行😅，以后会想办法修改自动登录的问题，可以提点意见\ngithub项目地址 link  爬取的题库在文件夹里\nover大火\n","slug":"maogai_crawler","date":"2021-11-10T14:43:00.000Z","categories_index":"PROJECT","tags_index":"Crawler,python,requests","author_index":"Maskros"},{"id":"44a21ae344829c5e89324b4b716ab686","title":"python爬虫杂记","content":"python爬虫杂记Crawler in python\n\n\n\n\n\n\n\n\n\n又名 《为了偷懒爬毛概题库的突击学习》\n一些知识\n爬虫在使用场景中的分类：\n\n通用爬虫：抓取系统重要促成部分，抓取的是一整张页面数据\n\n聚焦爬虫：是建立在通用爬虫的基础上，抓取的是页面中特定的局部内容\n\n增量式爬虫：检测网站中数据更新的情况，只会抓取网站中最新更新出来的数据\n\n\n\n\n\nrobots.txt协议：君子协议，规定网站中哪些数据能爬哪些不能，约定俗成\n\nhttp &amp; https 协议：\n\n\n\n\n\n\n\n\n\nhttp协议：服务器和客户端进行数据交互的一种形式\nhttps协议：安全的超文本传输协议 证书秘钥加密\n\n常用请求头信息：\n\nUser-Agent：请求载体的身份标识\n\nConnection：请求完毕后，是断开连接还是保持连接\n\n\n\n\n\n常用响应头信息：\nContent-Type：服务器响应回客户端的数据类型\n\n\n\nrequests模块\n\n\n\n\n\n\n\n\nrequests: python原生的基于网络请求的模块，模拟浏览器发请求\n.text 字符串   .content 二进制   .json() 对象\n编码流程：\n\n指定url\n发起请求\n获取响应数据\n持久化存储\n\n0x00 requests 一血\n\n\n\n\n\n\n\n\nresponse.text\nimport requests\n# 1.指定url\nurl='xxxx/xxx/xxx.xxx'\n# 2.发起请求 get方法会返回一个响应对象\nresponse = requests.get(url=url)\n# 3.获取响应数据 .text返回的是字符串形式的响应数据\npage_text = response.text\nprint(page_text)\n# 4.持久化存储\nwith open('./xxx.html','w',encoding='utf-8') as fp:\n    fp.write(page_text)\nprint('over!')\n\n0x01 网页采集器\nUA检测 \nUA伪装\n\n\n\n\n\n\n\n\n\n\nrequests.get(url, params, headers)\nimport requests\n\n# UA：User-Agent 请求载体的身份标识\n# UA检测：门户网站的服务器会检测对应请求的载体身份标识，如果检测到的标识为基于某一款浏览器的，\n# 则说明是正常请求，反之服务端就可能拒绝这次请求\n\n# UA伪装：让爬虫对应的请求载体身份标识伪装成某一款浏览器\nif __name__ == '__main__':\n    # UA伪装：将对应的User-Agent封装到一个字典中\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n    &#125;\n    url = 'https://www.sogou.com/web'\n    # 处理url携带的参数：封装到字典中\n    kw = input('enter a word:')\n    param = &#123;\n        'query': kw\n    &#125;\n    # 对指定url发起的请求对应url是携带参数的，并且请求过程中处理了参数\n    response = requests.get(url=url, params=param, headers=headers)\n\n    page_text = response.text\n    fileName = './requests_test/test2/'+kw+'.html'\n    with open(fileName, 'w', encoding='utf-8') as fp:\n        fp.write(page_text)\n    print(fileName, ' is saved')\n\n\n0x02 百度翻译\npost请求 (携带了参数)  \najax\n响应数据是一组json数据\n\n\n\n\n\n\n\n\n\n\nrequests.post(url, data, json, headers...)\nresponse.json()\nimport requests\nimport json\nif __name__ == '__main__':\n    # 1.指定url\n    post_url = 'https://fanyi.baidu.com/sug'\n    # 2.进行UA伪装\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n    &#125;\n    # 3.post请求参数处理(同get请求一致)\n    word = input('enter a word')\n    data = &#123;\n        'kw': word\n    &#125;\n    # 4.请求发送\n    response = requests.post(url=post_url, data=data, headers=headers)\n    # 5.获取响应数据:json()方法返回的是obj(如果确认响应数据是json类型才能使用)\n    dic_obj=response.json()\n    print(dic_obj)\n    # 6.持久化存储\n    fileName = './requests_test/test3/'+word+'.json'\n    fp = open(fileName,'w',encoding='utf-8')\n    # 由于中文不能用ascii编码，所以令ensure_ascii=False\n    json.dump(dic_obj,fp=fp,ensure_ascii=False) \n    print('over!')\n\n\n0x03 豆瓣电影\n\n\n\n\n\n\n\n\nrequest.get\nimport requests\nimport json\nif __name__ == '__main__':\n    url = 'https://movie.douban.com/j/chart/top_list'\n    param = &#123;\n        'type': '24',    \n        'interval_id': '100:90',\n        'action': '',\n        'start': '40',  # 从库中的第几部电影去取\n        'limit': '20',  # 一次从库中取出的个数\n    &#125;\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n    &#125;\n    response = requests.get(url=url, params=param, headers=headers) \n    list_data = response.json()\n    # print(list_data)\n    fp = open('./requests_test/test4/douban.json', 'w', encoding='utf-8')\n    json.dump(list_data, fp=fp, ensure_ascii=False)\n\n    print('over!')\n\n\n0x04 综合案例-数据提取import requests\nimport json\n\nif __name__ == '__main__':\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n    &#125;\n    id_list = []  # 存储企业id\n    all_data_list = []  # 存储所有的企业详情数据\n\n    # 批量获取不同企业的id值\n    url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsList'\n    # 参数的封装\n    for page in range(1,6):\n        page=str(page)\n        data = &#123;\n            'on': 'true',\n            'page': page,\n            'pagesize': '15',\n            'productName': '',\n            'conditionType': '1',\n            'applyname': '',\n            'applysn': '',\n        &#125;\n        json_ids = requests.post(url=url, headers=headers, data=data).json()\n        for dic in json_ids['list']:\n            id_list.append(dic['ID'])\n\n    # 获取企业详细数据\n    post_url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById'\n    for id in id_list:\n        data = &#123;\n            'id': id\n        &#125;\n        detail_json = requests.post(\n            url=post_url, headers=headers, data=data).json()\n        print(detail1_json, '--------ending--------')\n        all_data_list.append(detail_json)\n    # 持久化存储all_data_list\n    fp = open('./requests_test/test5/allData.json', 'w', encoding='utf-8')\n    json.dump(all_data_list, fp=fp, ensure_ascii=False)\n    print('over!')\n\n\n数据解析\n\n\n\n\n\n\n\n\n聚焦爬虫：爬取页面中指定的页面内容\n编码流程：\n\n指定url\n发起请求\n获取响应数据\n数据解析\n持久化存储\n\n数据解析分类：正则，bs4，xpath\n数据解析原理概述：\n\n\n\n\n\n\n\n\n\n解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储\n\n进行指定标签的定位\n标签或者标签对应的属性中存储的数据值进行提取 (解析)\n\n0x00 图片\n\n\n\n\n\n\n\n\n.content 返回二进制\nimport requests\n\nif __name__ == '__main__':\n    # 如何爬取图片数据\n    url = 'https://i2.hdslb.com/bfs/archive/237001f0163eb48c1745a906c5b480f449183d66.jpg@672w_378h_1c_100q.webp'\n    # content 返回的是二进制形式图片数据\n    img_data = requests.get(url=url).content\n\n    with open('./data_parse_test/test1/dsm.jpg','wb') as fp:\n        fp.write(img_data)    \n\n\n0x01 正则解析\n\n\n\n\n\n\n\n\n需要导入re模块\n常用正则表达式\n\nex:\n&lt;div class=\"test\">\n    &lt;a href=\"/dsadas/sdada\" target=\"_blank\">\n    &lt;img src=\"//sdadasd/dsadas/dasdas\" alt=\"sdada\">\n    &lt;/a>\n&lt;/div>\n\nex='&lt;div class=\"test\">.*?&lt;img src=\"(.*?)\" alt .*?&lt;/div>'\n\n练习：图片分页爬取\nimport requests\nimport re\nimport os\n\n# 需求：爬取所有图片\nif __name__ == '__main__':\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n    &#125;\n    #创建文件夹，保存所有图片\n    if not os.path.exists('./data_parse_test/test1'):\n        os.mkdir('./data_parse_test/test1/')\n    #设置一个通用url模板\n    url = 'https://www.qiushibaike.com/pic/page/%d/?s=5184961'\n    for pageNum in range(1,36):\n        #对应页码的url\n        new_url = format(url%pageNum)\n        # 使用通用爬虫对url对应的一整张页面进行爬取\n        page_text = requests.get(url=url, headers=headers).text\n\n        # 使用聚焦爬虫将页面中所有漫画进行解析/提取\n        ex = '&lt;div class=\"thumb\">.*?&lt;img src=\"(.*?)\" alt.*?&lt;/div> '\n        img_src_list = re.findall(ex, page_text, re.S)\n        # print(img_src_list)\n        for src in img_src_list:\n            #拼接出一个完整的图片url\n            src='https:'+src\n            #请求到了图片的二进制数据\n            img_data=requests.get(url=src,headers=headers).content\n            #生成图片名称\n            img_name=src.split('/')[-1]\n            #图片存储的路径\n            imgPath='./data_parse_test/test1/'+img_name\n            with open(imgPath,'wb') as fp:\n                fp.write(img_data)\n                print(img_name,'下载成功！')\n\n\n0x02 bs4解析\n\n\n\n\n\n\n\n\n所需模块：bs4 lxml\n数据解析的原理：\n\n标签定位\n提取标签、标签属性中存储的数据值\n\nbs4数据解析的原理：\n\n实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中\n通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取\n\n如何实例化Beautiful对象：\n\n\n\n\n\n\n\n\n\nfrom bs4 import BeautifulSoup\n\n对象的实例化：将本地/互联网上获取的页面源码加载到该对象中\nsoup=BeautifulSoap(page_text.content,&#39;lxml&#39;)\n\n\n提供的用于数据解析的方法和属性：\n\nsoup.tagName 对应html标签 返回的是html中第一次出现的tagName标签\n\nsoup.find() :\n\nsoup.find(&#39;tagName&#39;) 同 soup.tagName\n属性定位：soup.find(&#39;tagName&#39;,class_=&#39;xxx&#39;) (class要带下划线)\nsoup.find_all(&#39;tagName&#39;) 返回所有的标签(列表)\n\n\nsoup.select()\n\nsoup.select(&#39;某种选择器(id,class,标签...)&#39;)，返回的是一个列表\n\n\n\n\n\n\n\n\n\n#id, tag, .class\n\n层级选择器：\n\nsoup.select(&#39;.class1 &gt; ul &gt; li &gt; a&#39;)[2]  表示 class1 下的 ul 标签下的 li 标签中的第二个 a 标签。 &gt; 表示一个层级关系\nsoup.select(&#39;.class1 &gt; ul a&#39;)[2] 表示同上，空格表示的是多个层级关系\n\n\n\n\n获取标签之间的文本数据\n\nsoup.a.text/string/get_text()\n.text/.get_text() 可以获得某一个标签中所有的文本内容\n.string 只可以获取改标签下面直系的文本内容\n\n\n\n\n获取标签中属性值\n\nsoup.a[&#39;href&#39;]\n\n\n\n练习：小说章节名和内容爬取\nimport requests\nimport lxml\nfrom bs4 import BeautifulSoup\n\n# 需求：爬取小说的所有章节标题和内容\nif __name__ == '__main__':\n    if not os.path.exists('./data_parse_test/test2'):\n        os.mkdir('./data_parse_test/test2/')\n    headers = &#123;\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n    &#125;\n    # 对首页的页面进行爬取\n    url = 'http://www.banzhu22.org/5_5853/'\n    page_text = requests.get(url=url, headers=headers)\n\n    # 在首页中解析出章节的标题和详情页的url\n    # 1. 实例化BeautifulSoup对象，将网页源码加载到对象中\n    soup = BeautifulSoup(page_text.content, 'lxml')\n    dd_list = soup.select('.box_con > #list dd')[9:]\n\n    fp = open('./data_parse_test/test2/49gifts.txt', 'w', encoding='utf-8')\n    for dd in dd_list:\n        title = dd.a.string\n        detail_url = 'http://www.banzhu22.org' + dd.a['href']\n        # 对详情页发起请求，解析出章节内容\n        detail_page_text = requests.get(url=detail_url, headers=headers)\n        # 解析出详情页中相关章节的内容\n        detail_soup = BeautifulSoup(detail_page_text.content, 'lxml')\n        div_tag = detail_soup.find('div', id='content')\n        # 解析到章内容\n        content = div_tag.text\n        fp.write(title+'\\n'+content+'\\n')\n        print(title+'downloaded successfully!')\n\n    print('over!')\n\n\n0x03 xpath解析\n\n\n\n\n\n\n\n\n是最常用且最便捷高效的爬取方式，通用性最强\n所需模块：lxml\nxpath解析原理：\n\n实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中\n调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获\n\n如何实例化etree对象：\n\n\n\n\n\n\n\n\n\nfrom lxml import etree\n\n本地源码：etree.parse(filePath)\n\n互联网源码：etree.HTML(&#39;page_text&#39;)\n\nxpath(&#39;xpath表达式&#39;)\n\n\nxpath表达式：\n\n\n\n\n\n\n\n\n\n各表达式可以用 | 连接\n\n/：表示的是一个层级，从根节点开始定位\n\n开头./：定位了层级后，当前层级下的层级\n\n//：表示的是多个层级，可以从任意位置开始定位\n\n属性定位：//div[@class=&quot;xxx&quot;] 即 tag[@attrName=&quot;attrValue&quot;]\n\n索引定位：//div[@class=&quot;xxx&quot;]/p[3] 索引是从1开始的\n\n取文本：\n\n/text() 标签下直系的文本内容\n//text() 标签下所有的文本内容\n\n\n取属性：/@attrName\n\n通用处理中文乱码的解决方案\nname = name.encode('iso-8859-1').decode('gbk')\n\n练习略\n验证码识别反爬机制：验证码\n识别验证码的操作：\n\n第三方自动识别：云打码 \n\nto be added….\n模拟登陆需求：对校园网进行登陆 (无验证码)\n\n点击登陆按钮后会发起一个POST请求，POST请求中会携带登录信息(username,pwd)\nprint(response.status_code) 打印响应状态码，如果打印200则证明模拟登陆成功\n\n需求：爬取当前用户的相关信息\nhttp/https协议特性：无状态\n没有请求到对应页面数据的原因：发起的第二次基于页面的请求时，服务器端不知道此次请求是基于登录状态下的请求\ncookie：用来让服务端记录客户端的相关状态\n\ncookie值的来源是哪里：模拟登陆post请求后，有服务器端创建\nsession会话对象：\n可以进行请求的发送\n如果请求过程中产生了cookie，则cookie会被自动存储/携带在该session对象中\n\n\n\n步骤：\n\n创建一个session对象： session = requests.Session()\n使用session对象进行模拟登录post请求的发送 (cookie就会被存储在session中)\nsession对象再对登录后页面对应的get请求进行发送 (携带了cookie)\n\nselenium工具\n\n\n\n\n\n\n\n\n解决requests无法执行javaScript代码的问题\n\n用于web应用程序自动化测试的工具，直接运行在浏览器当中，支持chrome、firefox等主流浏览器。可以通过代码控制与页面上元素进行交互（点击、输入等），也可以获取指定元素的内容\n\n缺点： 效率低，速度慢\n\n\n\n\n\n\n\n\n\n\n\nto be added … \n","slug":"Crawler","date":"2021-11-10T09:03:30.000Z","categories_index":"NOTE","tags_index":"Crawler,note,python","author_index":"Maskros"},{"id":"e394fa1264795d63defb812bbe4eb503","title":"2021CCPC女生专场vp","content":"2021CCPC女生专场\n\n\n\n\n\n\n\n\n“假如我是女生”\nA_公交线路\n\n\n\n\n\n\n\n\n水题\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nvoid solve() &#123;\n    int n,x,y; cin>>n>>x>>y;\n    int k[20];\n    rep(i,1,n+1) cin>>k[i];\n    int m; cin>>m;\n    int p[20];\n    rep(i,1,m+1) cin>>p[i];\n    int lpos=x-1,rpos=x+1;\n    rep(i,1,m+1)&#123;\n        if(k[lpos]!=p[i])&#123;\n            if(y&lt;x) &#123;cout&lt;&lt;\"Wrong\"&lt;&lt;endl; return;&#125;\n            else &#123;cout&lt;&lt;\"Right\"&lt;&lt;endl; return;&#125;\n        &#125;\n        if(k[rpos]!=p[i])&#123;\n            if(x&lt;y) &#123;cout&lt;&lt;\"Wrong\"&lt;&lt;endl; return;&#125;\n            else &#123;cout&lt;&lt;\"Right\"&lt;&lt;endl; return;&#125;\n        &#125;\n        lpos--; rpos++;\n    &#125;\n    cout&lt;&lt;\"Unsure\"&lt;&lt;endl;\n\n&#125;\nint main() &#123;\n    int T = 1;\n    // cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\nD_修建道路\n\n\n\n\n\n\n\n\n沙比题，两两取最大值即可，脂环王写了一发线段树优化递归我不是很认可\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 200005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nint a[maxn];\nvoid solve() &#123;\n    int n;\n    cin >> n;\n    ll ans = 0;\n    rep(i, 0, n) &#123;\n        cin >> a[i];\n        if(i>0) ans+=max(a[i],a[i-1]);\n    &#125;\n    cout&lt;&lt;ans&lt;&lt;endl;\n&#125;\nint main() &#123;\n    int T = 1;\n    // cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nG_3G网络\n\n\n\n\n\n\n\n\n输出1/n即可 我搞错了double 结果wa在精度上了 最后手写了个除法\n结果发现 printf(“%.16lf”,ans) 即可，少写个小数点😅\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nvoid solve() &#123;\n    int n; cin>>n;\n    int x,y;\n    rep(i,0,n)&#123;\n        cin>>x>>y;\n    &#125;\n    int ans[15];  \n    rep(i,0,12)&#123;\n        if(i==0)&#123;\n            if(n==1) &#123;ans[0]=1; tmp=0;&#125;\n            else &#123;ans[0]=0; tmp*=10;&#125;\n        &#125;else&#123;\n            ans[i]=tmp/n;\n            tmp=tmp%n;\n            tmp*=10;\n        &#125;\n    &#125;\n    cout&lt;&lt;ans[0]&lt;&lt;\".\";\n    rep(i,1,12)&#123;\n        cout&lt;&lt;ans[i];\n    &#125;\n\n&#125;\nint main() &#123;\n    int T = 1;\n    // cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n// ans=1.0/n\n// printf(\"%.16lf\",ans);\n\nI_驾驶卡丁车\n\n\n\n\n\n\n\n\n楞模拟就行，八个方向 dis[8][2] 直接做掉啊做掉\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nchar mp[55][55];\nint dis[8][2] = &#123;\n    &#123;-1, 0&#125;, &#123;-1, -1&#125;, &#123;0, -1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;0, 1&#125;, &#123;-1, 1&#125;&#125;;\nint n, m, x, y, v, face;\nbool crsh=0;\nbool check(int x, int y) &#123;\n    if (x &lt;= 0 || x > n || y &lt;= 0 || y > m)\n        return false;\n    if (mp[x][y] == '#')\n        return false;\n    else\n        return true;\n&#125;\nvoid go()&#123;\n    rep(j, 0, v) &#123;\n        if (dis[face][0] != 0 &amp;&amp; dis[face][1] != 0) &#123;\n            if (!check(x + dis[face][0], y) &amp;&amp; !check(x, y + dis[face][1])) &#123;\n                crsh = true;\n                v = 0;\n                break;\n            &#125;\n        &#125;\n        if (check(x + dis[face][0], y + dis[face][1])) &#123;\n            x += dis[face][0];\n            y += dis[face][1];\n        &#125; else &#123;\n            crsh = true;\n            v = 0;\n            break;\n        &#125;\n    &#125;\n&#125;\nvoid solve() &#123;\n    cin >> n >> m;\n    v=0, face=0;\n    rep(i, 1, n+1) &#123;\n        rep(j, 1, m+1) &#123;\n            cin >> mp[i][j];\n            if (mp[i][j] == '*') &#123;\n                x = i, y = j;\n            &#125;\n        &#125;\n    &#125;\n    int opcnt;\n    cin >> opcnt;\n    char op;\n    crsh = false;\n    rep(i, 0, opcnt) &#123;\n        cin >> op;\n        crsh = false;\n        if (op == 'L') &#123;\n            face++;\n            if (face > 7) &#123;\n                face = 0;\n            &#125;\n            go();\n        &#125;\n        eif(op == 'R') &#123;\n            face--;\n            if (face &lt; 0) &#123;\n                face = 7;\n            &#125;\n            go();\n        &#125;\n        eif(op == 'U') &#123;\n            v++;\n            go();\n        &#125;\n        eif(op == 'D') &#123;\n            v = max(v - 1, 0);\n            go();\n        &#125;\n        if (crsh)\n            cout &lt;&lt; \"Crash! \";\n        cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n    int T = 1;\n    // cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\nK_音乐游戏\n\n\n\n\n\n\n\n\n沙比题\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nvoid solve() &#123;\n    int n; cin&gt;&gt;n;\n    string s;\n    int cnt&#x3D;0;\n    rep(i,0,n+1)&#123;\n        getline(cin,s);\n        rep(j,0,s.length())&#123;\n            if (s[j] &#x3D;&#x3D; &#39;-&#39;)\n                cnt++;\n        &#125;\n    &#125;\n    cout&lt;&lt;cnt;\n\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    &#x2F;&#x2F; cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：再次化身签到皇帝，还在想B题的字符串，请把“今天想出来B了吗”打在评论区😘\n","slug":"2021ccpc_girl","date":"2021-11-08T14:25:00.000Z","categories_index":"SOLUTIONS","tags_index":"solutions,CCPC,ACM,思维,模拟","author_index":"Maskros"},{"id":"f6d54634de34a34bc60807e4bd91093d","title":"Codeforces Round 752 (Div.2)","content":"Codeforces Round #752 (Div.2)A_Era\n\n\n\n\n\n\n\n\n水题\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nvoid solve() &#123;\n    int n;\n    cin >> n;\n    ll ans = 0;\n    int t;\n    int pos = 1;\n    rep(i, 1, n + 1) &#123;\n        cin >> t;\n        if (t > pos) &#123;\n            ans += t - pos;\n            pos += t - pos;\n        &#125;\n        pos++;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\nB_XOR_Specia_LIS_t\n\n\n\n\n\n\n\n\n题意：\n沙比题，如果序列所分成的若干子序列中，最长的任意递增序列(不需要连续)的长度相异或，可以为0则输出 yes 否则输出 no\n思路：\n没说咋分，就一个一个分，所以就是 1^1^1^… ，根据序列长度的奇偶性判断一下即可，偶数一定yes，奇数就判断是不是单增序列，不是的话一定yes，反之no\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 100005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nint a[maxn];\nvoid solve() &#123;\n    int n; cin>>n;\n    int tmp;\n    rep(i,0,n)&#123;\n        cin >> a[i];\n    &#125;\n    bool is=false;\n    if(n&amp;1)&#123;\n        rep(i,1,n)&#123;\n            if(a[i]&lt;=a[i-1])&#123;\n                cout&lt;&lt;\"YES\"&lt;&lt;endl;\n                is=true;\n                break;\n            &#125;\n        &#125;\n        if(!is) cout&lt;&lt;\"NO\"&lt;&lt;endl;\n    &#125;else&#123;\n        cout&lt;&lt;\"YES\"&lt;&lt;endl;\n    &#125;\n\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\nC_Di_visible_Confusion\n\n\n\n\n\n\n\n\n题意：\n一个序列，可以对a[i]进行删除操作的前提是 a[i]%(i+1)!=0，问这个序列能不能被删干净\n思路：\n暴力即可\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 100005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nint a[maxn];\nvoid solve() &#123;\n    int n; cin>>n;\n    rep(i,1,n+1)&#123;\n        cin>>a[i];\n    &#125;\n    bool flag=false;\n    rep(i,1,n+1)&#123;\n        flag=false;\n        rep(j,2,i+2)&#123;\n            if(a[i]%j!=0)&#123;\n                flag=true;\n                break;\n            &#125;\n        &#125;\n        if(!flag)&#123;\n            cout&lt;&lt;\"NO\"&lt;&lt;endl;\n            return;\n        &#125;\n    &#125;\n    cout&lt;&lt;\"YES\"&lt;&lt;endl;\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nD_Vupsen_Pupsen_and_0\n\n\n\n\n\n\n\n\n题意：\n输入x,y 两个偶数，找出 n，使得 n%x=y%n\n思路：\n分类讨论即可：\n\nx&gt;y 时，n=x+y\nx&lt;y 时，n=y-(y%x)/2\n考虑特例\n\n思考不出来的时候画数轴可以给你灵感\n#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 100005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nvoid solve() &#123;\n    ll x, y;\n    cin >> x >> y;\n    if (x == y) &#123;\n        cout &lt;&lt; x &lt;&lt; endl;\n        return;\n    &#125;\n    if (x > y) &#123;\n        cout &lt;&lt; x + y &lt;&lt; endl;\n    &#125; else &#123;\n        if (y % x == 0) &#123;\n            cout &lt;&lt; x &lt;&lt; endl;\n        &#125; else &#123;\n            cout &lt;&lt; y - (y % x) / 2 &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n","slug":"cf 752","date":"2021-10-31T14:50:00.000Z","categories_index":"SOLUTIONS","tags_index":"solutions,ACM,思维,codeforces","author_index":"Maskros"},{"id":"4370eb9e88a3fbe0e8eca2138219f214","title":"Educational Codeforces Round 116 (Div.2)","content":"Educational Codeforces Round 116 (Rated for Div. 2)A_AB_Balance\n\n\n\n\n\n\n\n\n题意：\n由ab构成的串，做最少操作使ab和ba出现的次数相同\n思路：\n如果出现次数不同，最多差1，修改首位即可\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nvoid solve() &#123;\n    string s;\n    cin &gt;&gt; s;\n    int l &#x3D; s.length();\n    int ab &#x3D; 0, ba &#x3D; 0;\n    rep(i, 0, l) &#123;\n        if (s[i] &#x3D;&#x3D; &#39;a&#39;) &#123;\n            if (s[i + 1] &#x3D;&#x3D; &#39;b&#39;)\n                ab++;\n        &#125;\n        if (s[i] &#x3D;&#x3D; &#39;b&#39;) &#123;\n            if (s[i + 1] &#x3D;&#x3D; &#39;a&#39;)\n                ba++;\n        &#125;\n    &#125;\n    if (ab &#x3D;&#x3D; ba)\n        cout &lt;&lt; s &lt;&lt; endl;\n    else &#123;\n        if (ab &gt; ba) &#123;\n            if (s[0] &#x3D;&#x3D; &#39;a&#39;)\n                s[0] &#x3D; &#39;b&#39;;\n        &#125; else &#123;\n            if (s[0] &#x3D;&#x3D; &#39;b&#39;)\n                s[0] &#x3D; &#39;a&#39;;\n        &#125;\n        cout &lt;&lt; s &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nB_Update_Files\n\n\n\n\n\n\n\n\n水题\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nll quickpow(ll a, ll b) &#123;\n    ll ans &#x3D; 1;\n    ll res &#x3D; a;\n    while (b) &#123;\n        if (b &amp; 1)\n            ans &#x3D; ans * res;\n        b &gt;&gt;&#x3D; 1;\n        res &#x3D; res * res;\n    &#125;\n    return ans;\n&#125;\nvoid solve() &#123;\n    ll n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    if (n &#x3D;&#x3D; 1)\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    else &#123;\n        int need &#x3D; 0;\n        ll tmp &#x3D; 0;\n        rep(i, 0, 65) &#123;\n            tmp &#x3D; quickpow(2, i);\n            if (tmp &gt;&#x3D; k || tmp &gt;&#x3D; n) &#123;\n                need &#x3D; i;\n                break;\n            &#125;\n        &#125;\n        if (tmp &gt;&#x3D; n)\n            cout &lt;&lt; need &lt;&lt; endl;\n        else &#123;\n            ll times &#x3D; need;\n            if ((n - tmp) % k &gt; 0) &#123;\n                times +&#x3D; (n - tmp) &#x2F; k + 1;\n            &#125; else &#123;\n                times +&#x3D; (n - tmp) &#x2F; k;\n            &#125;\n            cout &lt;&lt; times &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nC_Banknotes\n\n\n\n\n\n\n\n\n题意：\n给定n,k, n代表纸币种类，k代表最多可用纸币数量，接下来给出a[0…n-1]， 顺序由小到大，表示每张纸币的面值为 10^a[i]，求不能表示出的金额的最小值\n思路：\n贪心，按10进制从低位到高位取，能取够低位就是 a[i+1]-1 的形式，即为 x999… , 如果a[i]取不到a[i+1] 或者 没有更大面值的钞票，答案即为 a[i] * 剩余张数 + a[i]-1 , 能取到就接着找a[i+1]。\n#include &lt;bits&#x2F;stdc++.h&gt;\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar(&#39;\\n&#39;)\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x; i &gt; y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; &quot; &quot;;\ntypedef long long ll;\n#define pll pair&lt;ll, ll&gt;\nusing namespace std;\nll a[20];\nll quickpow(ll a, ll b) &#123;\n    ll ans &#x3D; 1;\n    ll res &#x3D; a;\n    while (b) &#123;\n        if (b &amp; 1)\n            ans &#x3D; ans * res;\n        b &gt;&gt;&#x3D; 1;\n        res &#x3D; res * res;\n    &#125;\n    return ans;\n&#125;\nvoid solve() &#123;\n    ll n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    rep(i, 0, n) &#123;\n        cin &gt;&gt; a[i];\n        a[i] &#x3D; quickpow(10, a[i]);\n    &#125;\n    a[n] &#x3D; 0;\n    ll ans &#x3D; 0;\n    ll tmp &#x3D; 0;\n    rep(i, 0, n) &#123;\n        if (i &#x3D;&#x3D; 0) &#123;\n            if (n &#x3D;&#x3D; 1) &#123;\n                cout &lt;&lt; k + 1 &lt;&lt; endl;\n                return;\n            &#125;\n            if (a[i] * k + 1 &lt; a[i + 1]) &#123;\n                cout &lt;&lt; a[i] * k + 1 &lt;&lt; endl;\n                return;\n            &#125; else &#123;\n                tmp +&#x3D; a[i + 1] &#x2F; a[i] - 2;\n                ans &#x3D; a[i + 1] - 1;\n            &#125;\n        &#125; else &#123;\n            if ((k - tmp) * a[i] &lt; a[i + 1]) &#123;\n                ans &#x3D; (k - tmp) * a[i] + a[i] - 1;\n                cout &lt;&lt; ans &lt;&lt; endl;\n                return;\n            &#125;\n            eif(a[i + 1] &#x3D;&#x3D; 0) &#123;\n                ans &#x3D; (k - tmp) * a[i] + a[i] - 1;\n                cout &lt;&lt; ans &lt;&lt; endl;\n                return;\n            &#125;\n            else &#123;\n                tmp +&#x3D; a[i + 1] &#x2F; a[i] - 1;\n                ans &#x3D; a[i] - 1;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main() &#123;\n    int T &#x3D; 1;\n    cin &gt;&gt; T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\n总结我真是个沙比，打的时候因为有个判断条件写错了一直wa2，比赛完十分钟就过了，纯掉分飞舞 😅\n","slug":"cf Edu 116","date":"2021-10-30T06:02:00.000Z","categories_index":"SOLUTIONS","tags_index":"solutions,ACM,思维,codeforces","author_index":"Maskros"},{"id":"a34fa7abdbec32f8c07db7bb49b7ce14","title":"Codeforces Round 750 (Div.2)","content":"Codeforces Round #750 (Div.2)A_Luntik_and_Concerts#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nvoid solve() &#123;\n    ll a, b, c;\n    cin >> a >> b >> c;\n    int mn = min(a, b);\n    if ((mn + c) &amp; 1) &#123;\n        mn--;\n        a -= mn;\n        b -= mn;\n    &#125; else &#123;\n        a -= mn;\n        b -= mn;\n    &#125;\n    b &amp;= 1;\n    if (b) &#123;\n        if (a >= 2)\n            a -= 2;\n        cout &lt;&lt; (a &amp; 1) &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; (a &amp; 1) &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\nB_Luntik_and_Subsequences#include &lt;bits/stdc++.h>\n\n#define gcd(a, b) __gcd(a, b)\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 400005\n#define co(x) cout &lt;&lt; x &lt;&lt; \" \";\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nll quickpow(int a, int b)&#123; \n    ll ans = 1;\n    ll res = a;\n    while (b)\n    &#123;\n        if (b &amp; 1)\n            ans = ans * res;\n        b >>= 1;\n        res = res * res;\n    &#125;\n    return ans;\n&#125;\nvoid solve()\n&#123;\n    int n; cin>>n;\n    int a[65];\n    rep(i,0,n) cin>>a[i];\n    sort(a,a+n);\n    ll cnt=0;\n    if(a[0]>1) cout&lt;&lt;0&lt;&lt;endl;\n    else&#123;\n        ll cnt0=0,cnt1=0;\n        rep(i,0,n)&#123;\n            if(a[i]==0) cnt0++;\n            eif(a[i]==1) cnt1++;\n            else break;\n        &#125;\n        cnt=cnt1*quickpow(2,cnt0);\n        cout&lt;&lt;cnt&lt;&lt;endl;\n    &#125;\n&#125;\nint main()\n&#123;\n    IOS;\n    int T = 1;\n    cin >> T;\n    while (T--)\n    &#123;\n        solve();\n    &#125;\n&#125;\n\nC_Grandma_Capa_Knits_a_Scarf\n\n\n\n\n\n\n\n\n题意：\n待补\n思路：\n待补\n#include &lt;iostream>\n#include &lt;algorithm>\n#include &lt;cstring>\n#include &lt;vector>\n#define ll long long\n#define pb push_back\nusing namespace std;\nint sum1[100005], sum2[100005];\nint p[1000005];\nint main() &#123;\n\tint T;\n\tcin >> T;\n\t//T = 1;\n\twhile(T--) &#123;\n\t\tint n;\n\t\tcin >> n;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint ans = 0x3f3f3f3f;\n\t\tfor(int i = 0; i &lt; 26; i++) &#123;\n\t\t\tstring s1 = \"\";\n\t\t\tsum1[0] = sum2[n + 1] = sum2[n] = 0;\n\t\t\tchar now = 'a' + i;\n\t\t\tfor(int j = 0; j &lt; s.size(); j++) &#123;\n\t\t\t\tif(s[j] == now) &#123;\n\t\t\t\t\tif(j == 0) sum1[j] = 1;\n\t\t\t\t\telse sum1[j] = sum1[j - 1] + 1;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tif(j == 0) sum1[j] = 0;\n\t\t\t\t\telse sum1[j] = sum1[j - 1];\n\t\t\t\t\ts1 += s[j];\n\t\t\t\t\tp[s1.size() - 1] = j;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\tfor(int j = s.size() - 1; j >= 0; j--) &#123;\n\t\t\t\tsum2[j] = sum2[j + 1];\n\t\t\t\tif(s[j] == now) sum2[j]++;\n\t\t\t&#125;\n\t\t\tstring s2 = s1;\n\t\t\treverse(s2.begin(), s2.end());\n\t\t\t//cout &lt;&lt; \"fuck\" &lt;&lt; endl;\n\t\t\tif(s1 == s2) &#123;\n\t\t\t\t//cout &lt;&lt; (char)('a' + i) &lt;&lt; endl;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int k = 0; k &lt; s1.size() / 2 + (s1.size() &amp; 1 ? 1 : 0); k++) &#123;\n\t\t\t\t\t//if(i == 0) cout &lt;&lt; k &lt;&lt; \" \" &lt;&lt; endl;\n\t\t\t\t\tint pos1 = p[k], pos2 = p[s1.size() - 1 - k];\n\t\t\t\t\t//if(i + 'a' == 'r') cout &lt;&lt; k &lt;&lt; \" \" &lt;&lt; del &lt;&lt; endl;\n\t\t\t\t\tif(k == 0) del += abs(sum1[pos1] - sum2[pos2]);\n\t\t\t\t\telse del += abs((sum1[pos1] - sum1[p[k - 1]]) - (sum2[pos2] - sum2[p[s1.size() - k]]));\n\t\t\t\t&#125;\n\t\t\t\tans = min(ans, del);\n\t\t\t&#125;\n\t\t&#125;\n\t\tif(ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl;\n\t\telse cout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n// 1\n// 8\n// rprarlap\n\nD_Vupsen_Pupsen_and_0\n\n\n\n\n\n\n\n\n题意：\n已知非零数组a[i]，求非零数组b[i]，使得a[i]*b[i] 的和为0\n思路：\n个数为偶数两两相消，个数为奇数的话，选取尾部三个数，判断两个相加不为零的数出来，当作一个数与剩下的一个数两两相消即可。\n坑点：三个数时合并的两个数相加不能为0\n#include &lt;bits/stdc++.h>\n\n#define INF 0x3f3f3f3f3f\n#define eps 1e-6\n#define PI acos(-1.0)\n#define pb push_back\n#define eif else if\n#define en putchar('\\n')\n#define rep(i, x, y) for (int i = x; i &lt; y; i++)\n#define red(i, x, y) for (int i = x; i > y; i--)\n#define mem(a, x) memset(a, x, sizeof(a))\n#define IOS cin.tie(0), ios::sync_with_stdio(false)\n#define maxn 100005\ntypedef long long ll;\n#define pll pair&lt;ll, ll>\nusing namespace std;\nvoid solve() &#123;\n    int a[maxn];\n    int n;\n    cin >> n;\n    rep(i, 0, n) &#123;\n        cin >> a[i];\n    &#125;\n    bool t1 = false, t2 = false, t3 = false;\n    if (n &amp; 1) &#123;\n        if (a[n - 1] + a[n - 2] != 0) &#123;\n            a[n - 2] = a[n - 1] + a[n - 2];\n            t1 = true;\n        &#125; else &#123;\n            if (a[n - 2] + a[n - 3] != 0) &#123;\n                a[n - 3] = a[n - 2] + a[n - 3];\n                a[n - 2] = a[n - 1];\n                t2 = true;\n            &#125; else &#123;\n                a[n - 3] = a[n - 3] + a[n - 1];\n                t3 = true;\n            &#125;\n        &#125;\n        for (int i = 0; i &lt; n - 1; i += 2) &#123;\n            if (i == n - 3) &#123;\n                if (t1) &#123;\n                    cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \";\n                &#125;\n                eif(t2) &#123;\n                    cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i];\n                &#125;\n                eif(t3) &#123;\n                    cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \" &lt;&lt; a[i + 1];\n                &#125;\n            &#125; else &#123;\n                cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \";\n            &#125;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125; else &#123;\n        for (int i = 0; i &lt; n; i += 2) &#123;\n            cout &lt;&lt; a[i + 1] &lt;&lt; \" \" &lt;&lt; -a[i] &lt;&lt; \" \";\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n    int T = 1;\n    cin >> T;\n    while (T--) &#123;\n        solve();\n    &#125;\n&#125;\n\n\n","slug":"cf 750","date":"2021-10-27T17:02:50.000Z","categories_index":"SOLUTIONS","tags_index":"solutions,ACM,思维,codeforces,string","author_index":"Maskros"},{"id":"e2155c016c02706041cead02c4e9a9a6","title":"kmp & exkmp","content":"kmp &amp; exkmpKnuth-Morris-Pratt &amp; entend kmp \n字符串匹配\nkmp\n\n\n\n\n\n\n\n\nKeywords：next[] \n由BF改进，O(m+n)，传世经典属于是😅\n以下均假设主串为 S，模式串为 P \n\nWhat is next[] ?\n针对模式串，next[j] 表示模式串下标 j 之前 最长相同前后缀的长度，这不重要。\n你只需要记住：next[j]表示当 P[j]!=S[i] 时，j 指针的下一步移动位置。\n偷个好图：\n\n\nHow to quickly build next[] ?\n\n\n\n\n\n\n\n\n\n话不多说，直接上🐎\nvoid kmp_pre(string p, int next[])&#123;\n\tint i,j;\n\tj&#x3D;next[0]&#x3D;-1;\n\ti&#x3D;0;\n\twhile(i&lt;p.length())&#123;\n\t\twhile(-1!&#x3D;j &amp;&amp; p[i]!&#x3D;p[j]) j&#x3D;next[j];\n\t\tnext[++i]&#x3D;++j;\n\t&#125;\n&#125;\n\n① 初始化next[0]=-1\n② 如果 P[next[m]]==P[m] ，那么 next[m+1]=next[m]+1\n③ 如果 P[next[m]]!=P[m]，令 t=m, t=next[t]，比较 P[next[t]]和 P[m]：相同的话 next[m]=next[t]+1 , 不同的令t=next[t] 继续比较，直到 t==-1 时，next[m]=0 \n\n\nkmp计数模板\n模式串在主串中出现了几次 (可重叠、不可重叠)\nvoid kmp_pre(string p, int next[])&#123;\n\tint i,j;\n\tj&#x3D;next[0]&#x3D;-1;\n\ti&#x3D;0;\n\twhile(i&lt;p.length())&#123;\n\t\twhile(-1!&#x3D;j &amp;&amp; p[i]!&#x3D;p[j]) j&#x3D;next[j];\n\t\tnext[++i]&#x3D;++j;\n\t&#125;\n&#125;\nint kmp_Count(string x, string y, int next[])&#123; &#x2F;&#x2F;x是模式串，y是主串\n\tint i,j;\n\tint ans&#x3D;0;\n\tkmp_pre(x,next);\n\ti&#x3D;j&#x3D;0;\n\twhile(i&lt;y.length())&#123;\n\t\twhile(-1!&#x3D;j &amp;&amp; y[i]!&#x3D;x[j]) j&#x3D;next[j];\n\t\ti++;j++;\n\t\tif(j&gt;&#x3D;x.length())&#123;\n\t\t\tans++;\n            &#x2F;&#x2F;以下二选一\n\t\t\tj&#x3D;next[j]; &#x2F;&#x2F;可重叠计数\n            j&#x3D;0;\t&#x2F;&#x2F;不可重叠计数\n\t\t&#125;\n\t&#125;\n\treturn ans;\n&#125;\n\nexkmp\n\n\n\n\n\n\n\n\nKeywords: extend[] next[]\nO(m+n)\ne-kmp 可以找到主串中所有模式串的匹配\n\nWhat are they?\nnext[i]: 对模式串，表示 P[i...m-1] 与 P[0...m-1] 的最长公共前缀\nextend[i] : 对主串和模式串，表示 S[i...n-1]与 P[0...m-1] 的最长公共前缀\n\nHow to build them?\n\n\n\n\n\n\n\n\n\n🐎来\nvoid ekmp_pre(string x, int next[])&#123;\n\tint m&#x3D;x.length();\n\tnext[0]&#x3D;m;\n\tint j&#x3D;0;\n\twhile(j+1&lt;m &amp;&amp; x[j]&#x3D;&#x3D;x[j+1]) j++;\n\tnext[1]&#x3D;j;\n\tint k&#x3D;1;\n\tfor(int i&#x3D;2; i&lt;m; i++)&#123;\n\t\tint p&#x3D;next[k]+k-1;\n\t\tint L&#x3D;next[i-k];\n\t\tif(i+L&lt;p+1) next[i]&#x3D;L;\n\t\telse&#123;\n\t\t\tj&#x3D;max(0,p-i+1);\n\t\t\twhile(i+j&lt;m &amp;&amp; xi+j]&#x3D;&#x3D;x[j]) j++;\n\t\t\tnext[i]&#x3D;j;\n\t\t\tk&#x3D;i;\n\t\t&#125;\n\t&#125;\n&#125;\nvoid ekmp(string x, string y, int next[], int extend[])&#123;\n\tekmp_pre(x,next);\n\tint j&#x3D;0;\n\tint m&#x3D;x.length(), n&#x3D;y.length();\n\twhile(j&lt;n &amp;&amp; j&lt;m &amp;&amp; x[j]&#x3D;&#x3D;y[j]) j++;\n\textend[0]&#x3D;j;\n\tint k&#x3D;0;\n\tfor(int i&#x3D;1; i&lt;n; i++)&#123;\n\t\tint p&#x3D;extend[k]+k-1;\n\t\tint L&#x3D;next[i-k];\n\t\tif(i+L&lt;p+1) extend[i]&#x3D;L;\n\t\telse&#123;\n\t\t\tj&#x3D;max(0,p-i+1);\n\t\t\twhile(i+j&lt;n &amp;&amp; j&lt;m &amp;&amp; y[i+j]&#x3D;&#x3D;x[j]) j++;\n\t\t\textend[i]&#x3D;j;\n\t\t\tk&#x3D;i;\n\t\t&#125;\n\t&#125;\n&#125;\n\n假设我们已经知道 next[] , 如何求 extend[] 呢？\n\n\n\n\n\n\n\n\n\n此处变量设置会和🐎有所出入，主要是理解过程😅\n① 假设当前 S 串遍历到位置i , 即extend[0...i-1]的值均以求出；首先设置两个变量，a 和 p，p 代表以a为起始位置的字符匹配成功的最右边界，’p = 最后一个匹配成功位置+1’ ，即 S[a...p) == P[0...p-a) ，假设下面基于S[i] 对应 P[i-a] 的几种情况开始讨论：\n② 如图所示，如果 i+next[i-a] &lt; p ，根据 next[]  数组的定义，易知 extend[i] = next[i-a]\n\n③ 如果 i+next[i-a] == p ，此时S[p]!=P[p-a] 且P[p-i]!=P[p-a]，但是S[p]==P[p-i]的可能仍然存在，所以直接从 S[p] 与 P[p-i] 开始向后匹配即可\n\n④ 如果 i+next[i-a] &gt; p ，此时说明 S[i...p) 与 P[i-a...p-a]相同，注意到 S[p]!=P[p-a] 并且 P[p-i]==P[p-a]，即 S[p]!=T[p-i] ，所以没必要继续往下判断了，故赋值extend[i]=p-i\n\n⑤ 由上面的过程，求解next[i]的过程即为 P 自己和自己匹配的过程，over\n\n\n\n\n\n\n\n\n\n\n\n需要细品\n\n题单Solution\n\n0x01 剪花布条 HDU-2087 link\n\n0x02 Secret HDU-6153 link\n\n0x03 Cow Patterns POJ-3167 link\n\n… 待更\n\n\n\n\n\n\n\n\n\n\n\nkmp 和 exkmp 整的头晕….\n","slug":"kmp & exkmp","date":"2021-10-23T17:02:50.000Z","categories_index":"ALGORITHMS","tags_index":"ACM,note,string,algorithm","author_index":"Maskros"},{"id":"ebad22b2d3ed9cce7b0eb0ed467a5511","title":"SpringMVC学习杂记","content":"SpringMVC学习杂记\n\n\n\n\n\n\n\n\n注：杂记即为看到啥记啥 毫无章法 乱jb记\n\n\n\n\n\n\n\n\n\n常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等\nSpringSpring 是最受欢迎的企业级 Java 应用程序开发的轻量级框架\nSpring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践\n三层架构\n表现层  web层  MVC是表现层的一个设计模型 \n\n业务层  service层\n\n持久层  dao层\n\n\n优良特性\n非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API\n控制反转：IOC——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。\n依赖注入：DI——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。\n面向切面编程：Aspect Oriented Programming——AOP\n容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期\n组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。\n一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC）\n\n体系结构\nMVC职责分析\nController：控制器\n\n取得表单数据\n调用业务逻辑\n转向指定的页面\n\n\nModel：模型\n\n业务逻辑\n保存数据的状态\n\n\nView：视图\n\n显示页面\n\n\n\n\n\nMVC框架需要做哪些事情：\n\n将url映射到java类或java类的方法 .\n\n封装用户提交的数据 .\n\n处理请求–调用相关的业务处理–封装响应数据 .\n\n将响应的数据进行渲染 . jsp / html 等表示层数据 .\n\n\n\n\nServletjsp：本质就是一个servlet\n\n添加pom依赖\n\n新建空Maven项目\n\nAdd Framework Support 选择Web Application添加 变成web项目 \n\n导入servlet和jsp的依赖\n\n编写一个Servlet类，用来处理用户的请求\n\n\npublic class HelloServlet extends HttpServlet \n\n\n在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp\n在web.xml中注册Servlet\n配置Tomcat 并启动测试\n\nSpringMVC\n\n\n\n\n\n\n\n\nSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量 级Web框架\n Spring MVC的特点：\n\n轻量级，简单易学\n高效 , 基于请求响应的MVC框架\n与Spring兼容性好，无缝结合\n约定优于配置\n功能强大：RESTful、数据验证、格式化、本地化、主题等\n简洁灵活\n\nSpring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁\n中心控制器Spring MVC框架以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\nSpringMVC的原理如下图所示：\n​    当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n\nSpringMVC执行原理\n\n\n\n\n\n\n\n\n图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现\n\n\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n\n\n\n\n\n\n\n\n\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080 服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\n\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\n\nHandler让具体的Controller执行。\n\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\n\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n\n最终视图呈现给用户。\n\n\n配置版\n配置web.xml  ， 注册DispatcherServlet\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n        version=\"4.0\">\n\n   &lt;!--1.注册DispatcherServlet-->\n   &lt;servlet>\n       &lt;servlet-name>springmvc&lt;/servlet-name>\n       &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>\n       &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml-->\n       &lt;init-param>\n           &lt;param-name>contextConfigLocation&lt;/param-name>\n           &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value>\n       &lt;/init-param>\n       &lt;!--启动级别-1-->\n       &lt;load-on-startup>1&lt;/load-on-startup>\n   &lt;/servlet>\n\n   &lt;!--/ 匹配所有的请求；（不包括.jsp）-->\n   &lt;!--/* 匹配所有的请求；（包括.jsp）-->\n   &lt;servlet-mapping>\n       &lt;servlet-name>springmvc&lt;/servlet-name>\n       &lt;url-pattern>/&lt;/url-pattern>\n   &lt;/servlet-mapping>\n\n&lt;/web-app>\n编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml  : [servletname]-servlet.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n&lt;/beans>\n添加 处理映射器\n&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\n添加 处理器适配器\n&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n添加 视图解析器\n&lt;!--视图解析器:DispatcherServlet给他的ModelAndView-->\n&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\">\n   &lt;!--前缀-->\n   &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n   &lt;!--后缀-->\n   &lt;property name=\"suffix\" value=\".jsp\"/>\n&lt;/bean>\n编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；\npackage com.maskros.controller;\n\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n//注意：这里我们先导入Controller接口\npublic class HelloController implements Controller &#123;\n\n   public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n       //ModelAndView 模型和视图\n       ModelAndView mv = new ModelAndView();\n\n       //封装对象，放在ModelAndView中。Model\n       mv.addObject(\"msg\",\"HelloSpringMVC!\");\n       //封装要跳转的视图，放在ModelAndView中\n       mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp\n       return mv;\n  &#125;\n   \n&#125;\n将自己的类交给SpringIOC容器，注册bean\n&lt;!--Handler-->\n&lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/>\n写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;title&gt;Kuangshen&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n$&#123;msg&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n配置tomcat启动测试\n\n\n\n\n\n\n\n\n\n\n\n可能遇到的问题：访问出现404，排查步骤：\n\n查看控制台输出，看一下是不是缺少了什么jar包。\n如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！\n\n\n※注解版\n由于Maven可能存在资源过滤的问题，我们将配置完善\n&lt;build>\n   &lt;resources>\n       &lt;resource>\n           &lt;directory>src/main/java&lt;/directory>\n           &lt;includes>\n               &lt;include>**/*.properties&lt;/include>\n               &lt;include>**/*.xml&lt;/include>\n           &lt;/includes>\n           &lt;filtering>false&lt;/filtering>\n       &lt;/resource>\n       &lt;resource>\n           &lt;directory>src/main/resources&lt;/directory>\n           &lt;includes>\n               &lt;include>**/*.properties&lt;/include>\n               &lt;include>**/*.xml&lt;/include>\n           &lt;/includes>\n           &lt;filtering>false&lt;/filtering>\n       &lt;/resource>\n   &lt;/resources>\n&lt;/build>\n在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入\n\n配置 web.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n        version=\"4.0\">\n\n   &lt;!--1.注册servlet-->\n   &lt;servlet>\n       &lt;servlet-name>SpringMVC&lt;/servlet-name>\n       &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>\n       &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联-->\n       &lt;init-param>\n           &lt;param-name>contextConfigLocation&lt;/param-name>\n           &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value>\n       &lt;/init-param>\n       &lt;!-- 启动顺序，数字越小，启动越早 -->\n       &lt;load-on-startup>1&lt;/load-on-startup>\n   &lt;/servlet>\n\n   &lt;!--所有请求都会被springmvc拦截 -->\n   &lt;servlet-mapping>\n       &lt;servlet-name>SpringMVC&lt;/servlet-name>\n       &lt;url-pattern>/&lt;/url-pattern>\n   &lt;/servlet-mapping>\n\n&lt;/web-app>\n\n\n\n\n\n\n\n\n\n\n/ 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错\n\n添加 SpringMVC 配置文件\n在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:context=\"http://www.springframework.org/schema/context\"\n      xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc\n       https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n   &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 -->\n   &lt;context:component-scan base-package=\"com.kuang.controller\"/>\n   &lt;!-- 让Spring MVC不处理静态资源 -->\n   &lt;mvc:default-servlet-handler />\n   &lt;!--\n   支持mvc注解驱动\n       在spring中一般采用@RequestMapping注解来完成映射关系\n       要想使@RequestMapping注解生效\n       必须向上下文中注册DefaultAnnotationHandlerMapping\n       和一个AnnotationMethodHandlerAdapter实例\n       这两个实例分别在类级别和方法级别处理。\n       而annotation-driven配置帮助我们自动完成上述两个实例的注入。\n    -->\n   &lt;mvc:annotation-driven />\n\n   &lt;!-- 视图解析器 -->\n   &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\n         id=\"internalResourceViewResolver\">\n       &lt;!-- 前缀 -->\n       &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n       &lt;!-- 后缀 -->\n       &lt;property name=\"suffix\" value=\".jsp\" />\n   &lt;/bean>\n\n&lt;/beans>\n创建 Contronller\n\n\n\n\n\n\n\n\n\n\n@Controller是为了让Spring IOC容器初始化时自动扫描到；\n@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；\n方法中声明Model类型的参数是为了把Action中的数据带到视图中；\n方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。\n\n// 编写控制类\npackage com.kuang.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\n@RequestMapping(\"/HelloController\")\npublic class HelloController &#123;\n\n   //真实访问地址 : 项目名/HelloController/hello\n   @RequestMapping(\"/hello\")\n   public String sayHello(Model model)&#123;\n       //向模型中添加属性msg与值，可以在JSP页面中取出并渲染\n       model.addAttribute(\"msg\",\"hello,SpringMVC\");\n       //web-inf/jsp/hello.jsp\n       return \"hello\";\n  &#125;\n&#125;\n创建视图层\n在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;title&gt;SpringMVC&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n$&#123;msg&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n配置 Tomcat 运行\n\n\n\n使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\n控制器和RestFul\n\n\n\n\n\n\n\n\n控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。\n控制器负责解析用户的请求并将其转换为一个模型。\n在Spring MVC中一个控制器类可以包含多个方法\n在Spring MVC中，对于Controller的配置方式有很多种，一般使用注解@Controller\n实现Controller接口\nmvc的配置文件只留下 视图解析器\n\nControllerTest1\n//定义控制器\n//注意点：不要导错包，实现Controller接口，重写方法；\npublic class ControllerTest1 implements Controller &#123;\n\n   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n       //返回一个模型视图对象\n       ModelAndView mv = new ModelAndView();\n       mv.addObject(\"msg\",\"Test1Controller\");\n       mv.setViewName(\"test\");\n       return mv;\n  &#125;\n&#125;\n编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类\n&lt;bean name=\"/t1\" class=\"com.maskros.controller.ControllerTest1\"/>\n编写前端test.jsp\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;title&gt;Kuangshen&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n$&#123;msg&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n实现接口Controller定义控制器是较老的办法\n缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；\n\n使用注解@Controller\n@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；\n\nSpring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。\n&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 -->\n&lt;context:component-scan base-package=\"com.kuang.controller\"/>\n增加一个ControllerTest2类，使用注解实现\n//@Controller注解的类会自动添加到Spring上下文中\n@Controller\npublic class ControllerTest2&#123;\n\n   //映射访问路径\n   @RequestMapping(\"/t2\")\n   public String index(Model model)&#123;\n       //Spring MVC会自动实例化一个Model对象用于向视图中传值\n       model.addAttribute(\"msg\", \"ControllerTest2\");\n       //返回视图位置\n       return \"test\";\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。\n@RequestMapping 使用\n@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径\n\n// 只注解在方法上面\n@Controller\npublic class TestController &#123;\n   @RequestMapping(\"/h1\")\n   public String test()&#123;\n       return \"test\";\n  &#125;\n&#125;\n//访问路径：http://localhost:8080 / 项目名 / h1\n\n// 同时注解类与方法@Controller\n@RequestMapping(\"/admin\")\npublic class TestController &#123;\n   @RequestMapping(\"/h1\")\n   public String test()&#123;\n       return \"test\";\n  &#125;\n&#125;\n//访问路径：http://localhost:8080 / 项目名/ admin /h1 \n\nRestFul风格\n\n\n\n\n\n\n\n\nRestful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。localhost:8080/a/b/c/d/……\n在Spring MVC中可以使用  @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上\n@Controller\npublic class RestFulController &#123;\n\n   //映射访问路径\n   @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\")\n   public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;\n       \n       int result = p1+p2;\n       //Spring MVC会自动实例化一个Model对象用于向视图中传值\n       model.addAttribute(\"msg\", \"结果：\"+result);\n       //返回视图位置\n       return \"test\";\n       \n  &#125;\n   \n&#125;\n\n使用路径变量的好处？\n\n\n使路径变得更加简洁；\n获得参数更加方便，框架会自动进行类型转换。\n通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。\n\n\n\n使用method属性指定请求类型\n用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等\n//映射访问路径,必须是POST请求\n@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.POST&#125;)\npublic String index2(Model model)&#123;\n   model.addAttribute(\"msg\", \"hello!\");\n   return \"test\";\n&#125;\n\n// 我们使用浏览器地址栏进行访问默认是Get请求，会报错405\n// 如果将POST修改为GET则正常了\n\n//映射访问路径,必须是Get请求\n@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.GET&#125;)\npublic String index2(Model model)&#123;\n   model.addAttribute(\"msg\", \"hello!\");\n   return \"test\";\n&#125;\n\n\nSpring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\\\n所有的地址栏请求默认都会是 HTTP GET 类型的\n方法级别的注解变体有如下几个：组合注解\n@GetMapping\n@PostMapping\n@PutMapping\n@DeleteMapping\n@PatchMapping\n\n@GetMapping 是一个组合注解，平时使用的会比较多, 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式\n数据处理和跳转转发 重定向\n接受请求参数以及数据回显\n@RequestParam(\"xxx\")  //必须要求传这个参数\n\nJson\n\n\n\n\n\n\n\n\nJavaScript Object Notation, JS 对象标记 是一种轻量级的数据交换格式，目前使用特别广泛，采用完全独立于编程语言的文本格式来存储和表示数据\n\n@Controller：定义一个控制器类，\n@RestController： 注解相当于 @Controller ＋ @ResponseBody 合在一起的作用。\n@ResponseBody：标记Controller类中的方法。把return的结果变成JSON对象返回。\n\n语法格式：\n\n对象表示为键值对，数据由逗号分隔\n花括号保存对象\n方括号保存数组\n\nJSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值\n&#123;\"name\": \"QinJiang\"&#125;\n&#123;\"age\": \"3\"&#125;\n&#123;\"sex\": \"男\"&#125;\n\nJson 和 JavaScript 对象互转：\nJSON.parse()  //从JSON字符串转换为JavaScript 对象\nJSON.stringify() //从JavaScript 对象转换为JSON字符串\n\nController返回Json数据Jackson使用导入它的jar包 配置SpringMVC\n编写Controller时需要运用到两个新东西：@ResponseBody，ObjectMapper对象\n乱码处理\nFastJson使用\n\n\n\n\n\n\n\n\n 阿里开发 方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换\n乱码问题&lt;!-- Json乱码问题配置 -->\n&lt;mvc:annotation-driven>\n   &lt;mvc:message-converters register-defaults=\"true\">\n       &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n           &lt;constructor-arg value=\"UTF-8\"/>\n       &lt;/bean>\n       &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\n           &lt;property name=\"objectMapper\">\n               &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\">\n                   &lt;property name=\"failOnEmptyBeans\" value=\"false\"/>\n               &lt;/bean>\n           &lt;/property>\n       &lt;/bean>\n   &lt;/mvc:message-converters>\n&lt;/mvc:annotation-driven>\n\n\n\nAjax\n\n\n\n\n\n\n\n\nAsynchronous JavaScript and XML（异步的 JavaScript 和 XML）\nAjax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术\n\n可以通过 iframe 标签来伪造一个Ajax\n利用AJAX可以做：\n注册时，输入用户名自动检测用户是否已经存在。\n登陆时，提示用户名密码错误\n删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。\n….\n\n\n\njQuery.ajax\n\n\n\n\n\n\n\n\nAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据\njQuery是一个库，提供大量的JavaScript函数\njQuery.ajax(...)\n      部分参数：\n            url：请求地址\n            type：请求方式，GET、POST（1.9.0之后用method）\n        headers：请求头\n            data：要发送的数据\n    contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\")\n          async：是否异步\n        timeout：设置请求超时时间（毫秒）\n      beforeSend：发送请求前执行的函数(全局)\n        complete：完成之后执行的回调函数(全局)\n        success：成功之后执行的回调函数(全局)\n          error：失败之后执行的回调函数(全局)\n        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型\n        dataType：将服务器端返回的数据转换成指定类型\n          \"xml\": 将服务器端返回的内容转换成xml格式\n          \"text\": 将服务器端返回的内容转换成普通文本格式\n          \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。\n        \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式\n          \"json\": 将服务器端返回的内容转换成相应的JavaScript对象\n        \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数\n\nAjax异步加载数据实现了数据回显\n&lt;script>\n   $(function () &#123;\n       $(\"#btn\").click(function () &#123;\n           $.post(\"$&#123;pageContext.request.contextPath&#125;/a2\",function (data) &#123;\n               console.log(data)\n               var html=\"\";\n               for (var i = 0; i &lt;data.length ; i++) &#123;\n                   html+= \"&lt;tr>\" +\n                       \"&lt;td>\" + data[i].name + \"&lt;/td>\"+\n                       \"&lt;td>\" + data[i].age + \"&lt;/td>\" +\n                       \"&lt;td>\" + data[i].sex + \"&lt;/td>\" +\n                       \"&lt;/tr>\"\n              &#125; \t//html拼接\n               $(\"#content\").html(html);\n          &#125;);\n      &#125;)\n  &#125;)\n&lt;/script>\n\n拦截器Interceptor\n\n\n\n\n\n\n\n\nSpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。可用于验证用户是否登录 (认证用户)\n过滤器和拦截器的区别：\n过滤器：\n\nservlet规范中的一部分，任何java web工程都可以使用\n在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截\n\n拦截器 (是AOP思想的具体应用)\n\n拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用\n拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的\n\n想要自定义拦截器，必须实现 HandlerInterceptor 接口\n在springmvc的配置文件中配置拦截器\n&lt;!--关于拦截器的配置-->\n    &lt;mvc:interceptors>\n        &lt;mvc:interceptor>\n            &lt;!--/** 包括路径及其子路径-->\n            &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截-->\n            &lt;!--/admin/** 拦截的是/admin/下的所有-->\n            &lt;mvc:mapping path=\"/somewhere/**\"/>\n            &lt;!--拦截somewhere下的 somewhere用@RequestMapping()配置 -->\n            &lt;!--bean配置的就是拦截器-->\n            &lt;bean class=\"com.maskros.interceptor.MyInterceptor\"/>\n        &lt;/mvc:interceptor>\n    &lt;/mvc:interceptors>\n\n每写一个拦截器要到xml中配置这个拦截器\nexp：未登录时点击主页按钮会被拦截器重定向到登录页面\n杂记SpringMVC + Vue + SpringBoot + SpringCloud + Linux\nSpring：IOC 和 AOP\nSpringMVC：SpringMVC的执行流程，SSM框架整合\nSSM =  javaweb做项目\nMVC：模型 (dao, service) , 视图 (jsp) , 控制器 (servlet)\nservlet: 转发 重定向\n前端 数据传输 实体类\n实体类：用户名 密码  生日 ….. n个\n前端：用户名 密码\npojo: User\nvo: UserVo\nMVVM:  M - V - VM (ViewModel: 双向绑定)\nform表单 method: get/post\n&lt;form action&#x3D;&quot;&#x2F;hello&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;method&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n\n\n\nSpring: 大杂烩，我们可以将SpringMVC中所有要用到的Bean，注册到Spring中\n访问网站：-&gt; Servlet(中转调度) &lt;=&gt; Service -&gt; Dao -&gt; Sql\n前后端分离时代：\n后端部署后端，提供接口，提供数据：json\n前端独立部署，负责渲染后端的数据\njs:\n\n函数：闭包() ()\nDom\nid, name, tag\ncreate, remove\n\n\nBom\nwindow\ndocument\n\n\n\nES6: import require\njs:\ndata:&#123;'name':$(\"#username\").val()&#125;,\n// data传键值对 &#123;x:y&#125;  .val()==value 左边的name对应controller的name 右边的username对应下面输入框的id,加#才能取到！    \n\n\n\nIDEA alt+insert 快捷键 实现接口等等 \n","slug":"springMVC","date":"2021-09-15T18:37:28.000Z","categories_index":"NOTE","tags_index":"note,springMVC,java","author_index":"Maskros"},{"id":"0b411eca06d29c39e2fc21f5cd175527","title":"STL使用手册","content":"STL使用手册Standard Template Library\n\n\n\n\n\n\n\n\n\n又名《👴怕忘了先把他写下来》\n我 是 谁 ?斯丹德儿的 坦普雷特 莱博瑞 即标准模板库\n\n重要特点：数据结构和算法的分离\n\n重要特性：不是面向对象的\n\n逻辑层次：体现了泛型化程序设计的思想\n\n实现层次：以一种类型参数化的方式实现，基于模板(template)\n\n\n六大组件：\n\n容器（Container），是一种数据结构，如list，vector，deques ，以模板类的方法提供 ;\n迭代器（Iterator），提供了访问容器中对象的方法。迭代器就如同一个指针。C++的指针也是一种迭代器。迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；\n算法（Algorithm），是用来操作容器中的数据的模板函数。如sort()，find()，函数本身与他们操作的数据的结构和类型无关 ;\n仿函数（Functor）\n适配器（Adaptor）\n分配器（allocator）\n\n👴 常用的\n\n\n\n\n\n\n\n\n以下不按顺序，想到啥就写啥，有个🥚的顺序\n容器string字符串\n&#x2F;&#x2F;构造函数\nstring s(str,index); &#x2F;&#x2F;将字符串str内“始于位置index”的部分当作字符串的初值\nstring s(str,index,n); &#x2F;&#x2F;将字符串str内“始于index且长度顶多n”的部分作为字符串的初值\nstring s(n,c); &#x2F;&#x2F;生成一个字符串，包含n个c字符(char)\nstring s(str.begin(),str.end()); &#x2F;&#x2F;以区间begin():end() (不包含end())内的字符作为字符串s的初值\n\n&#x2F;&#x2F;操作函数\ns.erase(s.begin(),s.end()); &#x2F;&#x2F;删除\ns.replace(pos,len,str); &#x2F;&#x2F;替换，从pos开始长为len被替换为str\ns.find(str,pos&#x3D;0); &#x2F;&#x2F;从pos向右查找，返回str第一次出现的位置\ns.rfind(str,pos&#x3D;npos); &#x2F;&#x2F;从pos反向查找，返回找到位置\ns.find_first_of(str); &#x2F;&#x2F;查找第一个属于str中字符的位置\ns.find_first_not_of(str); &#x2F;&#x2F;查找第一个不属于str中字符位置\ns.find_last_of(str);\ns.find_last_not_of(str);\ns1.compare(s2); &#x2F;&#x2F;比较，相等0大于1小于-1\ns1.compare(pos,len,s2)&#x2F;&#x2F;从s1的pos开始长为len与s2比较\n\nstringstream自动且直接的类型转换\nstringstream sstream;\n&#x2F;&#x2F;数据类型转换\nstring str;\nint a&#x3D;123;\nsstream &lt;&lt; a;\nsstream &gt;&gt; str;\ncout&lt;&lt;str;\ncout&lt;&lt;sstream.str(); \n&#x2F;&#x2F;多个字符串拼接\nsstream &lt;&lt; &quot;xxxx&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;aaaaa&quot;;\n&#x2F;&#x2F;清空stringstream\nsstream.clear();\nsstream.str(&quot;&quot;);\n\npair便携结构体\n&#x2F;&#x2F;访问通过first second\n&#x2F;&#x2F;可以通过一般运算符比较，先比较first再second\npair&lt;string,int&gt; p (str,123);\npair&lt;string,int&gt; p &#x3D; make_pair(str,123);\n\nvector向量容器，动态存储\nvector&lt;int&gt; v;\nv.front(); v.back();\nv.begin(); v.end();\nv.push_back();\nv.size();\nv.empty();\nv.clear();\nv.pop_back(); &#x2F;&#x2F;删除表尾元素\nv.insert(it,x); &#x2F;&#x2F;向迭代器it 指向的元素前插入新元素x\nv.insert(it,n,x); &#x2F;&#x2F;插入n个x\nv.insert(it, first, last); &#x2F;&#x2F;将由迭代器first和last 所指定的序列[first, last)插入到迭代器it指向的元素前面\nv.erase(it); &#x2F;&#x2F;删\nv.erase(first,last);\nv.reverse(n); &#x2F;&#x2F;预分配缓冲空间，使存储空间至少可容纳n个元素\nv.resize(n); &#x2F;&#x2F;改变序列长度，超出元素删除，若源空间小于n，则默认值填满空间\nv.resize(n,val); &#x2F;&#x2F;超出的用val填满\n\nstack栈\nstack&lt;int&gt; s;\ns.push(x);\ns.pop();\ns.top();\ns.empty();\ns.size();\n\nqueue队列，优先队列，双端队列\n&#x2F;&#x2F; queue\nqueue&lt;int&gt; q;\nq.push(x);\nq.pop();\nq.front(); q.back();\nq.empty();\nq.size();\n\n&#x2F;&#x2F; priority_queue\npriority&lt;int&gt; q; &#x2F;&#x2F;默认大者优先\npriority&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; &#x2F;&#x2F;小的先出队 三个模板参数：元素类型，容器类型，比较算子\n&#x2F;&#x2F; 优先级设置：定义结构体\nstruct Student&#123;\n    int num;\n    int grade;\n    friend bool operator &lt; (Student s1, Student s2)&#123;\n        return s1.grade&lt;s2.grade;\n        &#x2F;&#x2F;此处小于号还是小于的作用，故队列中以成绩高的学生优先，若反之变号即可\n    &#125;\n&#125;;\npriority_queue&lt;Student&gt; q;\n&#x2F;&#x2F;也可以把重载的函数写在结构体外面\nstruct cmp&#123;\n    bool operator() (Student s1, Student s2)&#123;\n        return s1.grade&lt;s2.grade;\n    &#125;\n&#125;;&#x2F;&#x2F;tips:优先队列中的cmp和sort中的cmp效果相反\npriority_queue&lt;Student,vector&lt;Student&gt;,cmp&gt; q;\n&#x2F;&#x2F;如果结构体内数据庞大，像出现字符串或者数组，建议使用引用来提高效率。此时比较类的参数需要加上 const 和 &amp;\nfriend bool operator &lt; (const Student &amp;s1, const Student &amp;s2)&#123;\n\treturn s1.grade&lt;s2.grade;\n&#125;\n\n&#x2F;&#x2F;deque\ndeque&lt;int&gt; d;\nd.push_back(x); &#x2F;&#x2F;尾部插入\nd.push_front(x); &#x2F;&#x2F;首部插入元素\nd.insert(d.begin()+len,x); &#x2F;&#x2F;中间插入元素\n&#x2F;&#x2F;可以通过 d[0] d[1] 访问\nd.pop_front(); &#x2F;&#x2F;删除头部\nd.pop_back();\nd.erase(d.begin()+len); &#x2F;&#x2F;删除指定位置元素，可以写多个\n\nmap键值对，元素按关键字有序，内部红黑树\n&#x2F;&#x2F; map空间占用率高\nmap&lt;string,int&gt; m;\nm[key]&#x3D;value;\nm.insert(make_pair(key,value));\nm.erase(key);\nm.erase(it);\nm.clear();\nm.size();\t\nmap&lt;string,int&gt;::iterator it;\nfor(it&#x3D;mp.begin();it!&#x3D;mp.end();++it)&#123;\n    cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;\n&#125;\n\n&#x2F;&#x2F; unordered_map 效率较高 内部哈希表\n&#x2F;&#x2F; 对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map\n\nset无重复，按键值自动排序\n数据结构为红黑树。以节点形式保存（动态)，用迭代器访问\nset&lt;int&gt; s;\ns.begin(); s.end();\ns.clear();\ns.empty();\ns.erase(x);\ns.find(x);\ns.insert(x);\ns.size();\ns.lower_bound(value); &#x2F;&#x2F;返回第一个大于等于value的定位器\ns.upper_bound(value); &#x2F;&#x2F;返回最后一个大于等于value的定位器\nset&lt;int&gt;::iterator it;\nfor(it&#x3D;s.begin();it!&#x3D;s.end();it++)\n\tcout&lt;&lt;*it&lt;&lt;&quot; &quot;;\n\nlist链表\n\n如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector \n如果你需要大量的插入和删除，而不关心随即存取，则应使用list \n如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque\n\nlist&lt;int&gt; a(n);\nlist&lt;int&gt; a&#123;1,2,3,4&#125;;\na.push_back(x);\na.push_front(x);\na.empty();\na.resize(n);\na.clear();\na.front(); a.back();\na.reverse();\na.merge(b); &#x2F;&#x2F;b变空，a尾插入b\na.insert(pos,x);\na.insert(pos,b.begin(),b.end());\na.erase(a.begin(),a.end());\na.remove(x);\n\nbitset存放二进制0/1的容器，可以声明非常大的二进制位而不限于64，用来优化\nbitset&lt;N&gt; b; &#x2F;&#x2F;表示长为N的二进制串\n&#x2F;&#x2F; 通过b[pos]访问\nb.any(); &#x2F;&#x2F;存在为1的二进制位\nb.none(); &#x2F;&#x2F;不存在为1的二进制位\nb.count(); &#x2F;&#x2F;置1的二进制位的个数\nb.size();\nb.test(pos); &#x2F;&#x2F;在pos位处是否为1\nb.set(); &#x2F;&#x2F;所有位置1\nb.set(pos);\nb.reset(); &#x2F;&#x2F;所有位置0\nb.reset(pos);\nb.flip(); &#x2F;&#x2F;逐位取反\nb.flip(pos);\n\nfunctions查找lower_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于等于x的位置\nupper_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于x的位置\nfind();\nrfind();\n\n排序sort(a,a+n,cmp); &#x2F;&#x2F;默认ASC\n\n修改swap(a,b); &#x2F;&#x2F;交换\nreplace(pos,len,str); &#x2F;&#x2F;替换\nunique(a,a+n); &#x2F;&#x2F;去除相邻的重复元素,会把重复的藏到末尾，使用前需要先排序\n\n排列next_permutation(a,a+n); &#x2F;&#x2F;下一个全排列\nprev_permutation(a,a+n); &#x2F;&#x2F;上一个全排列\n&#x2F;&#x2F;函数返回bool值，一般配合while()\n\n其他isalpha(char x); &#x2F;&#x2F;小写字母返回2，大写字母1，非字母0\t\ntolower(char x); toupper(char x); &#x2F;&#x2F;返回小写，大写字母的ASCII值，非字母则相等\n&#x2F;&#x2F;海伦公式\np&#x3D;(a+b+c)&#x2F;2;\ns&#x3D;sqrt(p*(p-a)*(p-b)*(p-c));\nabs(int x); &#x2F;&#x2F;只用于整数\nfabs(double x); &#x2F;&#x2F;精度更高\n\n\n暂时就这些了，寄！\n","slug":"STL使用手册","date":"2021-08-13T06:15:31.000Z","categories_index":"ALGORITHMS","tags_index":"ACM,note,algorithm","author_index":"Maskros"},{"id":"e4b68a32c6fd94c2953f12692556d556","title":"我确实不会线段树","content":"线段树Segment Tree\n\n\n\n\n\n\n\n\n\n一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来艹了\n\n原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2,b]。\n作用：对编号连续的一些点的区间信息进行修改或者统计操作，用线段树统计的东西，必须符合区间加法。与树状数组不同的是，线段树不止适用于区间求和的查询，也可以进行区间最大值，区间最小值，或者区间异或值的查询。\n主要操作：区间查询、点更新、区间更新\n例如：\n\n给定s和t，求其区间上的最小值\n给定i和x，把ai的值改成x\n\n更新和区间查询的复杂度都是 O(log(N))\n操作\n\n\n\n\n\n\n\n\nbuild, update(内含push_down), query\n建树 (build)线段树是一棵平衡二叉树，每个节点都对应一条线段(区间)，反之不成立，每个节点 $p$ 的左右子节点的编号分别为 $2p$ 和 $2p+1$ ，假如节点 $p$ 储存区间 $[a,b]$ 的和，设 $mid=[\\frac{l+r}{2}]$，那么两个子节点分别储存 $[l,mid]$ 和 $[mid+1,r]$ 的和。可以发现，左节点对应的区间长度，与右节点相同或者比之恰好多 $1$。\n故建树可考虑递归进行：\nvoid build(ll l &#x3D; 1, ll r &#x3D; n, ll p &#x3D; 1)\n&#123;\n    if (l &#x3D;&#x3D; r) &#x2F;&#x2F; 到达叶子节点\n        tree[p]&#x3D;A[l]; &#x2F;&#x2F; 用数组中的数据赋值\n    else&#123;\n        ll mid &#x3D; (l + r) &#x2F; 2;\n        build(l, mid, p * 2); &#x2F;&#x2F; 先建立左右子节点\n        build(mid + 1, r, p * 2 + 1);\n        tree[p] &#x3D; tree[p * 2] + tree[p * 2 + 1]; &#x2F;&#x2F; 该节点的值等于左右子节点之和\n    &#125;\n&#125;\n\n 这里👴偷了个 gif 来演示一下过程 (虽然大部分都是偷的🤡)\n\n\n区间修改(update)首先定义”懒标记“(即“延迟标记”) mark[]：\n对于区间修改，朴素的想法是用递归的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个标记，将来要用到它的子区间的时候，再向下传递\n直接上🐴 (非最简):\nvoid update(ll l, ll r, ll d, ll p &#x3D; 1, ll cl &#x3D; 1, ll cr &#x3D; n)\n&#123;\n    if (cl &gt; r || cr &lt; l) &#x2F;&#x2F; 区间无交集\n        return; &#x2F;&#x2F; 剪枝\n    else if (cl &gt;&#x3D; l &amp;&amp; cr &lt;&#x3D; r) &#x2F;&#x2F; 当前节点对应的区间包含在目标区间中\n    &#123;\n        tree[p] +&#x3D; (cr - cl + 1) * d; &#x2F;&#x2F; 更新当前区间的值\n        if (cr &gt; cl) &#x2F;&#x2F; 如果不是叶子节点\n            mark[p] +&#x3D; d; &#x2F;&#x2F; 给当前区间打上标记\n    &#125;\n    else &#x2F;&#x2F; 与目标区间有交集，但不包含于其中\n    &#123;\n        ll mid &#x3D; (cl + cr) &#x2F; 2;\n        mark[p * 2] +&#x3D; mark[p]; &#x2F;&#x2F; 标记向下传递\n        mark[p * 2 + 1] +&#x3D; mark[p];\n        tree[p * 2] +&#x3D; mark[p] * (mid - cl + 1); &#x2F;&#x2F; 往下更新一层\n        tree[p * 2 + 1] +&#x3D; mark[p] * (cr - mid);\n        mark[p] &#x3D; 0; &#x2F;&#x2F; 清除标记\n        update(l, r, d, p * 2, cl, mid); &#x2F;&#x2F; 递归地往下寻找\n        update(l, r, d, p * 2 + 1, mid + 1, cr);\n        tree[p] &#x3D; tree[p * 2] + tree[p * 2 + 1]; &#x2F;&#x2F; 根据子节点更新当前节点的值\n    &#125;\n&#125;\n\n更新时，我们是从最大的区间开始，递归向下处理。注意到，任何区间都是线段树上某些节点的并集。于是我们记目标区间为 $[l,r] $，当前区间为 $[cl,cr]$ ， 当前节点为 $p$ ，我们会遇到三种情况：\n\n当前区间与目标区间没有交集：\n直接结束递归\n\n当前区间被包括在目标区间里：\n可以更新区间，不能忘记乘上区间长度\ntree[p] +&#x3D; (cr - cl + 1) * d;\n\n然后打上懒标记（叶子节点可以不打标记，因为不会再向下传递了）\nmark[p] +&#x3D; d;\t&#x2F;&#x2F;表示“该区间上每一个点都要加上d”。因为原来可能存在标记，所以是+&#x3D;而不是&#x3D;\n当前区间与目标区间相交，但不包含于其中:\n这时把当前区间一分为二，分别进行处理。如果存在懒标记，要先把懒标记传递给子节点（注意也是+=，因为原来可能存在懒标记)\nll mid &#x3D; (cl + cr) &#x2F; 2;\nmark[p * 2] +&#x3D; mark[p];\nmark[p * 2 + 1] +&#x3D; mark[p];\n\n两个子节点的值也就需要相应的更新（后面乘的是区间长度) :[p * 2] += mark[p] * (mid - cl + 1);\ntree[p * 2 + 1] += mark[p] * (cr - mid);\n不要忘记清除该节点的懒标记：\nmark[p]&#x3D;0;\n\n因为贵标记和👴一样是个懒蛋，只往下传递一层，所以这个过程并不是递归的，以后要用再才继续传递。其实我们常常把这个传递过程封装成一个函数扑屎裆 :\ninline void push_down(ll p, ll len)&#123;\n    mark[p * 2] +&#x3D; mark[p];\n    mark[p * 2 + 1] +&#x3D; mark[p];\n    tree[p * 2] +&#x3D; mark[p] * (len - len &#x2F; 2);\n    tree[p * 2 + 1] +&#x3D; mark[p] * (len &#x2F; 2); &#x2F;&#x2F; 右边的区间可能要短一点\n    mark[p] &#x3D; 0;\n&#125;\n&#x2F;&#x2F;这样儿 update() 里面调用的时候直接 push_down(p, cr - cl + 1); 就彳亍\n\n传递完标记后，再递归地去处理左右两个子节点就彳亍乐\n\n\n下面儿👴又偷了个视频展示一下区间 $[1,4]$ 加上 $1$ 的过程：\n\n至于单点修改，只需要令左右端点相等即可~\n区间查询(query)还就那个直接上🐴\nll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n)&#123;\n    if (cl > r || cr &lt; l)\n        return 0;\n    else if (cl >= l &amp;&amp; cr &lt;= r)\n        return tree[p];\n    else&#123;\n        ll mid = (cl + cr) / 2;\n        push_down(p, cr - cl + 1);\n        return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr); \n        // 上一行拆成三行写就和区间修改格式一致了\n    &#125;\n&#125;\n\n一样的递归，一样自顶至底地寻找，一样的合并信息，即插即用😍\n模板\n\n\n\n\n\n\n\n\nsource : 洛谷P3372 【模板】线段树 1\n题目描述如题，已知一个数列，你需要进行下面两种操作：1.将某区间每一个数加上x2.求出某区间每一个数的和输入格式第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。接下来M行每行包含3或4个整数，表示一个操作，具体如下：操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和输出格式输出包含若干行整数，即为所有操作2的结果。\n\ntips: 本模板分为龙鸣版和贵族版\n龙鸣version\n\n\n\n\n\n\n\n\n(此龙鸣非彼龙鸣，意为把上面的龙鸣🐴整合起来):\n#define MAXN 100005\nll n, m, A[MAXN], tree[MAXN * 4], mark[MAXN * 4]; \ninline void push_down(ll p, ll len)&#123;\n    mark[p * 2] += mark[p];\n    mark[p * 2 + 1] += mark[p];\n    tree[p * 2] += mark[p] * (len - len / 2);\n    tree[p * 2 + 1] += mark[p] * (len / 2);\n    mark[p] = 0;\n&#125;\nvoid build(ll l = 1, ll r = n, ll p = 1)&#123;\n    if (l == r)\n        tree[p] = A[l];\n    else&#123;\n        ll mid = (l + r) / 2;\n        build(l, mid, p * 2);\n        build(mid + 1, r, p * 2 + 1);\n        tree[p] = tree[p * 2] + tree[p * 2 + 1];\n    &#125;\n&#125;\nvoid update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n)&#123;\n    if (cl > r || cr &lt; l)\n        return;\n    else if (cl >= l &amp;&amp; cr &lt;= r)&#123;\n        tree[p] += (cr - cl + 1) * d;\n        if (cr > cl)\n            mark[p] += d;\n    &#125;\n    else&#123;\n        ll mid = (cl + cr) / 2;\n        push_down(p, cr - cl + 1);\n        update(l, r, d, p * 2, cl, mid);\n        update(l, r, d, p * 2 + 1, mid + 1, cr);\n        tree[p] = tree[p * 2] + tree[p * 2 + 1];\n    &#125;\n&#125;\nll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n)&#123;\n    if (cl > r || cr &lt; l)\n        return 0;\n    else if (cl >= l &amp;&amp; cr &lt;= r)\n        return tree[p];\n    else&#123;\n        ll mid = (cl + cr) / 2;\n        push_down(p, cr - cl + 1);\n        return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr);\n    &#125;\n&#125;\nint main()&#123;\n    n = read();\n    m = read();\n    for (int i = 1; i &lt;= n; ++i)\n        A[i] = read();\n    build();\n    for (int i = 0; i &lt; m; ++i)&#123;\n        ll opr = read(), l = read(), r = read();\n        if (opr == 1)&#123;\n            ll d = read();\n            update(l, r, d);\n        &#125;\n        else\n            printf(\"%lld\\n\", query(l, r));\n    &#125;\n    return 0;\n&#125;\n\n贵族version\n\n\n\n\n\n\n\n\n豪华升级plus，本来想加个乘除的发现板子不兼容，👴是懒狗\nconst int MAXN = 1e5 + 5;\nll tree[MAXN &lt;&lt; 2], mark[MAXN &lt;&lt; 2], n, m, A[MAXN];\nvoid push_down(int p, int len)&#123;\n    tree[p &lt;&lt; 1] += mark[p] * (len - len / 2);\n    mark[p &lt;&lt; 1] += mark[p];\n    tree[p &lt;&lt; 1 | 1] += mark[p] * (len / 2);\n    mark[p &lt;&lt; 1 | 1] += mark[p];\n    mark[p] = 0;\n&#125;\nvoid build(int p = 1, int cl = 1, int cr = n)&#123;\n    if (cl == cr) &#123; tree[p] = A[cl]; return; &#125;\n    int mid = (cl + cr) >> 1;\n    build(p &lt;&lt; 1, cl, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, cr);\n    tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1];\n&#125;\nll query(int l, int r, int p = 1, int cl = 1, int cr = n)&#123;\n    if (cl >= l &amp;&amp; cr &lt;= r) return tree[p];\n    push_down(p, cr - cl + 1);\n    ll mid = (cl + cr) >> 1, ans = 0;\n    if (mid >= l) ans += query(l, r, p &lt;&lt; 1, cl, mid);\n    if (mid &lt; r) ans += query(l, r, p &lt;&lt; 1 | 1, mid + 1, cr);\n    return ans;\n&#125;   \nvoid update(int l, int r, int d, int p = 1, int cl = 1, int cr = n)&#123;\n    if (cl >= l &amp;&amp; cr &lt;= r) &#123; tree[p] += d * (cr - cl + 1), mark[p] += d; return; &#125;\n    push_down(p, cr - cl + 1);\n    int mid = (cl + cr) >> 1;\n    if (mid >= l) update(l, r, d, p &lt;&lt; 1, cl, mid);\n    if (mid &lt; r) update(l, r, d, p &lt;&lt; 1 | 1, mid + 1, cr);\n    tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1];\n&#125;\n\n常见模型步骤：\n\n将问题转化成点信息和目标信息\n将目标信息根据需要扩充成区间信息\n增加信息符合区间加法\n增加标记支持区间操作\n\n\n代码中的主要模块：区间加法，标记下推，点信息-&gt;区间信息，各种操作(修改、查询…)\n\n字符串哈希\n\n\n\n\n\n\n\n\nURAL1989 Subpalindromes  题解\n给定一个字符串(长度&lt;=100000)，有两个操作。  1：改变某个字符。 2：判断某个子串是否构成回文串\n分析：\n直接判断会超时，此处用 线段树维护字符串哈希\n对于一个字符串$a[0],a[1],…,a[n-1] $它对应的哈希函数为$a[0]+a[1]*K + a[2]*K^2 +…+a[n-1]*K^{n-1}$\n再维护一个从右往左的哈希值：\n$a[0]*K^{n-1} + a[1]*K^{n-2} +…+a[n-1]$\n若是回文串，则左右的哈希值会相等。而左右哈希值相等，则很大可能这是回文串。\n若出现误判，可以再用一个K2，进行二次哈希判断，可以减小误判概率。实现上，哈希值最好对某个质数取余数，这样分布更均匀。\n解题模型：\n\n目标信息：某个区间的左，右哈希值\n点信息：一个字符\n\n目标信息已经符合区间加法，所以区间信息=目标信息\n故线段树结构：\n\n区间信息：区间哈希值\n\n点信息：一个字符\n\n\n核心：就是找到区间信息， 写好区间加法\n最长连续零\n\n\n\n\n\n\n\n\nCodeforces 527C Glass Carving 题解\n给定一个矩形，不停地纵向/横向切割，问每次切割后，最大的矩形面积是多少\n分析：\n最大矩形面积=最长的长*最宽的宽\n长宽范围均为1e5，故用01序列表示每个点是否被切割\n最长的长就是长的最长连续0的数量+1，宽同理，于是可用用线段树维护最长连续零\n解题模型：\n\n目标信息：区间最长连续零的个数\n点信息：0或1\n\n由于目标信息不符合区间加法，所以要扩充目标信息\n故线段树结构：\n\n区间信息：从左，右开始的最长连续零，本区间是否全零，本区间最长连续零\n点信息：0或1\n\n计数排序\n\n\n\n\n\n\n\n\nCodeforces 558E A Simple Task 题解\n给定一个长度不超过1e5的字符串（小写英文字母），和不超过5000个操作，每个操作 L R K 表示给区间[L,R]的字符串排序，K=1为升序，K=0为降序。 最后输出最终的字符串\n解题模型：\n\n目标信息：区间的计数排序结果\n点信息：一个字符\n\n目标信息是符合区间加法的，但是为了支持区间操作，还是需要扩充信息\n故线段树结构：\n\n目标信息：区间的计数排序结果，排序标记，排序种类（升降）\n点信息：一个字符\n\n\n\n\n\n\n\n\n\n\nTo be continued…\n","slug":"线段树","date":"2021-08-06T08:14:31.000Z","categories_index":"ALGORITHMS","tags_index":"ACM,note,algorithm","author_index":"Maskros"},{"id":"3da5b418046b7895ffe91ec3b92eec28","title":"sql学习笔记","content":"SQL结构化查询语言-Structured Query Language\n@author：Maskros\n\nType类型\n\n字符型\nVARCHAR型和CHAR型\n\n\n文本型\nTEXT\n\n\n数值型\n整数INT 、小数NUMERIC、钱数MONEY)\n\n\n逻辑型\nBIT\n\n\n日期型\nDATETIME \n\n\n\n\nOperation操作\n增删改查 CURD\ntips : 不区分大小写，列名表名前``可以省略\nSELECT(FROM)\nSELECT COLUMN 查询单个列\n\nSELECT `column_name`\nFROM `table_name`;\n\n\nSELECT COLUMN, COLUMN 查询多个列\n\nSELECT `column_name_1`, `column_name_2`  \nFROM `table_name`;\n\n\n使用 SELECT * 查询所有列\n\nSELECT * FROM `table_name`;\n\n\n使用 SELECT DISTINCT 查询不同行\n\nSELECT DISTINCT `column_name`\nFROM `table_name`\n\n​    希望查询的值都是唯一不重复的\n\nSELECT WHERE 对行进行筛选过滤\n\nSELECT `column_name1`,`column_name2`…\nFROM `table_name`\nWHERE `column_name` operator `value`;\n\nINSERT(INTO)\nINSERT INTO 在不指定列的情况下插入数据\n\nINSERT INTO `table_name`\nVALUES (value1, value2, value3,...);\n# 'value'\n\n\nINSERT INTO 在指定的列中插入数据\n\nINSERT INTO `table_name`\n(`column1`, `column2`, `column3`,...)\nVALUES (value1, value2, value3,...);\n\nUPDATE(SET)\nUPDATE 更新数据\n\nUPDATE `table_name`\nSET `column1`=value1,`column2`=value2,...\nWHERE `some_column`=some_value;\n# WHERE 可以省略\n\nDELETE(FROM)\nDELETE 删除数据\n\nDELETE FROM `table_name`\nWHERE `some_column` = `some_value`;\n\n\nTRUNCATE TABLE 清空表\n\n\nCondition条件\n比较运算符WHERE A OPERATOR B\n\n\ntips:  &lt;&gt; , != 均为不等于，但用法不同\n\n逻辑运算符\nAND 连接多条件\n\nOR 连接多条件\n\nNOT 过滤不满足条件的数据\n\n\nSELECT `column_name` \nFROM `table_name` \nWHERE NOT `condition`;\n# (condition1 operator condition2)\n\n特殊条件\nIN 查询多条件\n\nWhere `column_name1` IN (condition)\n# condition 中也可以写\nIN (select `column_name1` xxxxxxxx)\n\n\nNOT IN 排除\n\nSELECT *\nFROM `table_name`\nWHERE `column_name` (NOT) IN `value`;\n# （value1, value2）\n\n\nBETWEEN AND 查询两值间的数据范围\n\nSELECT *\nFROM `table_name`\nWHERE `column_name` BETWEEN `value` AND `value`;\n\n\nIS NULL 查询空数据\n使用 LIKE 模糊查询\n\nSELECT *\nFROM `table_name`\nWHERE `column_name` LIKE `value`;\n# LIKE `D%`\n# 'D%' 表示以D开头的所有单词，% 表示为通配符，可以替代0~n个字符\n\nORDER BY &amp; LIMIT\nORDER BY 对数据进行排序（一列/多列(多列按SELECT顺序)）\nASC (ascend)升序(默认)  |  DESC(descend) 降序\n\n\nSELECT &#96;column_name&#96;, &#96;column_name&#96;\nFROM &#96;table_name&#96;\n# WHERE XXXX\nORDER BY &#96;column_name&#96;, &#96;column_name&#96; ASC|DESC; \n\n\n使用 LIMIT 限制输出行数\noffset ：是返回集的初始标注，起始点是0\ncount ：制定返回的数量\n\n\nSELECT `column_name`, `column_name`\nFROM `table_name`\n# ORDER BY XXXX\nLIMIT `offset` , `count`;\n# offset和count通常只用一个count：LIMIT (0,)1 \n\nFunction函数\n算数函数\nAVG() 函数求数值列的平均值\n\nSELECT AVG(`column_name`) # AS `column2_name`\nFROM `table_name`;\n\n\nMAX() 函数返回指定列中的最大值\n\nMIN() 函数返回指定列中的最小值\n\nSUM() 函数统计数值列的总数\n\nROUND() 函数将数值四舍五入\n\nROUND() 返回值数据类型会被变换为一个BIGINT 。\n当 decimals 为正数时，column_name 四舍五入为 decimals 所指定的小数位数。省略decimals自动保留四舍五入后的整数。当 decimals 为负数时，column_name 则按 decimals 所指定的在小数点的左边四舍五入。\n\nSELECT ROUND(`column_name`, `decimals`) \nFROM `table_name`;\n#decimals 规定要返回的小数位数\nNULL() 函数判断空值\n\nISNULL()\nSELECT ISNULL(`column_name`)\nFROM `table_name`;\n# 返回 0 或 1\nIFNULL()\nSELECT IFNULL(`column_name`, `value`)\nFROM `table_name`;\n# 是 NULL 则返回 value 值，不是则返回对应内容\n\n\nCOUNT() 函数计数\n\n\n# COUNT(column_name) 对列具有的行数进行计数 除去值为 NULL 的行\n# 主要用于查看各列数据的数量情况，便于统计数据的缺失值\nSELECT COUNT(`column_name`) \nFROM `table_name`;\n# COUNT(*) 对表中行的数目进行计数,包括 NULL 所在行和重复项所在行\n# 主要用于查看表中的记录数\nSELECT COUNT(*) \nFROM `table_name`;\n# COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目\nSELECT COUNT(DISTINCT `column_name`) \nFROM `table_name`;\n\n时间函数\nNOW()，CURDATE()、CURTIME() 获取当前时间\n\nNOW() 返回当前日期和时间  YYYY-MM-DD hh:mm:ss\nCURDATE() 返回当前日期  YYYY-MM-DD\nCURTIME() 返回当前时间  hh:mm:ss\n要精确的秒以后的时间的话，可以在 () 中加数字，加多少，就表示精确到秒后多少位\n\n\nDATE()、TIME() 函数提取日期和时间\n\nEXTRACT() 函数提取指定的时间信息\n\nFROM\n\n返回日期/时间的单独部分\n\nunit :  YEAR (年)、MONTH (月)、DAY (日)、HOUR (小时)、MINUTE (分钟)、 SECOND (秒)\nSELECT EXTRACT(unit FROM date) # unit 为单独部分名\nFROM `table`\n# date - 合法column\n\n\nDATE_FORMAT() 格式化输出日期\n\n%Y 年份 %m 月份 %d 日期 %w 星期 %H 小时  %i 分钟 %s 秒\n小写y 表示年份后两位，小写h表示12小时计的小时\n\nSELECT DATE_FORMAT(date,'format');\nDATE_ADD() 增加时间\n\nINTERVAL\n向日期添加指定的时间间隔\n expr 是希望添加的时间间隔的数值\ntype :  MICROSECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , QUARTER , YEAR\n\nSELECT DATE_ADD(date, INTERVAL expr type)\nFROM table_name\nDATE_SUB() 减少时间\n\nDATEDIFF() 和 TIMESTAMPDIFF() 计算日期差\n\n时间1-时间2\nDATEDIFF() 默认只能计算天数差\n\nSELECT DATEDIFF(时间1,时间2) AS date_diff FROM courses;\n\n\nTIMESTAMPDIFF() 计算相差年月周日时\n类型YEAR,MONTH,WEEK,DAY,HOUR\n\n\n\nSELECT TIMESTAMPDIFF (类型,时间1,时间2) AS year_diff；\n\n\nConstraints约束\nNOT NULL非空约束\n\n强制列不接受 NULL 值\n\n# 建表\nCREATE TABLE &#96;Persons&#96; (\n    &#96;ID&#96; int NOT NULL,\n    &#96;LastName&#96; varchar(255)\n);\n# 已建表\nALTER TABLE &#96;Persons&#96;\nMODIFY &#96;Age&#96; int NOT NULL;\n# 撤销\nALTER TABLE &#96;Persons&#96;\nMODIFY &#96;Age&#96; int NULL;\n\nUNIQUE唯一约束\n\n不希望出现重复记录\nCONSTRAINT 命名\nDROP 撤销\n\n# 建表\n## MySQL\nCREATE TABLE `Persons`(\n    `P_Id` int NOT NULL,\n    UNIQUE (`P_Id`)\n)\n## SQL Server / Oracle / MS Access\nCREATE TABLE `Persons`(\n\t`P_Id` int NOT NULL UNIQUE,\n)\n## 命名+多列\nCREATE TABLE `Persons`(\n    `P_Id` int NOT NULL,\n    `LastName` varchar(255) NOT NULL,\n    CONSTRAINT uc_PersonID UNIQUE (`P_Id`,`LastName`)\n)\n\n# 已建\nALTER TABLE `Persons`\nADD UNIQUE（`P_Id`）\n## 多列\nALTER TABLE `Persons`\nADD CONSTRAINT uc_PersonID UNIQUE (`P_Id`,`LastName`)\n\n# 撤销\n## MySQL\nALTER TABLE `Persons`\nDROP INDEX uc_PersonID\n## SQL Server / Oracle / MS Access\nALTER TABLE `Persons`\nDROP CONSTRAINT uc_PersonID\n\nPRIMARY KEY主键约束\n\n简单的说，PRIMARY KEY = UNIQUE + NOT NULL \nNOT NULL UNIQUE 可以将表的一列或多列定义为唯一性属性，而 PRIMARY KEY 设为多列时，仅能保证多列之和是唯一的，具体到某一列可能会重复。\nPRIMARY KEY 可以与外键配合，从而形成主从表的关系\nPRIMARY KEY 一般在逻辑设计中用作记录标识，这也是设置 PRIMARY KEY 的本来用意，而 UNIQUE 只是为了保证域/域组的唯一性\n\n# 建表\n## MySQL\nCREATE TABLE `Persons(\n    `P_Id` int NOT NULL,\n    PRIMARY KEY (`P_Id`)\n);\n## SQL Server / Oracle / MS Access\nCREATE TABLE `Persons`(\n    `P_Id` int NOT NULL PRIMARY KEY,\n)\n## 命名+多列\nCONSTRAINT pk_PersonID PRIMARY KEY (`P_Id`,`LastName`)\n\n# 已建\nALTER TABLE `Persons`\nADD PRIMARY KEY (`P_Id`)\n## 多列\nALTER TABLE `Persons`\nADD CONSTRAINT pk_PersonID PRIMARY KEY (`P_Id`,`LastName`)\n\n# 撤销\n## MySQL\nALTER TABLE `Persons`\nDROP PRIMARY KEY\n## SQL Server / Oracle / MS Access\nALTER TABLE `Persons`\nDROP CONSTRAINT pk_PersonID\n\nFOREIGN KEY外键约束 \n\n一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY \n保证数据的完整性和一致性\n在两个表之间建立关系，需要指定引用主表的哪一列，REFERENCES 表示引用一个表\n\n# 建表\n## MySQL\nCREATE TABLE `Orders`(\n    `P_Id` int,\n    FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)\n)\n## SQL Server / Oracle / MS Access\nCREATE TABLE `Orders`(\n    P_Id int FOREIGN KEY REFERENCES Persons(P_Id)\n)\n## 命名+多列\nCONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)\nREFERENCES Persons(P_Id)\n\n# 已建\nALTER TABLE `Orders`\nADD FOREIGN KEY (P_Id)\nREFERENCES Persons(P_Id)\n## 命名\nALTER TABLE `Orders`\nADD CONSTRAINT fk_PerOrders\nFOREIGN KEY (P_Id)\nREFERENCES Persons(P_Id)\n\n# 撤销\n## MySQL\nALTER TABLE `Orders`\nDROP FOREIGN KEY fk_PerOrders\n## SQL Server / Oracle / MS Access\nALTER TABLE `Orders`\nDROP CONSTRAINT fk_PerOrders\n\nCHECK检查约束 \n\n限制列中的值的范围，评估插入或修改后的值。满足条件插入，否不插\n可以为同一列指定多个 CHECK 约束\n\n# 建表\nCREATE TABLE `courses`(\n\t`student_count` int, …\n\tCHECK (Condition1 AND Condition2)\n)\n## 命名\nCONSTRAINT chk_courses CHECK (`student_count` > 0);\n\n# 已建\nALTER TABLE `courses` \nADD CHECK ( `student_count` > 0);\n## ADD CONSTRAINT XXX CHECK (Condition);\n\n# 撤销\n## MySQL\nALTER TABLE `courses` \nDROP CHECK chk_courses\n## SQL Server / Oracle / MS Access\nALTER TABLE `courses` \nDROP CONSTRAINT chk_courses\n\nDEFAULT默认约束\n`City` varchar(255) DEFAULT 'Sandnes'\n`OrderDate` date DEFAULT GETDATE()  # 可以用函数\n\nALTER TABLE `Persons`\nALTER `City` SET DEFAULT 'SANDNES'\nADD CONSTRAINT ab_c DEFAULT 'SANDNES' for `City`\n\nALTER `City` DROP DEFAULT\nALTER COLUMN `City` DROP DEFAULT\n\nJoin多表联结\n联结\n在一条 SELECT 语句中关联多个表，返回一组输出\n\n两大主角 : 主键 (PRIMARY KEY) 和外键 (FOREIGN KEY)\n\n使用完全限定列名（用一个点分隔表名和列名）\n\n\n# condition\n`table1`.`common_field` = `table2`.`common_field`\n\n\nJOIN 连接子句\nINNER JOIN 内连接：如果表中有至少一个匹配，则返回行\nOUTER JOIN 外连接\nLEFT JOIN：即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行\n\n\nFULL JOIN 全连接：只要其中一个表中存在匹配，则返回行\nCROSS JOIN 交叉连接：又称笛卡尔积，两个表数据一一对应，返回结果的行数等于两个表行数的乘积\n\n\n\nINNER JOIN内连接 又称为EQUIJOIN 等值连接\n\n内连接就是取两个表的交集，返回的结果就是连接的两张表中都满足条件的部分\n\nSELECT `table1`.`column1`, `table2`.`column2`...\nFROM `table1`\n(INNER) JOIN `table2` # INNER 可省略不写\nON `table1`.`common_field` = `table2`.`common_field`;\n# ON CONDITION\n\n# exp\nSELECT `c`.`id`, `c`.`name` AS `course_name`, `t`.`name` AS `teacher_email`\nFROM `courses` `c`\n    (INNER) JOIN `teachers` `t` ON `c`.`teacher_id` = `t`.`id`;\n\n\ncourses c 等同于 courses AS c ，给courses 表取别名为 c\n\nOUTER JOIN外连接 分为左外连接 右外连接 全外连接\n\n外连接可以将某个表格中，在另外一张表格中无对应关系，但是也能将数据匹配出来\n\nSELECT column_name 1,column_name 2 ... column_name n\n    FROM table1\n        LEFT | RIGHT | FULL  (OUTER) JOIN table2\n        ON CONDITION;\n\n\nLEFT JOIN : 以左表为参考表，返回左表中的所有记录，加上右表中匹配到的记录\nRIGHT JOIN :  以右表为参考表\nFULL JOIN : 只要左表和右表其中一个表中存在匹配，则返回行\n\n\n\n\n\n\n\n\n\n\ntips :  MySQL 数据库不支持全连接，想要实现全连接可以使用 UNION ALL 来将左连接和右连接结果组合在一起实现全连接\n\nUNION :  联合，把两次或多次查询结果合并起来\n要求：两次查询的列数必须一致，同时，每条 SELECT 语句中的列的顺序必须相同\nUNION 会去掉重复的行。 如果不想去掉重复的行，可以使用 UNION ALL \n如果子句中有 order by , limit，需用括号()包起来。推荐放到所有子句之后，即对最终合并的结果来排序或筛选\n\n\n\nSELECT column_name 1,column_name 2 ... column_name n\n    FROM table1\n        LEFT JOIN table2 ON CONDITION \nUNION\nSELECT column_name 1,column_name 2 ... column_name n\n    FROM table1\n        RIGHT JOIN table2 ON CONDITION ;\n\nCROSS JOIN交叉连接 结果也称作笛卡尔积\n\n返回左表中的所有行，左表中的每一行与右表中的所有行组合。即将两个表的数据一一对应，其查询结果的行数为左表中的行数乘以右表中的行数。\n\n# 隐式连接 不需要使用 CROSS JOIN 关键字\nSELECT `table1`.`column1`, `table2`.`column2`...\nFROM `table1`,`table2`;\n# 显式连接\nSELECT `table1`.`column1`, `table2`.`column2`...\nFROM `table1`\nCROSS JOIN `table2`;\n\n\n通过增加联结条件，使用 WHERE 子句帮助筛选过滤无效的数据\n\n\nAdvanced Select分组查询\nGROUP BY 子句\n\n对同类的数据进行分类\n\nSELECT `column_name`, aggregate_function(`column_name`)\nFROM `table_name`\nWHERE `column_name` operator value\nGROUP BY `column_name`;\nHAVING 子句\n\n使用 WHERE 条件子句时不能与聚合函数联合使用\n HAVING 子句经常与 GROUP BY 联合使用，HAVING 子句就是对分组统计函数进行过滤的子句\nHAVING 子句对于 GROUP BY 子句设置条件的方式其实与 WHERE 子句与 SELECT 的方式类似，语法相近，但 WHERE 子句搜索条件是在分组操作之前，而 HAVING 则是在之后\n\nSELECT   `column_name`, aggregate_function(`column_name`) \nFROM     `table_name` \nWHERE    `column_name` operator value \nGROUP BY `column_name` \nHAVING   aggregate_function(`column_name`) operator value;\n\n\nex: 查询教师表 teachers计算不同国籍教师的平均年龄和所有教师的平均年龄，比较两者的大小，最后返回大于所有教师平均年龄的不同国籍下的全部教师信息\n\n# 子查询\nSELECT * FROM teachers \n    WHERE country IN\n        (SELECT country FROM teachers GROUP BY country\n            HAVING AVG(age) > (SELECT AVG(age) FROM teachers))\n\n子查询(Base)\nSELECT 语句中的子查询\n\nSELECT `column_name(s)`\nFROM `table_name`\nWHERE `column_name` OPERATOR (\n    SELECT `column_name(s)`\n    FROM `table_name`\n);\n\n\nINSERT 语句中的子查询\n\nINSERT INTO `table_name`\n\tSELECT `colnum_name(s)`\n\tFROM `table_name`\n\t[ WHERE VALUE OPERATOR ]\n\n\nUPDATE 语句中的子查询\n\nUPDATE `table_name` \nSET `column_name` = `new_value`\nWHERE `column_name` OPERATOR \n   (SELECT `column_name`\n   FROM `table_name`\n   [WHERE] )\n\n\nDELETE 语句中的子查询\n\nDELETE FROM `table_name`\nWHERE `column_name` OPERATOR \n   (SELECT `column_name`\n   FROM `table_name`  \n   [WHERE] )\n\n子查询(Adv.)\n内联视图子查询\n\n将查询的结果集作为一个查询表，继续进行查询操作\n\nSELECT *\nFROM (\n\tSELECT * xxxx\n) `T`\nWHERE xxx = (\n\tSELECT xxxx\n);\nIN 操作符的多行子查询 / NOT IN \n\nANY 操作符的多行子查询\n\n在子查询中使用 ANY ，表示与子查询返回的任何值比较为真，则返回真\n\nSELECT `column_name(s)`\nFROM `table_name`\nWHERE `column_name` OPERATOR\n   ANY(SELECT column_name\n   FROM table_name)\nALL 操作符的多行子查询\n\n在子查询中使用 ALL ，表示与子查询返回的所有值比较为真，则返回真\n\n\n多列子查询\n\nHAVING 子句中的子查询\n\n\n","slug":"sql","date":"2021-07-28T16:07:28.000Z","categories_index":"NOTE","tags_index":"note,sql","author_index":"Maskros"},{"id":"1f59b3eb6e524ce1c0f6b34920ea6c38","title":"博弈论","content":"博弈论Game Theory\n\nNim游戏属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下：\n\n两名选手交替移动，在有限的合法移动集合中任选一种进行移动\n对于任何一种局面，合法的移动集合只取决于局面本身\n到谁无法移动谁就输了\n\n以下给出 P/N 的定义：\n\nP-Position：先手必败点 (Previous)\nN-Position：先手必胜点 (Next)\n可知所有终结点都是P点，一步就能到P点的一定是N点，通过一步只能到N点的一定是P点\n\n下面来说说Nim游戏：“有若干堆石子，每堆石子的数量有限，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为没有任何合法的移动）“，简单来想，我们可以想到一个递归的算法：对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P，那么向这个子局面的移动就是必胜策略。这其中有大量的重叠子问题，所以可以用DP或者记忆化搜索的方法以提高效率。\n但是👴们已经有了一个nb的结论：\n对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1^a2^…^an=0，其中^表示异或(xor)运算\n根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。\n\nSprague-Grundy函数ICG的抽象模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负\n首先定义mex(minimal excludnt) 运算：\n施加于集合，表示最小的不属于这个集合的非负整数，exp: mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。\n下面给出SG函数的定义：\n对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数如下：sg(x)=mex{ sg(y) | y是x的后继 }。\n结论：当SG[x] = 0时，x为必败状态；当SG[x] &gt; 0时，x为必胜状态\n所以从1~n的SG函数值应该如何计算呢？\n\n使用 数组 f[ ] 将可改变当前状态 的方式记录下来\n然后我们使用 另一个数组 S[ ] 将当前状态x 的后继状态标记\n模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)\n不断重复 2-3 的步骤，即完成计算 1-n 的SG函数值\n\nSG定理：SG(G)=SG(G1)^SG(G2)^…^SG(Gn)，原游戏的SG函数值是它的所有子游戏的SG函数值的异或\n\n解题模型\n把原游戏分解成多个独立的子游戏，则原游戏的SG函数值就变为SG(G)=SG(G1)^SG(G2)^…^Sg(Gn)\n\n分别考虑每一个子游戏，计算其SG值\nSG值的计算方法（important）：\n​    a. 可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1) （Bash game）\n​    b. 可选步数为任意步，SG(x) = x（Nim game）\n​    c. 可选步数为一系列不连续的数，用模板计算\n\n\n板子\n\n\n\n\n\n\n\n\n首选打表预处理，打表没法使的时候就怼dfs\n☆打表&#x2F;&#x2F;打表\nint f[N],SG[MAXN],S[MAXN]; &#x2F;&#x2F; f[] 可改变当前状态的方式(可取走石子个数)   S[] 当前状态的后继状态集合\n\nvoid getSG(int n) &#123;\n\tint i,j;\n\tmemset(SG,0,sizeof(SG));\n\tfor(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; \n\t\tmemset(S,0,sizeof(S));\n\t\tfor(j&#x3D;0; f[j]&lt;&#x3D;i &amp;&amp; j&lt;&#x3D;N;j++)\n\t\t\tS[SG[i-f[j]]]&#x3D;1; &#x2F;&#x2F;S[]数组来保存当前状态的后继状态集合\n\t\tfor(j&#x3D;0;j&lt;&#x3D;n;j++)&#123; \n        \tif(!S[j])&#123;&#x2F;&#x2F;模拟mex运算\n\t\t\t\tSG[i]&#x3D;j;\n\t\t\t\tbreak;\n            &#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n深搜&#x2F;&#x2F;注意 f数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍\n&#x2F;&#x2F;n是集合f的大小 f[i]是定义的特殊取法规则的数组\nint f[110],SG[10010],n;\n\nint SG_dfs(int x)&#123;\n    int i;\n    if(SG[x]!&#x3D;-1)\n        return SG[x];\n    bool vis[110];\n    memset(vis,0,sizeof(vis));\n    for(i&#x3D;0;i&lt;n;i++)&#123;\n        if(x&gt;&#x3D;f[i])&#123;\n            SG_dfs(x-f[i]);\n            vis[SG[x-f[i]]]&#x3D;1;\n        &#125;\n    &#125;\n    int e;\n    for(i&#x3D;0;;i++)\n        if(!vis[i])&#123;\n            e&#x3D;i;\n            break;\n        &#125;\n    return SG[x]&#x3D;e;\n&#125;\n\n\n常见博弈Bash Game只有一堆n个物品，两个人轮流取物，每次至少取一个，最多取m个。最后取光者得胜（谁拿了最后一个谁赢）\n结论：最优选择为保持给对手留下 m+1 的倍数\n\nif(n%(m+1) != 0)  则先手必赢 \n\nif(n%(m+1) == 0)  则后手必赢\n\n\nWythoff Game\n\n\n\n\n\n\n\n\n各位👴属实🐮，黄金分割数（1+√5）/2 = 1.618 都给整上了\n有两堆各若干个物品，两个人轮流从某一堆取物或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜\n这里用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势\n由ak，bk组成的矩形近似为黄金矩形\n结论：\n\n(int)((bk-ak)*(1+sqrt(5.0))/2) != ak ,  先手必赢\n\n(int)((bk-ak)*(1+sqrt(5.0))/2) == ak , 后手必赢\n\n\nNim Game若干堆石子，每堆石子的数量有限，两个人可以选择一堆石子并拿走若干颗\n结论：xor 略\nFibonacci Nim有一堆个数为n的石子，游戏双方轮流取石子，满足: (1)先手不能在第一次把所有的石子取完 (2)每次可以取的石子数介于1到对手刚取的石子数的2倍之间(包含)  (3) 取走最后一个石子的人为赢家\n结论：当n为Fibonacci数的时候，必败\nf[i]：1,2,3,5,8,13,21,34,55,89……\n","slug":"博弈论","date":"2001-01-09T16:00:00.000Z","categories_index":"ALGORITHMS","tags_index":"ACM,note,algorithm","author_index":"Maskros"}]