{"title":"博弈论","uid":"1f59b3eb6e524ce1c0f6b34920ea6c38","slug":"博弈论","date":"2021-07-31T01:51:28.000Z","updated":"2021-08-27T03:19:04.133Z","comments":true,"path":"api/articles/博弈论.json","keywords":null,"cover":null,"content":"<h1 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h1><p>Game Theory</p>\n<hr>\n<h2 id=\"Nim游戏\"><a href=\"#Nim游戏\" class=\"headerlink\" title=\"Nim游戏\"></a>Nim游戏</h2><p>属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下：</p>\n<ul>\n<li>两名选手交替移动，在有限的合法移动集合中任选一种进行移动</li>\n<li>对于任何一种局面，合法的移动集合只取决于局面本身</li>\n<li>到谁无法移动谁就输了</li>\n</ul>\n<p>以下给出 P/N 的定义：</p>\n<ul>\n<li>P-Position：先手必败点 (Previous)</li>\n<li>N-Position：先手必胜点 (Next)</li>\n<li>可知所有终结点都是P点，一步就<strong>能</strong>到P点的一定是N点，通过一步<strong>只能</strong>到N点的一定是P点</li>\n</ul>\n<p>下面来说说Nim游戏：“有若干堆石子，每堆石子的数量有限，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为没有任何合法的移动）“，简单来想，我们可以想到一个递归的算法：对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P，那么向这个子局面的移动就是必胜策略。这其中有大量的重叠子问题，所以可以用DP或者记忆化搜索的方法以提高效率。</p>\n<p>但是👴们已经有了一个nb的结论：</p>\n<p><strong>对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1^a2^…^an=0，其中^表示异或(xor)运算</strong></p>\n<p>根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。</p>\n<hr>\n<h2 id=\"Sprague-Grundy函数\"><a href=\"#Sprague-Grundy函数\" class=\"headerlink\" title=\"Sprague-Grundy函数\"></a>Sprague-Grundy函数</h2><p>ICG的抽象模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负</p>\n<p>首先定义mex(minimal excludnt) 运算：</p>\n<p>施加于集合，表示<strong>最小</strong>的<strong>不属于</strong>这个集合的<strong>非负整数</strong>，exp: mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p>\n<p>下面给出SG函数的定义：</p>\n<p>对于一个给定的<strong>有向无环图</strong>，定义关于图的每个顶点的Sprague-Garundy函数如下：sg(x)=mex{ sg(y) | y是x的<strong>后继</strong> }。</p>\n<p>结论：当SG[x] = 0时，x为必败状态；当SG[x] &gt; 0时，x为必胜状态</p>\n<p>所以从1~n的SG函数值应该如何计算呢？</p>\n<ol>\n<li>使用 数组 f[ ] 将可改变当前状态 的方式记录下来</li>\n<li>然后我们使用 另一个数组 S[ ] 将当前状态x 的后继状态标记</li>\n<li>模拟mex运算，也就是我们在标记值中 搜索 <strong>未被标记值</strong> 的最小值，将其赋值给SG(x)</li>\n<li>不断重复 2-3 的步骤，即完成计算 1-n 的SG函数值</li>\n</ol>\n<p><strong>SG定理</strong>：<strong>SG(G)=SG(G1)^SG(G2)^…^SG(Gn)<strong>，原游戏的SG函数值是它的所有子游戏的SG函数值的</strong>异或</strong></p>\n<hr>\n<h2 id=\"解题模型\"><a href=\"#解题模型\" class=\"headerlink\" title=\"解题模型\"></a>解题模型</h2><ol>\n<li><p>把原游戏分解成多个独立的子游戏，则原游戏的SG函数值就变为<strong>SG(G)=SG(G1)^SG(G2)^…^Sg(Gn)</strong></p>\n</li>\n<li><p>分别考虑每一个子游戏，计算其SG值</p>\n<p><strong>SG值的计算方法</strong>（important）：</p>\n<p>​    a. <strong>可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1)</strong> <strong>（Bash game）</strong></p>\n<p>​    b. <strong>可选步数为任意步，SG(x) = x（Nim game）</strong></p>\n<p>​    c. <strong>可选步数为一系列不连续的数，用模板计算</strong></p>\n</li>\n</ol>\n<h2 id=\"板子\"><a href=\"#板子\" class=\"headerlink\" title=\"板子\"></a>板子</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>首选打表预处理，打表没法使的时候就怼dfs</p></blockquote>\n<h3 id=\"☆打表\"><a href=\"#☆打表\" class=\"headerlink\" title=\"☆打表\"></a>☆打表</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;打表\nint f[N],SG[MAXN],S[MAXN]; &#x2F;&#x2F; f[] 可改变当前状态的方式(可取走石子个数)   S[] 当前状态的后继状态集合\n\nvoid getSG(int n) &#123;\n\tint i,j;\n\tmemset(SG,0,sizeof(SG));\n\tfor(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; \n\t\tmemset(S,0,sizeof(S));\n\t\tfor(j&#x3D;0; f[j]&lt;&#x3D;i &amp;&amp; j&lt;&#x3D;N;j++)\n\t\t\tS[SG[i-f[j]]]&#x3D;1; &#x2F;&#x2F;S[]数组来保存当前状态的后继状态集合\n\t\tfor(j&#x3D;0;j&lt;&#x3D;n;j++)&#123; \n        \tif(!S[j])&#123;&#x2F;&#x2F;模拟mex运算\n\t\t\t\tSG[i]&#x3D;j;\n\t\t\t\tbreak;\n            &#125;\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"深搜\"><a href=\"#深搜\" class=\"headerlink\" title=\"深搜\"></a>深搜</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;注意 f数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍\n&#x2F;&#x2F;n是集合f的大小 f[i]是定义的特殊取法规则的数组\nint f[110],SG[10010],n;\n\nint SG_dfs(int x)&#123;\n    int i;\n    if(SG[x]!&#x3D;-1)\n        return SG[x];\n    bool vis[110];\n    memset(vis,0,sizeof(vis));\n    for(i&#x3D;0;i&lt;n;i++)&#123;\n        if(x&gt;&#x3D;f[i])&#123;\n            SG_dfs(x-f[i]);\n            vis[SG[x-f[i]]]&#x3D;1;\n        &#125;\n    &#125;\n    int e;\n    for(i&#x3D;0;;i++)\n        if(!vis[i])&#123;\n            e&#x3D;i;\n            break;\n        &#125;\n    return SG[x]&#x3D;e;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"常见博弈\"><a href=\"#常见博弈\" class=\"headerlink\" title=\"常见博弈\"></a>常见博弈</h2><h3 id=\"Bash-Game\"><a href=\"#Bash-Game\" class=\"headerlink\" title=\"Bash Game\"></a>Bash Game</h3><p>只有一堆n个物品，两个人轮流取物，每次至少取一个，最多取m个。最后取光者得胜（谁拿了最后一个谁赢）</p>\n<p>结论：最优选择为保持给对手留下 <strong>m+1</strong> 的倍数</p>\n<ul>\n<li><p>if(n%(m+1) != 0)  则先手必赢 </p>\n</li>\n<li><p>if(n%(m+1) == 0)  则后手必赢</p>\n</li>\n</ul>\n<h3 id=\"Wythoff-Game\"><a href=\"#Wythoff-Game\" class=\"headerlink\" title=\"Wythoff Game\"></a>Wythoff Game</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>各位👴属实🐮，黄金分割数（1+√5）/2 = 1.618 都给整上了</p></blockquote>\n<p>有两堆各若干个物品，两个人轮流从某一堆取物或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜</p>\n<p>这里用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为<strong>局势</strong></p>\n<p>由ak，bk组成的矩形近似为黄金矩形</p>\n<p>结论：</p>\n<ul>\n<li><p>(int)((bk-ak)*(1+sqrt(5.0))/2) != ak ,  先手必赢</p>\n</li>\n<li><p>(int)((bk-ak)*(1+sqrt(5.0))/2) == ak , 后手必赢</p>\n</li>\n</ul>\n<h3 id=\"Nim-Game\"><a href=\"#Nim-Game\" class=\"headerlink\" title=\"Nim Game\"></a>Nim Game</h3><p>若干堆石子，每堆石子的数量有限，两个人可以选择一堆石子并拿走若干颗</p>\n<p>结论：xor 略</p>\n<h3 id=\"Fibonacci-Nim\"><a href=\"#Fibonacci-Nim\" class=\"headerlink\" title=\"Fibonacci Nim\"></a>Fibonacci Nim</h3><p>有一堆个数为n的石子，游戏双方轮流取石子，满足: (1)先手不能在第一次把所有的石子取完 (2)每次可以取的石子数介于1到对手刚取的石子数的2倍之间(包含)  (3) 取走最后一个石子的人为赢家</p>\n<p>结论：<strong>当n为Fibonacci数的时候，必败</strong></p>\n<p>f[i]：1,2,3,5,8,13,21,34,55,89……</p>\n","text":"博弈论Game Theory Nim游戏属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下： 两名选手交替移动，在有限的合法移动集合中任选一种进行移动 对于任何一种局面，合法的移动集合只取决于局面本身 到谁无法移动谁就输了 以下给出...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","count":5,"path":"api/categories/ALGORITHMS.json"}],"tags":[{"name":"ACM","slug":"ACM","count":15,"path":"api/tags/ACM.json"},{"name":"algorithm","slug":"algorithm","count":7,"path":"api/tags/algorithm.json"},{"name":"note","slug":"note","count":9,"path":"api/tags/note.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%9A%E5%BC%88%E8%AE%BA\"><span class=\"toc-text\">博弈论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nim%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">Nim游戏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Sprague-Grundy%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Sprague-Grundy函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%A2%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">解题模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%BF%E5%AD%90\"><span class=\"toc-text\">板子</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%98%86%E6%89%93%E8%A1%A8\"><span class=\"toc-text\">☆打表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%90%9C\"><span class=\"toc-text\">深搜</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%8D%9A%E5%BC%88\"><span class=\"toc-text\">常见博弈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Bash-Game\"><span class=\"toc-text\">Bash Game</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Wythoff-Game\"><span class=\"toc-text\">Wythoff Game</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Nim-Game\"><span class=\"toc-text\">Nim Game</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fibonacci-Nim\"><span class=\"toc-text\">Fibonacci Nim</span></a></li></ol></li></ol></li></ol>","author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"我确实不会线段树","uid":"e4b68a32c6fd94c2953f12692556d556","slug":"线段树","date":"2021-08-06T08:14:31.000Z","updated":"2021-10-19T12:15:21.108Z","comments":true,"path":"api/articles/线段树.json","keywords":null,"cover":[],"text":"线段树Segment Tree 一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来艹了 原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","count":5,"path":"api/categories/ALGORITHMS.json"}],"tags":[{"name":"ACM","slug":"ACM","count":15,"path":"api/tags/ACM.json"},{"name":"algorithm","slug":"algorithm","count":7,"path":"api/tags/algorithm.json"},{"name":"note","slug":"note","count":9,"path":"api/tags/note.json"}],"author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}