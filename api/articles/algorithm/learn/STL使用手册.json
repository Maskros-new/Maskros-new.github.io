{"title":"STL使用手册","uid":"0b411eca06d29c39e2fc21f5cd175527","slug":"algorithm/learn/STL使用手册","date":"2021-08-13T06:15:31.000Z","updated":"2022-01-22T09:38:07.375Z","comments":true,"path":"api/articles/algorithm/learn/STL使用手册.json","keywords":null,"cover":"https://img0.baidu.com/it/u=1597304645,862627513&fm=26&fmt=auto&gp=0.jpg","content":"<h1 id=\"STL使用手册\"><a href=\"#STL使用手册\" class=\"headerlink\" title=\"STL使用手册\"></a>STL使用手册</h1><p>Standard Template Library</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>又名《👴怕忘了先把他写下来》</p></blockquote>\n<h2 id=\"我-是-谁\"><a href=\"#我-是-谁\" class=\"headerlink\" title=\"我 是 谁 ?\"></a>我 是 谁 ?</h2><p>斯丹德儿的 坦普雷特 莱博瑞 即标准模板库</p>\n<ul>\n<li><p>重要特点：数据结构和算法的分离</p>\n</li>\n<li><p>重要特性：不是面向对象的</p>\n</li>\n<li><p>逻辑层次：体现了泛型化程序设计的思想</p>\n</li>\n<li><p>实现层次：以一种类型参数化的方式实现，基于模板(template)</p>\n</li>\n</ul>\n<p>六大组件：</p>\n<ul>\n<li>容器（Container），是一种数据结构，如list，vector，deques ，以模板类的方法提供 ;</li>\n<li>迭代器（Iterator），提供了访问容器中对象的方法。迭代器就如同一个指针。C++的指针也是一种迭代器。迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；</li>\n<li>算法（Algorithm），是用来操作容器中的数据的模板函数。如sort()，find()，函数本身与他们操作的数据的结构和类型无关 ;</li>\n<li>仿函数（Functor）</li>\n<li>适配器（Adaptor）</li>\n<li>分配器（allocator）</li>\n</ul>\n<h2 id=\"👴-常用的\"><a href=\"#👴-常用的\" class=\"headerlink\" title=\"👴 常用的\"></a>👴 常用的</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>以下不按顺序，想到啥就写啥，有个🥚的顺序</p></blockquote>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><p>字符串</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;构造函数\nstring s(str,index); &#x2F;&#x2F;将字符串str内“始于位置index”的部分当作字符串的初值\nstring s(str,index,n); &#x2F;&#x2F;将字符串str内“始于index且长度顶多n”的部分作为字符串的初值\nstring s(n,c); &#x2F;&#x2F;生成一个字符串，包含n个c字符(char)\nstring s(str.begin(),str.end()); &#x2F;&#x2F;以区间begin():end() (不包含end())内的字符作为字符串s的初值\n\n&#x2F;&#x2F;操作函数\ns.erase(s.begin(),s.end()); &#x2F;&#x2F;删除\ns.replace(pos,len,str); &#x2F;&#x2F;替换，从pos开始长为len被替换为str\ns.find(str,pos&#x3D;0); &#x2F;&#x2F;从pos向右查找，返回str第一次出现的位置\ns.rfind(str,pos&#x3D;npos); &#x2F;&#x2F;从pos反向查找，返回找到位置\ns.find_first_of(str); &#x2F;&#x2F;查找第一个属于str中字符的位置\ns.find_first_not_of(str); &#x2F;&#x2F;查找第一个不属于str中字符位置\ns.find_last_of(str);\ns.find_last_not_of(str);\ns1.compare(s2); &#x2F;&#x2F;比较，相等0大于1小于-1\ns1.compare(pos,len,s2)&#x2F;&#x2F;从s1的pos开始长为len与s2比较<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"stringstream\"><a href=\"#stringstream\" class=\"headerlink\" title=\"stringstream\"></a>stringstream</h4><p>自动且直接的类型转换</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">stringstream sstream;\n&#x2F;&#x2F;数据类型转换\nstring str;\nint a&#x3D;123;\nsstream &lt;&lt; a;\nsstream &gt;&gt; str;\ncout&lt;&lt;str;\ncout&lt;&lt;sstream.str(); \n&#x2F;&#x2F;多个字符串拼接\nsstream &lt;&lt; &quot;xxxx&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;aaaaa&quot;;\n&#x2F;&#x2F;清空stringstream\nsstream.clear();\nsstream.str(&quot;&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h4><p>便携结构体</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;访问通过first second\n&#x2F;&#x2F;可以通过一般运算符比较，先比较first再second\npair&lt;string,int&gt; p (str,123);\npair&lt;string,int&gt; p &#x3D; make_pair(str,123);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h4><p>向量容器，动态存储</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; v;\nv.front(); v.back();\nv.begin(); v.end();\nv.push_back();\nv.size();\nv.empty();\nv.clear();\nv.pop_back(); &#x2F;&#x2F;删除表尾元素\nv.insert(it,x); &#x2F;&#x2F;向迭代器it 指向的元素前插入新元素x\nv.insert(it,n,x); &#x2F;&#x2F;插入n个x\nv.insert(it, first, last); &#x2F;&#x2F;将由迭代器first和last 所指定的序列[first, last)插入到迭代器it指向的元素前面\nv.erase(it); &#x2F;&#x2F;删\nv.erase(first,last);\nv.reverse(n); &#x2F;&#x2F;预分配缓冲空间，使存储空间至少可容纳n个元素\nv.resize(n); &#x2F;&#x2F;改变序列长度，超出元素删除，若源空间小于n，则默认值填满空间\nv.resize(n,val); &#x2F;&#x2F;超出的用val填满<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h4><p>栈</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">stack&lt;int&gt; s;\ns.push(x);\ns.pop();\ns.top();\ns.empty();\ns.size();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h4><p>队列，优先队列，双端队列</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; queue\nqueue&lt;int&gt; q;\nq.push(x);\nq.pop();\nq.front(); q.back();\nq.empty();\nq.size();\n\n&#x2F;&#x2F; priority_queue\npriority&lt;int&gt; q; &#x2F;&#x2F;默认大者优先\npriority&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; &#x2F;&#x2F;小的先出队 三个模板参数：元素类型，容器类型，比较算子\n&#x2F;&#x2F; 优先级设置：定义结构体\nstruct Student&#123;\n    int num;\n    int grade;\n    friend bool operator &lt; (Student s1, Student s2)&#123;\n        return s1.grade&lt;s2.grade;\n        &#x2F;&#x2F;此处小于号还是小于的作用，故队列中以成绩高的学生优先，若反之变号即可\n    &#125;\n&#125;;\npriority_queue&lt;Student&gt; q;\n&#x2F;&#x2F;也可以把重载的函数写在结构体外面\nstruct cmp&#123;\n    bool operator() (Student s1, Student s2)&#123;\n        return s1.grade&lt;s2.grade;\n    &#125;\n&#125;;&#x2F;&#x2F;tips:优先队列中的cmp和sort中的cmp效果相反\npriority_queue&lt;Student,vector&lt;Student&gt;,cmp&gt; q;\n&#x2F;&#x2F;如果结构体内数据庞大，像出现字符串或者数组，建议使用引用来提高效率。此时比较类的参数需要加上 const 和 &amp;\nfriend bool operator &lt; (const Student &amp;s1, const Student &amp;s2)&#123;\n\treturn s1.grade&lt;s2.grade;\n&#125;\n\n&#x2F;&#x2F;deque\ndeque&lt;int&gt; d;\nd.push_back(x); &#x2F;&#x2F;尾部插入\nd.push_front(x); &#x2F;&#x2F;首部插入元素\nd.insert(d.begin()+len,x); &#x2F;&#x2F;中间插入元素\n&#x2F;&#x2F;可以通过 d[0] d[1] 访问\nd.pop_front(); &#x2F;&#x2F;删除头部\nd.pop_back();\nd.erase(d.begin()+len); &#x2F;&#x2F;删除指定位置元素，可以写多个<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>键值对，元素按关键字有序，内部红黑树</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; map空间占用率高\nmap&lt;string,int&gt; m;\nm[key]&#x3D;value;\nm.insert(make_pair(key,value));\nm.erase(key);\nm.erase(it);\nm.clear();\nm.size();\t\nmap&lt;string,int&gt;::iterator it;\nfor(it&#x3D;mp.begin();it!&#x3D;mp.end();++it)&#123;\n    cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;\n&#125;\n\n&#x2F;&#x2F; unordered_map 效率较高 内部哈希表\n&#x2F;&#x2F; 对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>无重复，按键值自动排序</p>\n<p>数据结构为红黑树。以节点形式保存（动态)，用迭代器访问</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">set&lt;int&gt; s;\ns.begin(); s.end();\ns.clear();\ns.empty();\ns.erase(x);\ns.find(x);\ns.insert(x);\ns.size();\ns.lower_bound(value); &#x2F;&#x2F;返回第一个大于等于value的定位器\ns.upper_bound(value); &#x2F;&#x2F;返回最后一个大于等于value的定位器\nset&lt;int&gt;::iterator it;\nfor(it&#x3D;s.begin();it!&#x3D;s.end();it++)\n\tcout&lt;&lt;*it&lt;&lt;&quot; &quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>链表</p>\n<ul>\n<li>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector </li>\n<li>如果你需要大量的插入和删除，而不关心随即存取，则应使用list </li>\n<li>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">list&lt;int&gt; a(n);\nlist&lt;int&gt; a&#123;1,2,3,4&#125;;\na.push_back(x);\na.push_front(x);\na.empty();\na.resize(n);\na.clear();\na.front(); a.back();\na.reverse();\na.merge(b); &#x2F;&#x2F;b变空，a尾插入b\na.insert(pos,x);\na.insert(pos,b.begin(),b.end());\na.erase(a.begin(),a.end());\na.remove(x);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h4><p>存放二进制0/1的容器，可以声明非常大的二进制位而不限于64，用来优化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bitset&lt;N&gt; b; &#x2F;&#x2F;表示长为N的二进制串\n&#x2F;&#x2F; 通过b[pos]访问\nb.any(); &#x2F;&#x2F;存在为1的二进制位\nb.none(); &#x2F;&#x2F;不存在为1的二进制位\nb.count(); &#x2F;&#x2F;置1的二进制位的个数\nb.size();\nb.test(pos); &#x2F;&#x2F;在pos位处是否为1\nb.set(); &#x2F;&#x2F;所有位置1\nb.set(pos);\nb.reset(); &#x2F;&#x2F;所有位置0\nb.reset(pos);\nb.flip(); &#x2F;&#x2F;逐位取反\nb.flip(pos);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h3><h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">lower_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于等于x的位置\nupper_bound(a,a+n,x); &#x2F;&#x2F;二分查找第一个大于x的位置\nfind();\nrfind();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">sort(a,a+n,cmp); &#x2F;&#x2F;默认ASC<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">swap(a,b); &#x2F;&#x2F;交换\nreplace(pos,len,str); &#x2F;&#x2F;替换\nunique(a,a+n); &#x2F;&#x2F;去除相邻的重复元素,会把重复的藏到末尾，使用前需要先排序<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"排列\"><a href=\"#排列\" class=\"headerlink\" title=\"排列\"></a>排列</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">next_permutation(a,a+n); &#x2F;&#x2F;下一个全排列\nprev_permutation(a,a+n); &#x2F;&#x2F;上一个全排列\n&#x2F;&#x2F;函数返回bool值，一般配合while()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">isalpha(char x); &#x2F;&#x2F;小写字母返回2，大写字母1，非字母0\t\ntolower(char x); toupper(char x); &#x2F;&#x2F;返回小写，大写字母的ASCII值，非字母则相等\n&#x2F;&#x2F;海伦公式\np&#x3D;(a+b+c)&#x2F;2;\ns&#x3D;sqrt(p*(p-a)*(p-b)*(p-c));\nabs(int x); &#x2F;&#x2F;只用于整数\nfabs(double x); &#x2F;&#x2F;精度更高<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<p>暂时就这些了，寄！</p>\n","text":"STL使用手册Standard Template Library 又名《👴怕忘了先把他写下来》 我 是 谁 ?斯丹德儿的 坦普雷特 莱博瑞 即标准模板库 重要特点：数据结构和算法的分离 重要特性：不是面向对象的 逻辑层次：体现了泛型化程序设计的思想 实现层次：以一种类型参数化的方...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","count":5,"path":"api/categories/ALGORITHMS.json"}],"tags":[{"name":"ACM","slug":"ACM","count":17,"path":"api/tags/ACM.json"},{"name":"note","slug":"note","count":10,"path":"api/tags/note.json"},{"name":"algorithm","slug":"algorithm","count":7,"path":"api/tags/algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#STL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C\"><span class=\"toc-text\">STL使用手册</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91-%E6%98%AF-%E8%B0%81\"><span class=\"toc-text\">我 是 谁 ?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%F0%9F%91%B4-%E5%B8%B8%E7%94%A8%E7%9A%84\"><span class=\"toc-text\">👴 常用的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#string\"><span class=\"toc-text\">string</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#stringstream\"><span class=\"toc-text\">stringstream</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pair\"><span class=\"toc-text\">pair</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#vector\"><span class=\"toc-text\">vector</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#stack\"><span class=\"toc-text\">stack</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#queue\"><span class=\"toc-text\">queue</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#set\"><span class=\"toc-text\">set</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#list\"><span class=\"toc-text\">list</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bitset\"><span class=\"toc-text\">bitset</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#functions\"><span class=\"toc-text\">functions</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">查找</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9\"><span class=\"toc-text\">修改</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%88%97\"><span class=\"toc-text\">排列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}},"mapped":true,"prev_post":{"title":"SpringMVC学习杂记","uid":"ebad22b2d3ed9cce7b0eb0ed467a5511","slug":"note/springMVC","date":"2021-09-15T18:37:28.000Z","updated":"2022-01-22T09:37:58.349Z","comments":true,"path":"api/articles/note/springMVC.json","keywords":null,"cover":"https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0803%2Fe7e5645ep00qx8udl000vc000dc007im.png&thumbnail=650x2147483647&quality=80&type=jpg","text":"SpringMVC学习杂记 注：杂记即为看到啥记啥 毫无章法 乱jb记 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由M...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"NOTE","slug":"NOTE","count":5,"path":"api/categories/NOTE.json"}],"tags":[{"name":"note","slug":"note","count":10,"path":"api/tags/note.json"},{"name":"springMVC","slug":"springMVC","count":1,"path":"api/tags/springMVC.json"},{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}}},"next_post":{"title":"我确实不会线段树","uid":"e4b68a32c6fd94c2953f12692556d556","slug":"algorithm/learn/线段树","date":"2021-08-06T08:14:31.000Z","updated":"2022-01-22T09:37:32.683Z","comments":true,"path":"api/articles/algorithm/learn/线段树.json","keywords":null,"cover":"https://img0.baidu.com/it/u=1851813078,3504357646&fm=26&fmt=auto&gp=0.jpg","text":"线段树Segment Tree 一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来艹了 原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","count":5,"path":"api/categories/ALGORITHMS.json"}],"tags":[{"name":"ACM","slug":"ACM","count":17,"path":"api/tags/ACM.json"},{"name":"note","slug":"note","count":10,"path":"api/tags/note.json"},{"name":"algorithm","slug":"algorithm","count":7,"path":"api/tags/algorithm.json"}],"author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}}}}