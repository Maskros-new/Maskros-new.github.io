{"title":"博弈论","uid":"1f59b3eb6e524ce1c0f6b34920ea6c38","slug":"algorithm/learn/博弈论","date":"2021-07-31T01:51:28.000Z","updated":"2022-02-04T15:44:39.081Z","comments":true,"path":"api/articles/algorithm/learn/博弈论.json","keywords":null,"cover":"http://img.mp.itc.cn/upload/20160916/f7f2d7ebe46b4a49ae4bd4baf8e30044_th.png","content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css\"><h1><span id=\"博弈论\">博弈论</span></h1><p>Game Theory</p>\n<hr>\n<h2><span id=\"nim游戏\">Nim游戏</span></h2><p>属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下：</p>\n<ul>\n<li>两名选手交替移动，在有限的合法移动集合中任选一种进行移动</li>\n<li>对于任何一种局面，合法的移动集合只取决于局面本身</li>\n<li>到谁无法移动谁就输了</li>\n</ul>\n<p>以下给出 P/N 的定义：</p>\n<ul>\n<li>P-Position：先手必败点 (Previous)</li>\n<li>N-Position：先手必胜点 (Next)</li>\n<li>可知所有终结点都是P点，一步就<strong>能</strong>到P点的一定是N点，通过一步<strong>只能</strong>到N点的一定是P点</li>\n</ul>\n<p>下面来说说Nim游戏：“有若干堆石子，每堆石子的数量有限，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为没有任何合法的移动）“，简单来想，我们可以想到一个递归的算法：对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P，那么向这个子局面的移动就是必胜策略。这其中有大量的重叠子问题，所以可以用DP或者记忆化搜索的方法以提高效率。</p>\n<p>但是👴们已经有了一个nb的结论：</p>\n<p><strong>对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1^a2^…^an=0，其中^表示异或(xor)运算</strong></p>\n<p>根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。</p>\n<hr>\n<h2><span id=\"sprague-grundy函数\">Sprague-Grundy函数</span></h2><p>ICG的抽象模型：给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负</p>\n<p>首先定义mex(minimal excludnt) 运算：</p>\n<p>施加于集合，表示<strong>最小</strong>的<strong>不属于</strong>这个集合的<strong>非负整数</strong>，exp: mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p>\n<p>下面给出SG函数的定义：</p>\n<p>对于一个给定的<strong>有向无环图</strong>，定义关于图的每个顶点的Sprague-Garundy函数如下：sg(x)=mex{ sg(y) | y是x的<strong>后继</strong> }。</p>\n<p>结论：当SG[x] = 0时，x为必败状态；当SG[x] &gt; 0时，x为必胜状态</p>\n<p>所以从1~n的SG函数值应该如何计算呢？</p>\n<ol>\n<li>使用 数组 f[ ] 将可改变当前状态 的方式记录下来</li>\n<li>然后我们使用 另一个数组 S[ ] 将当前状态x 的后继状态标记</li>\n<li>模拟mex运算，也就是我们在标记值中 搜索 <strong>未被标记值</strong> 的最小值，将其赋值给SG(x)</li>\n<li>不断重复 2-3 的步骤，即完成计算 1-n 的SG函数值</li>\n</ol>\n<p><strong>SG定理</strong>：<strong>SG(G)=SG(G1)^SG(G2)^…^SG(Gn)</strong>，原游戏的SG函数值是它的所有子游戏的SG函数值的<strong>异或</strong></p>\n<hr>\n<h2><span id=\"解题模型\">解题模型</span></h2><ol>\n<li><p>把原游戏分解成多个独立的子游戏，则原游戏的SG函数值就变为<strong>SG(G)=SG(G1)^SG(G2)^…^Sg(Gn)</strong></p>\n</li>\n<li><p>分别考虑每一个子游戏，计算其SG值</p>\n<p><strong>SG值的计算方法</strong>（important）：</p>\n<p>​    a. <strong>可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1)</strong> <strong>（Bash game）</strong></p>\n<p>​    b. <strong>可选步数为任意步，SG(x) = x（Nim game）</strong></p>\n<p>​    c. <strong>可选步数为一系列不连续的数，用模板计算</strong></p>\n</li>\n</ol>\n<h2><span id=\"板子\">板子</span></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>首选打表预处理，打表没法使的时候就怼dfs</p></blockquote>\n<h3><span id=\"打表\">☆打表</span></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;打表\nint f[N],SG[MAXN],S[MAXN]; &#x2F;&#x2F; f[] 可改变当前状态的方式(可取走石子个数)   S[] 当前状态的后继状态集合\n\nvoid getSG(int n) &#123;\n\tint i,j;\n\tmemset(SG,0,sizeof(SG));\n\tfor(i&#x3D;1;i&lt;&#x3D;n;i++) &#123; \n\t\tmemset(S,0,sizeof(S));\n\t\tfor(j&#x3D;0; f[j]&lt;&#x3D;i &amp;&amp; j&lt;&#x3D;N;j++)\n\t\t\tS[SG[i-f[j]]]&#x3D;1; &#x2F;&#x2F;S[]数组来保存当前状态的后继状态集合\n\t\tfor(j&#x3D;0;j&lt;&#x3D;n;j++)&#123; \n        \tif(!S[j])&#123;&#x2F;&#x2F;模拟mex运算\n\t\t\t\tSG[i]&#x3D;j;\n\t\t\t\tbreak;\n            &#125;\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3><span id=\"深搜\">深搜</span></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;注意 f数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍\n&#x2F;&#x2F;n是集合f的大小 f[i]是定义的特殊取法规则的数组\nint f[110],SG[10010],n;\n\nint SG_dfs(int x)&#123;\n    int i;\n    if(SG[x]!&#x3D;-1)\n        return SG[x];\n    bool vis[110];\n    memset(vis,0,sizeof(vis));\n    for(i&#x3D;0;i&lt;n;i++)&#123;\n        if(x&gt;&#x3D;f[i])&#123;\n            SG_dfs(x-f[i]);\n            vis[SG[x-f[i]]]&#x3D;1;\n        &#125;\n    &#125;\n    int e;\n    for(i&#x3D;0;;i++)\n        if(!vis[i])&#123;\n            e&#x3D;i;\n            break;\n        &#125;\n    return SG[x]&#x3D;e;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2><span id=\"常见博弈\">常见博弈</span></h2><h3><span id=\"bash-game\">Bash Game</span></h3><p>只有一堆n个物品，两个人轮流取物，每次至少取一个，最多取m个。最后取光者得胜（谁拿了最后一个谁赢）</p>\n<p>结论：最优选择为保持给对手留下 <strong>m+1</strong> 的倍数</p>\n<ul>\n<li><p>if(n%(m+1) != 0)  则先手必赢 </p>\n</li>\n<li><p>if(n%(m+1) == 0)  则后手必赢</p>\n</li>\n</ul>\n<h3><span id=\"wythoff-game\">Wythoff Game</span></h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>各位👴属实🐮，黄金分割数（1+√5）/2 = 1.618 都给整上了</p></blockquote>\n<p>有两堆各若干个物品，两个人轮流从某一堆取物或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜</p>\n<p>这里用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为<strong>局势</strong></p>\n<p>由ak，bk组成的矩形近似为黄金矩形</p>\n<p>结论：</p>\n<ul>\n<li><p>(int)((bk-ak)*(1+sqrt(5.0))/2) != ak ,  先手必赢</p>\n</li>\n<li><p>(int)((bk-ak)*(1+sqrt(5.0))/2) == ak , 后手必赢</p>\n</li>\n</ul>\n<h3><span id=\"nim-game\">Nim Game</span></h3><p>若干堆石子，每堆石子的数量有限，两个人可以选择一堆石子并拿走若干颗</p>\n<p>结论：xor 略</p>\n<h3><span id=\"fibonacci-nim\">Fibonacci Nim</span></h3><p>有一堆个数为n的石子，游戏双方轮流取石子，满足: (1)先手不能在第一次把所有的石子取完 (2)每次可以取的石子数介于1到对手刚取的石子数的2倍之间(包含)  (3) 取走最后一个石子的人为赢家</p>\n<p>结论：<strong>当n为Fibonacci数的时候，必败</strong></p>\n<p>f[i]：1,2,3,5,8,13,21,34,55,89……</p>\n","text":"博弈论Game Theory Nim游戏属于 ICG (Impartial Combinatorial Games) 的一种，满足条件如下： 两名选手交替移动，在有限的合法移动集合中任选一种进行移动 对于任何一种局面，合法的移动集合只取决于局面本身 到谁无法移动谁就输了 以下给出...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","count":6,"path":"api/categories/ALGORITHMS.json"}],"tags":[{"name":"ACM","slug":"ACM","count":27,"path":"api/tags/ACM.json"},{"name":"note","slug":"note","count":11,"path":"api/tags/note.json"},{"name":"博弈","slug":"博弈","count":2,"path":"api/tags/博弈.json"},{"name":"algorithm","slug":"algorithm","count":8,"path":"api/tags/algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">博弈论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Nim游戏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Sprague-Grundy函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">解题模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">板子</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">☆打表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">深搜</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">常见博弈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Bash Game</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Wythoff Game</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Nim Game</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Fibonacci Nim</span></a></li></ol></li></ol></li></ol>","author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}},"mapped":true,"prev_post":{"title":"我确实不会线段树","uid":"e4b68a32c6fd94c2953f12692556d556","slug":"algorithm/learn/线段树","date":"2021-08-06T08:14:31.000Z","updated":"2022-01-25T10:28:54.978Z","comments":true,"path":"api/articles/algorithm/learn/线段树.json","keywords":null,"cover":"https://img0.baidu.com/it/u=1851813078,3504357646&fm=26&fmt=auto&gp=0.jpg","text":"线段树Segment Tree 一个问题，只要能化成对一些连续点l的修改和统计问题，基本就可以用线段树来艹了 原理：将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","count":6,"path":"api/categories/ALGORITHMS.json"}],"tags":[{"name":"ACM","slug":"ACM","count":27,"path":"api/tags/ACM.json"},{"name":"note","slug":"note","count":11,"path":"api/tags/note.json"},{"name":"algorithm","slug":"algorithm","count":8,"path":"api/tags/algorithm.json"}],"author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}}},"next_post":{"title":"sql学习笔记","uid":"3da5b418046b7895ffe91ec3b92eec28","slug":"note/sql","date":"2021-07-28T16:07:28.000Z","updated":"2022-01-22T09:36:48.564Z","comments":true,"path":"api/articles/note/sql.json","keywords":null,"cover":"https://img.php.cn/upload/article/000/000/194/94356ed93d087dbd43d26949a1f09ec5.png","text":"SQL结构化查询语言-Structured Query Language @author：Maskros Type类型 字符型 VARCHAR型和CHAR型 文本型 TEXT 数值型 整数INT 、小数NUMERIC、钱数MONEY) 逻辑型 BIT 日期型 DATETIME O...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"NOTE","slug":"NOTE","count":5,"path":"api/categories/NOTE.json"}],"tags":[{"name":"note","slug":"note","count":11,"path":"api/tags/note.json"},{"name":"sql","slug":"sql","count":1,"path":"api/tags/sql.json"}],"author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}}}}