{"title":"Trie专题训练","uid":"845d8d8490a208e5b118592a6863cd87","slug":"algorithm/exercise/trie_problem","date":"2021-11-27T04:20:00.000Z","updated":"2022-01-22T09:37:15.580Z","comments":true,"path":"api/articles/algorithm/exercise/trie_problem.json","keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css\"><h1><span id=\"trie-专题训练\">Trie 专题训练</span></h1><p>0.0</p>\n<h2><span id=\"0x01-统计难题-hdu-1251\">0x01 统计难题 HDU 1251</span></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://acm.dingbacode.com/showproblem.php?pid=1251\">link</a></p>\n<p>题意：给了一堆字符串，统计以模式串作前缀出现的单词个数</p>\n<p>trie入门题，存结点时统计一下过当前结点的单词个数即可</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树\n&#x2F;&#x2F;很多题都是要用到节点下标来表示某个字符串\nconst int maxn &#x3D; 2e6 + 5;  &#x2F;&#x2F;如果是64MB可以开到2e6+5，尽量开大\nint tree[maxn][30];        &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号\nbool flagg[maxn];          &#x2F;&#x2F;表示以该节点结尾是一个单词\nint tot;                   &#x2F;&#x2F;总节点数\nint cnt[maxn];\nvoid insert_(char* str) &#123;\n    int len &#x3D; strlen(str);\n    int root &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; len; i++) &#123;\n        int id &#x3D; str[i] - &#39;a&#39;;\n        if (!tree[root][id])\n            tree[root][id] &#x3D; ++tot;\n        root &#x3D; tree[root][id];\n        cnt[root]++;\n    &#125;\n    flagg[root] &#x3D; true;\n&#125;\nbool find_(char* str) &#123;  &#x2F;&#x2F;查询操作，按具体要求改动\n    int len &#x3D; strlen(str);\n    int root &#x3D; 0;\n    int ans;\n    for (int i &#x3D; 0; i &lt; len; i++) &#123;\n        int id &#x3D; str[i] - &#39;a&#39;;\n        if (!tree[root][id])\n            return false;\n        root &#x3D; tree[root][id];\n        &#x2F;&#x2F; if(!flagg[root] &amp;&amp; i&#x3D;&#x3D;len-1) return false;   &#x2F;&#x2F;判断是否两个单词完全匹配\n    &#125;\n    ans &#x3D; cnt[root];\n    cout&lt;&lt;ans&lt;&lt;endl;\n    return true;\n&#125;\nvoid init() &#123;  &#x2F;&#x2F;最后清空，节省时间\n    for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123;\n        flagg[i] &#x3D; false;\n        for (int j &#x3D; 0; j &lt; 10; j++)\n            tree[i][j] &#x3D; 0;\n    &#125;\n    memset(cnt,0,sizeof(cnt));\n    tot &#x3D; 0;  &#x2F;&#x2F;RE有可能是这里的问题\n&#125;\nvoid solve() &#123;\n    char str[15];\n    init();\n    while(gets(str)&amp;&amp;str[0]!&#x3D;&#39;\\0&#39;)&#123;\n        insert_(str);\n    &#125;\n    while(gets(str)&amp;&amp;str[0]!&#x3D;EOF)&#123;\n        bool t &#x3D; find_(str);\n        if(!t) cout&lt;&lt;0&lt;&lt;endl;    \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2><span id=\"0x02-remember-the-word-la-3942\">0x02 Remember the Word LA 3942</span></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://vjudge.net/problem/UVALive-3942\">link</a></p>\n<p>题意：</p>\n<p>给出一个由S个不同单词组成的字典和一个长字符串，把这个字符串分解成若干个单词的连接(可重复使用)，有多少种方法。ex: 有四个单词：a, b, cd, ab；则abcd有两种分解方法：a+b+cd 和 ab+cd</p>\n<p>思路：</p>\n<p>dp + Trie</p>\n<p>计数问题考虑dp：</p>\n<p>考虑状态：<code>dp[i]</code> 为以i开始的后缀的方案数</p>\n<p>考虑转移：因为单词长度不大于100，我们可以直接暴力向后看当前单词是否存在，所以可以用Trie或者字符串哈希完成</p>\n<p>令dp(i)表示从字符i开始的字符串，dp(i)=sum{dp(i+len(x))}, x是s[i…L]的前缀。然后把所有可分解成的单词构造成一颗Trie树，再让母串在上面跑，dp[0]即是方案总数。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;bits&#x2F;stdc++.h&gt;\n#define maxn 300005\n#define mod 20071027\nchar P[maxn];\n#define rep(i, x, y) for (int i &#x3D; x; i &lt; y; i++)\n#define red(i, x, y) for (int i &#x3D; x; i &gt;&#x3D; y; i--)\nusing namespace std;\nint dp[maxn];        &#x2F;&#x2F;dp[i] 为以i开始的后缀的方案数\nint tree[maxn][30];  &#x2F;&#x2F;tree[i][j]表示节点i的第j个儿子的节点编号\nbool flagg[maxn];    &#x2F;&#x2F;表示以该节点结尾是一个单词\nint tot;             &#x2F;&#x2F;总节点数\nint m;               &#x2F;&#x2F;主串长度\nvoid insert_(char* str) &#123;\n    int len &#x3D; strlen(str);\n    int root &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; len; i++) &#123;\n        int id &#x3D; str[i] - &#39;a&#39;;\n        if (!tree[root][id])\n            tree[root][id] &#x3D; ++tot;\n        root &#x3D; tree[root][id];\n    &#125;\n    flagg[root] &#x3D; true;\n&#125;\nvoid find_(int id) &#123;  &#x2F;&#x2F;查询操作，按具体要求改动\n    int root &#x3D; 0;\n    for (int i &#x3D; id; i &lt;&#x3D; m; i++) &#123;\n        int k &#x3D; P[i] - &#39;a&#39;;\n        if (!tree[root][k]) break;\n        root &#x3D; tree[root][k];\n        if (flagg[root])    \n            dp[id] &#x3D; (dp[id] + dp[i + 1]) % mod;\n    &#125;\n&#125;\nvoid init() &#123; \n    for (int i &#x3D; 0; i &lt;&#x3D; tot; i++) &#123;\n        flagg[i] &#x3D; false;\n        for (int j &#x3D; 0; j &lt; 30; j++)\n            tree[i][j] &#x3D; 0;\n    &#125;\n    memset(dp, 0, sizeof(dp));\n    tot &#x3D; 0; \n&#125;\nchar c[105];\nint main() &#123;\n    long long times &#x3D; 0;\n    init();\n    while (scanf(&quot;%s&quot;, P)!&#x3D;EOF) &#123;\n        times++;\n        int S;\n        cin &gt;&gt; S;\n        &#x2F;&#x2F; init();\n        rep(i, 0, S) &#123;\n            scanf(&quot;%s&quot;, c);\n            insert_(c);\n        &#125;\n        m &#x3D; strlen(P);\n        dp[m] &#x3D; 1;\n        red(i, m, 0) &#123;\n            find_(i);\n        &#125;\n        cout &lt;&lt; &quot;Case &quot; &lt;&lt; times &lt;&lt; &quot;: &quot; &lt;&lt; dp[0] &lt;&lt; endl;\n        init();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2><span id=\"0x03-strcmp-anyone\">0x03 “strcmp()” Anyone?</span></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://vjudge.net/problem/UVA-11732\">link</a></p>\n<p>题意：</p>\n<p>输入n个字符串，两两调用一次strcmp()，问字符比较的总次数是多少？ex:</p>\n<p><code>strcmp(“than”, &quot;that&quot;)：cnt = 7</code></p>\n<p>题解：两个字符串比较次数其实是 <strong>相同字符数*2 + (存在不同字符? 1 : 0)</strong>；然后建字典树，dfs一下即可。因为节点的个数比较多，所以用左孩子右兄弟的方法建立字典树。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int maxnode &#x3D; 4000 * 1000 + 10;\nconst int sigma_size &#x3D; 26;\n&#x2F;&#x2F; 字母表为全体小写字母的Trie\nstruct Trie &#123;\n    int head[maxnode];  &#x2F;&#x2F; head[i]为第i个结点的左儿子编号\n    int next[maxnode];  &#x2F;&#x2F; next[i]为第i个结点的右兄弟编号\n    char ch[maxnode];   &#x2F;&#x2F; ch[i]为第i个结点上的字符\n    int tot[maxnode];   &#x2F;&#x2F; tot[i]为第i个结点为根的子树包含的叶结点总数\n    int sz;             &#x2F;&#x2F; 结点总数\n    long long ans;      &#x2F;&#x2F; 答案\n    void clear() &#123;\n        sz &#x3D; 1;\n        tot[0] &#x3D; head[0] &#x3D; next[0] &#x3D; 0;\n    &#125;  &#x2F;&#x2F; 初始时只有一个根结点\n\n    &#x2F;&#x2F; 插入字符串s（包括最后的&#39;\\0&#39;），沿途更新tot\n    void insert(const char* s) &#123;\n        int u &#x3D; 0, v, n &#x3D; strlen(s);\n        tot[0]++;\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            &#x2F;&#x2F; 找字符a[i]\n            bool found &#x3D; false;\n            for (v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v])\n                if (ch[v] &#x3D;&#x3D; s[i]) &#123;  &#x2F;&#x2F; 找到了\n                    found &#x3D; true;\n                    break;\n                &#125;\n            if (!found) &#123;\n                v &#x3D; sz++;  &#x2F;&#x2F; 新建结点\n                tot[v] &#x3D; 0;\n                ch[v] &#x3D; s[i];\n                next[v] &#x3D; head[u];\n                head[u] &#x3D; v;  &#x2F;&#x2F; 插入到链表的首部\n                head[v] &#x3D; 0;\n            &#125;\n            u &#x3D; v;\n            tot[u]++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 统计LCP&#x3D;u的所有单词两两的比较次数之和\n    void dfs(int depth, int u) &#123;\n        if (head[u] &#x3D;&#x3D; 0)  &#x2F;&#x2F; 叶结点\n            ans +&#x3D; tot[u] * (tot[u] - 1) * depth;\n        else &#123;\n            int sum &#x3D; 0;\n            for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v])\n                sum +&#x3D; tot[v] * (tot[u] - tot[v]);  &#x2F;&#x2F; 子树v中选一个串，其他子树中再选一个\n            ans +&#x3D; sum &#x2F; 2 * (2 * depth + 1);       &#x2F;&#x2F; 除以2是每种选法统计了两次\n            for (int v &#x3D; head[u]; v !&#x3D; 0; v &#x3D; next[v])\n                dfs(depth + 1, v);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 统计\n    long long count() &#123;\n        ans &#x3D; 0;\n        dfs(0, 0);\n        return ans;\n    &#125;\n&#125;;\nconst int maxl &#x3D; 1000 + 10;  &#x2F;&#x2F; 每个单词最大长度\nint n;\nchar word[maxl];\nTrie trie;\nint main() &#123;\n    int kase &#x3D; 1;\n    while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123;\n        trie.clear();\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            scanf(&quot;%s&quot;, word);\n            trie.insert(word);\n        &#125;\n        printf(&quot;Case %d: %lld\\n&quot;, kase++, trie.count());\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"Trie 专题训练0.0 0x01 统计难题 HDU 1251 link 题意：给了一堆字符串，统计以模式串作前缀出现的单词个数 trie入门题，存结点时统计一下过当前结点的单词个数即可 &#x2F;&#x2F;对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树 &...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"ALGORITHM TRAINING","slug":"ALGORITHM-TRAINING","count":2,"path":"api/categories/ALGORITHM-TRAINING.json"}],"tags":[{"name":"ACM","slug":"ACM","count":26,"path":"api/tags/ACM.json"},{"name":"string","slug":"string","count":5,"path":"api/tags/string.json"},{"name":"dp","slug":"dp","count":5,"path":"api/tags/dp.json"},{"name":"algorithm","slug":"algorithm","count":8,"path":"api/tags/algorithm.json"},{"name":"Trie","slug":"Trie","count":2,"path":"api/tags/Trie.json"},{"name":"dfs","slug":"dfs","count":1,"path":"api/tags/dfs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">Trie 专题训练</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">0x01 统计难题 HDU 1251</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">0x02 Remember the Word LA 3942</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">0x03 “strcmp()” Anyone?</span></a></li></ol></li></ol>","author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}},"mapped":true,"prev_post":{"title":"Notes on Kurose's Computer Networking：A TOP-DOWN APPROACH","uid":"73cfcb86305a1dc05f8e11e3779f31e9","slug":"note/ComputerNetwork_Note","date":"2021-12-10T05:44:28.000Z","updated":"2021-12-25T07:11:55.191Z","comments":true,"path":"api/articles/note/ComputerNetwork_Note.json","keywords":null,"cover":[],"text":"Notes on Kurose’s Computer NetworkingA TOP-DOWN APPROACH Thanks to 我爹的博客，让我偷了不少😋 Chapter 1 Computer Networks and the Internet1.1 What is the...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"NOTE","slug":"NOTE","count":5,"path":"api/categories/NOTE.json"}],"tags":[{"name":"note","slug":"note","count":11,"path":"api/tags/note.json"},{"name":"ComputerNetwork","slug":"ComputerNetwork","count":1,"path":"api/tags/ComputerNetwork.json"}],"author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}}},"next_post":{"title":"Trie","uid":"f9c5a67ed89813cc4d2fda9f690375dd","slug":"algorithm/learn/trie","date":"2021-11-27T03:55:50.000Z","updated":"2022-01-22T09:37:06.172Z","comments":true,"path":"api/articles/algorithm/learn/trie.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F202001%2F20200113201445546817.jpg&refer=http%3A%2F%2Fimage.bubuko.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640577246&t=4f6b0ed3fef63f86e86da00e1973e1f0","text":"Trie字典树/前缀树 什么是Trie 从根节点到每个单词结点的路径上所有字母连接成的字符串就是该结点对应的字符串 多叉树，最大分支数由字典的字符集含有的字符数决定 操作 插入字符串 insert 初始化 root = 0 , 遍历字符串, 对于其每一个字符, 计算其映射值 id...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ALGORITHMS","slug":"ALGORITHMS","count":6,"path":"api/categories/ALGORITHMS.json"}],"tags":[{"name":"ACM","slug":"ACM","count":26,"path":"api/tags/ACM.json"},{"name":"string","slug":"string","count":5,"path":"api/tags/string.json"},{"name":"note","slug":"note","count":11,"path":"api/tags/note.json"},{"name":"algorithm","slug":"algorithm","count":8,"path":"api/tags/algorithm.json"},{"name":"Trie","slug":"Trie","count":2,"path":"api/tags/Trie.json"}],"author":{"name":"Maskros","slug":"blog-author","avatar":"/img/logo_Maskros.jpg","link":"/","description":"Be Legendary within the hasty keys","socials":{"github":"https://github.com/Maskros-new","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"iconfont icon-bilibili-line","link":"https://space.bilibili.com/355516889"},"codeforces":{"icon":"iconfont icon-codeforces","link":"https://codeforces.com/profile/1ronMaker"},"mail":{"icon":"iconfont icon-mail","link":"mailto:1164528260@qq.com"}}}}}}